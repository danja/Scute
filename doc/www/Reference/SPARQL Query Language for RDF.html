<!DOCTYPE HTML PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" lang="en"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">




<meta name="generator" content="Microsoft FrontPage 6.0">
<meta name="generator" content="Emacs 22">
<meta name="RCS-Id" content="$Id: Overview.html,v 1.14 2008/01/16 15:38:27 eric Exp $">
<title>SPARQL Query Language for RDF</title>
<style type="text/css">
/*<![CDATA[*/
pre.data	{ border: thin solid #88AA88;
                  background-color: #E8F0E8;
                  margin: 1em 4em 1em 0em ; }
                  
.wgNote	{ border: thin solid #88AA88;
          background-color: #E8F0E8;
          padding: 0.5em ;
          margin: 1em 4em 1em 2em ; }

/*]]>*/
</style>
<link rel="stylesheet" type="text/css" href="SPARQL%20Query%20Language%20for%20RDF_files/local.css">
<link rel="stylesheet" type="text/css" href="SPARQL%20Query%20Language%20for%20RDF_files/W3C-REC.css">
</head><body>

<div class="head">
  <p><a href="http://www.w3.org/">
  <img src="SPARQL%20Query%20Language%20for%20RDF_files/w3c_home.png" alt="W3C" width="72" height="48"></a></p>

  <h1 id="main">SPARQL Query Language for RDF</h1>
  <h2><a name="w3c-doctype" id="w3c-doctype">W3C Recommendation 15 January 2008</a></h2>
  <dl>
	<dt>This version:</dt>
	<dd><a href="http://www.w3.org/TR/2008/REC-rdf-sparql-query-20080115/">http://www.w3.org/TR/2008/REC-rdf-sparql-query-20080115/</a></dd>
	<dt>Latest version:</dt>
	<dd><a href="http://www.w3.org/TR/rdf-sparql-query/">http://www.w3.org/TR/rdf-sparql-query/</a></dd>
	<dt>Previous version:</dt>
	<dd><a href="http://www.w3.org/TR/2007/PR-rdf-sparql-query-20071112/">http://www.w3.org/TR/2007/PR-rdf-sparql-query-20071112/</a></dd>
    <dt>Editors:</dt>
    <dd>Eric Prud'hommeaux, W3C &lt;<a href="mailto:eric@w3.org">eric@w3.org</a>&gt;<br>
    Andy Seaborne, Hewlett-Packard Laboratories, Bristol &lt;<a href="mailto:andy.seaborne@hp.com">andy.seaborne@hp.com</a>&gt;</dd>
  </dl>
<p>Please refer to the <a href="http://www.w3.org/2001/sw/DataAccess/query-errata"><strong>errata</strong></a> for this document, which may include some normative corrections.</p>

<p>See also <a href="http://www.w3.org/2003/03/Translations/byTechnology?technology=sparql-query"><strong>translations</strong></a>.</p>

<p class="copyright"><a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a> © 2006-2007 <a href="http://www.w3.org/"><acronym title="World Wide Web Consortium">W3C</acronym></a><sup>®</sup> (<a href="http://www.csail.mit.edu/"><acronym title="Massachusetts Institute of Technology">MIT</acronym></a>, <a href="http://www.ercim.org/"><acronym title="European Research Consortium for Informatics and Mathematics">ERCIM</acronym></a>, <a href="http://www.keio.ac.jp/">Keio</a>), All Rights Reserved. W3C <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>, <a href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and <a href="http://www.w3.org/Consortium/Legal/copyright-documents">document use</a> rules apply.</p>
</div>

<hr title="Separator for header">
<div>
  <h2 class="notoc"><a id="abstract" name="abstract">Abstract</a></h2>
  <p>
    RDF is a directed, labeled graph data format for representing information 
    in the Web. This specification defines the syntax and semantics of the 
    SPARQL query language for RDF. SPARQL can be used to express queries 
    across diverse data sources, whether the data is stored natively as RDF or 
    viewed as RDF via middleware. SPARQL contains capabilities for querying 
    required and optional graph patterns along with their conjunctions and 
    disjunctions. SPARQL also supports extensible value testing and 
    constraining queries by source RDF graph. The results of SPARQL queries 
    can be results sets or RDF graphs.
  </p>

</div>
<div>
<h2 id="status">Status of This Document</h2>

<p><em>This section describes the status of this document at the time of
 its publication. Other documents may supersede this document. A list of
 current W3C publications and the latest revision of this technical 
report can be found in the <a href="http://www.w3.org/TR/">W3C technical reports index</a> at http://www.w3.org/TR/.</em></p>

<p>This is a <a href="http://www.w3.org/2005/10/Process-20051014/tr.html#RecsW3C">W3C Recommendation</a>.</p>

<p>This document has been reviewed by W3C Members, by software 
developers, and by other W3C groups and interested parties, and is 
endorsed by the Director as a W3C Recommendation. It is a stable 
document and may be used as reference material or cited from another 
document. W3C's role in making the Recommendation is to draw attention 
to the specification and to promote its widespread deployment. This 
enhances the functionality and interoperability of the Web.</p>

<p>Comments on this document should be sent to <a href="mailto:public-rdf-dawg-comments@w3.org">public-rdf-dawg-comments@w3.org</a>, a mailing list with a <a href="http://lists.w3.org/Archives/Public/public-rdf-dawg-comments">public archive</a>.
 Questions and comments about SPARQL that are not related to this 
specification, including extensions and features, can be discussed on 
the mailing list <a href="mailto:public-sparql-dev@w3.org">public-sparql-dev@w3.org</a>, (<a href="http://lists.w3.org/Archives/Public/public-sparql-dev">public archive</a>).</p>

<p>This document was produced by the <a href="http://www.w3.org/2001/sw/DataAccess/">RDF Data Access Working Group</a>, which is part of the <a href="http://www.w3.org/2001/sw/Activity">W3C Semantic Web Activity</a>. The first release of this document as a Working Draft was 
12 October 2004
 and the Working Group has 
addressed a number of <a href="http://lists.w3.org/Archives/Public/public-rdf-dawg-comments/">comments received</a> and <a href="http://www.w3.org/2001/sw/DataAccess/issues">issues</a> since then. Two <a href="#chlog">changes have been made and logged</a> since the publication of the <a href="http://www.w3.org/TR/2007/PR-rdf-sparql-query-20071112/">November 2007 Proposed Recommendation</a>.</p>

<p id="implExp">The Working Group's 
<a href="http://www.w3.org/2001/sw/DataAccess/impl-report-ql">SPARQL Query Language For RDF Implementation Report</a>
 demonstrates that the goals for interoperable
implementations, set in the 
<a href="http://www.w3.org/TR/2007/CR-rdf-sparql-query-20070614">June 2007 Candidate Recommendation</a>
, were achieved.</p>

<p><span class="postponed">The Data Access Working Group has postponed 12 issues, including <a href="http://www.w3.org/2001/sw/DataAccess/issues#countAggregate">aggregate functions</a>, and <a href="http://www.w3.org/2001/sw/DataAccess/issues#update">an update language</a>.</span></p>

<p>This document was produced by a group operating under the <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/">5 February 2004 W3C Patent Policy</a>. W3C maintains a <a rel="disclosure" href="http://www.w3.org/2004/01/pp-impl/35463/status">public list of any patent disclosures</a>
 made in connection with the deliverables of the group; that page also 
includes instructions for disclosing a patent. An individual who has 
actual knowledge of a patent which the individual believes contains <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">Essential Claim(s)</a> must disclose the information in accordance with <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">section 6 of the W3C Patent Policy</a>.</p>
</div>
<hr>

<div class="toc">
  <h2><a id="contents" name="contents">Table of Contents</a></h2>
  
  <ul class="toc">
  
    <li class="tocline1"><a href="#introduction">1 Introduction</a> </li>
      <li class="tocline2"><a href="#docOutline">1.1 Document Outline</a>
      <ul class="toc">
        <li class="tocline2"><a href="#docConventions">1.2 Document Conventions</a>
        <ul class="toc">
          <li class="tocline2"><a href="#docNamespaces">1.2.1 Namespaces</a></li>
          <li class="tocline2"><a href="#docDataDesc">1.2.2 Data Descriptions</a></li>
          <li class="tocline2"><a href="#docResultDesc">1.2.3 Result Descriptions</a></li>
          <li class="tocline2"><a href="#docTerminology">1.2.4 Terminology</a></li>
        </ul>
      </li>
      </ul>
    </li>

    <li class="tocline1"><a href="#basicpatterns">2 Making Simple Queries</a> (Informative)
    <ul class="toc">
      <li class="tocline2"><a href="#WritingSimpleQueries">2.1 Writing a Simple Query</a></li>
      <li class="tocline2"><a href="#MultipleMatches">2.2 Multiple Matches</a></li>
      <li class="tocline2"><a href="#matchingRDFLiterals">2.3 Matching RDF Literals</a>
      <ul class="toc">
	<li class="tocline2"><a href="#matchLangTags">2.3.1 Matching Literals with Language Tags</a></li>
	<li class="tocline2"><a href="#matchNumber">2.3.2 Matching Literals with Numeric Types</a></li>
	<li class="tocline2"><a href="#matchArbDT">2.3.3 Matching Literals with Arbitrary Datatypes</a></li>
      </ul>
      </li>
      <li class="tocline2"><a href="#BlankNodesInResults">2.4 Blank Node Labels in Query Results</a></li>
      <li class="tocline2"><a href="#constructGraph">2.5 Building RDF Graphs</a></li>
    </ul>
    </li>

    <li class="tocline1"><a href="#termConstraint">3 RDF Term Constraints</a> (Informative)
    <ul class="toc">
      <li class="tocline2"><a href="#restrictString">3.1 Restricting the Value of Strings</a></li>
      <li class="tocline2"><a href="#restrictNumber">3.2 Restricting Numeric Values</a></li>
      <li class="tocline2"><a href="#otherTermConstraints">3.3 Other Term Constraints</a></li>
    </ul>
    </li>

    <li class="tocline1"><a href="#sparqlSyntax">4 SPARQL Syntax</a>
    <ul class="toc">
      <li class="tocline2"><a href="#syntaxTerms">4.1 RDF Term Syntax</a>
      <ul class="toc">
	<li><a href="#QSynIRI">4.1.1 Syntax for IRI</a></li>
	<li><a href="#QSynLiterals">4.1.2 Syntax for Literals</a></li>
	<li><a href="#QSynVariables">4.1.3 Syntax for Variables</a></li>
	<li><a href="#QSynBlankNodes">4.1.4 Syntax for Blank Nodes</a></li>
      </ul>
      </li>
      <li class="tocline2"><a href="#QSynTriples">4.2 Syntax for Triple Patterns</a>
      <ul class="toc">
	<li class="tocline2"><a href="#predObjLists">4.2.1 Predicate-Object Lists</a></li>
	<li class="tocline2"><a href="#objLists">4.2.2 Object Lists</a></li>
	<li class="tocline2"><a href="#collections">4.2.3 RDF Collections</a></li>
	<li class="tocline2"><a href="#abbrevRdfType">4.2.4 rdf:type</a></li>
      </ul>
      </li>
      
    </ul>
    </li>

    <li class="tocline1"><a href="#GraphPattern">5 Graph Patterns</a><ul class="toc">
    <li class="tocline2"><a href="#BasicGraphPatterns">5.1 Basic Graph Patterns</a>
    <ul class="toc">
      <li class="tocline2"><a href="#bgpBNodeLabels">5.1.1 Blank Node Labels</a></li>
      <li class="tocline2"><a href="#bgpExtend">5.1.2 Extending Basic Graph Pattern Matching</a></li>
    </ul>
    </li>
    <li class="tocline2"><a href="#GroupPatterns">5.2 Group Graph Patterns</a>
    <ul class="toc">
      <li class="tocline2"><a href="#emptyGroupPattern">5.2.1 Empty Group Pattern</a></li>
      <li class="tocline2"><a href="#scopeFilters">5.2.2 Scope of Filters</a></li>
      <li class="tocline2"><a href="#groupExamples">5.2.3 Group Graph Pattern Examples</a></li>
    </ul>
    </li>
    </ul>
    </li>

    <li class="tocline1"><a href="#optionals">6 Including Optional Values</a>
    <ul class="toc">
      <li class="tocline2"><a href="#OptionalMatching">6.1 Optional Pattern Matching</a></li>
      <li class="tocline2"><a href="#OptionalAndConstraints">6.2 Constraints in Optional Pattern Matching</a></li>
      <li class="tocline2"><a href="#MultipleOptionals">6.3 Multiple Optional Graph Patterns</a></li>
    </ul>
    </li>
    
    <li class="tocline1"><a href="#alternatives">7 Matching Alternatives</a></li>
    
    <li class="tocline1"><a href="#rdfDataset">8 RDF Dataset</a>
    <ul class="toc">
      <li class="tocline2"><a href="#exampleDatasets">8.1 Examples of RDF Datasets</a></li>
      <li class="tocline2"><a href="#specifyingDataset">8.2 Specifying RDF Datasets</a>
      <ul class="toc">
        <li class="tocline2"><a href="#unnamedGraph">8.2.1 Specifying the default Graph</a></li>
        <li class="tocline2"><a href="#namedGraphs">8.2.2 Specifying Named Graphs</a></li>
        <li class="tocline2"><a href="#specDataset">8.2.3 Combining FROM and FROM NAMED</a></li>
      </ul></li>
      <li class="tocline2"><a href="#queryDataset">8.3 Querying the Dataset</a>
      <ul class="toc">
        <li class="tocline2"><a href="#accessByLabel">8.3.1 Accessing Graph Names</a></li>
        <li class="tocline2"><a href="#restrictByLabel">8.3.2 Restricting by Graph IRI</a></li>
        <li class="tocline2"><a href="#restrictInQuery">8.3.3 Restricting possible Graph IRIs</a></li>
        <li class="tocline2"><a href="#namedAndDefaultGraph">8.3.4 Named and Default Graphs</a></li>
      </ul></li>
    </ul>
    </li>
    
    <li class="tocline1"><a href="#solutionModifiers">9 Solution Sequences and Modifiers</a>
    <ul class="toc">
      <li class="tocline2"><a href="#modOrderBy">9.1 ORDER BY</a></li>
      <li class="tocline2"><a href="#modProjection">9.2 Projection</a></li>
      <li class="tocline2"><a href="#modDuplicates">9.3 Duplicate Solutions</a><ul class="toc">
	<li class="tocline2"><a href="#modDistinct">9.3.1 DISTINCT</a></li>
	<li class="tocline2"><a href="#modReduced">9.3.2 REDUCED</a></li>
      </ul></li>
      <li class="tocline2"><a href="#modOffset">9.4 OFFSET</a></li>
      <li class="tocline2"><a href="#modResultLimit">9.5 LIMIT</a></li>
    </ul>
    </li>

    <li class="tocline1"><a href="#QueryForms">10&nbsp; Query forms</a>
    <ul class="toc">
      <li class="tocline2"><a href="#select">10.1 SELECT</a></li>
      <li class="tocline2"><a href="#construct">10.2 CONSTRUCT</a><ul class="toc">
	  <li class="tocline2"><a href="#tempatesWithBNodes">10.2.1 Templates with Blank Nodes</a></li>
      <li class="tocline2"><a href="#accessingRdfGraphs">10.2.2 Accessing Graphs in the RDF Dataset</a></li>
      <li class="tocline2"><a href="#SolModandCONSTRUCT">10.2.3 Solution Modifiers and CONSTRUCT</a></li>
    </ul>
	</li>
    <li class="tocline2"><a href="#ask">10.3 ASK</a></li>
    <li class="tocline2"><a href="#describe">10.4 DESCRIBE</a> (Informative)
    <ul class="toc">
	  <li class="tocline2"><a href="#explititURIs">10.4.1 Explicit IRIs</a></li>
	  <li class="tocline2"><a href="#identifyingResources">10.4.2 Identifying Resources</a></li>
	  <li class="tocline2"><a href="#descriptionsOfResources">10.4.3 Descriptions of Resources</a></li>
    </ul>
    </li>
  </ul>
  </li>
    
    <li class="tocline1"><a href="#tests">11 Testing Values</a>
    <ul class="toc">
      <li class="tocline2"><a href="#operandDataTypes">11.1 Operand 
      Data Types</a></li>
      <li class="tocline2"><a href="#evaluation">11.2 Filter Evaluation</a>
      <ul class="toc">
	<li class="tocline2"><a href="#invocation">11.2.1 Invocation</a></li>
	<li class="tocline2"><a href="#ebv">11.2.2 Effective Boolean Value</a></li>
      </ul>
      </li>
      <li class="tocline2"><a href="#OperatorMapping">11.3 Operator Mapping</a>
      <ul class="toc">
	<li class="tocline2"><a href="#operatorExtensibility">11.3.1 Operator 
	Extensibility</a></li>
      </ul>
      </li>
      <li class="tocline2"><a href="#SparqlOps">11.4 Operator Definitions</a>
      <ul class="toc">
	<li class="tocline2"><a href="#func-bound">11.4.1 <span class="sopTOC">
	bound</span></a></li>
	<li class="tocline2"><a href="#func-isIRI">11.4.2 <span class="sopTOC">
	isIRI</span></a></li>
	<li class="tocline2"><a href="#func-isBlank">11.4.3
	<span class="sopTOC">isBlank</span></a></li>
	<li class="tocline2"><a href="#func-isLiteral">11.4.4
	<span class="sopTOC">isLiteral</span></a></li>
	<li class="tocline2"><a href="#func-str">11.4.5 <span class="sopTOC">str</span></a></li>
	<li class="tocline2"><a href="#func-lang">11.4.6 <span class="sopTOC">
	lang</span></a></li>
	<li class="tocline2"><a href="#func-datatype">11.4.7
	<span class="sopTOC">datatype</span></a></li>
	<li class="tocline2"><a href="#func-logical-or">11.4.8
	<span class="sopTOC">logical-or</span></a></li>
	<li class="tocline2"><a href="#func-logical-and">11.4.9
	<span class="sopTOC">logical-and</span></a></li>
	<li class="tocline2"><a href="#func-RDFterm-equal">11.4.10
	<span class="sopTOC">RDFterm-equal</span></a></li>
	<li class="tocline2"><a href="#func-sameTerm">11.4.11
	<span class="sopTOC">sameTerm</span></a></li>
	<li class="tocline2"><a href="#func-langMatches">11.4.12
	<span class="sopTOC">langMatches</span></a></li>
	<li class="tocline2"><a href="#funcex-regex">11.4.13
	<span class="sopTOC">regex</span></a></li>
      </ul>
      </li>
      <li class="tocline2"><a href="#FunctionMapping">11.5 Constructor Functions</a></li>
      <li class="tocline2"><a href="#extensionFunctions">11.6 Extensible Value 
      Testing</a></li>
    </ul>
    </li>

    <li class="tocline1"><a href="#sparqlDefinition">12 Definition of SPARQL</a>
    <ul class="toc">
      <li class="tocline2"><a href="#initDefinitions">12.1 Initial Definitions</a>
      <ul class="toc">
        <li class="tocline2"><a href="#sparqlBasicTerms">12.1.1 RDF Terms</a></li>
        <li class="tocline2"><a href="#sparqlDataset">12.1.2 RDF Dataset</a></li>
        <li class="tocline2"><a href="#sparqlQueryVariables">12.1.3 Query Variables</a></li>
        <li class="tocline2"><a href="#sparqlTriplePatterns">12.1.4 Triple Patterns</a></li>
        <li class="tocline2"><a href="#sparqlBasicGraphPatterns">12.1.5 Basic Graph Patterns</a></li>
        <li class="tocline2"><a href="#sparqlSolutions">12.1.6 Solution Mappings</a></li>
        <li class="tocline2"><a href="#sparqlSolMod">12.1.7 Solution Sequence Modifiers</a></li>
      </ul>
      </li>

      <li class="tocline2"><a href="#sparqlQuery">12.2 SPARQL Query</a>
        <ul class="toc">
          <li class="tocline2"><a href="#convertGraphPattern">12.2.1 Converting Graph Patterns</a></li>
          <li class="tocline2"><a href="#sparqlAbsExamples">12.2.2 Examples of Mapped Graph Patterns</a></li>
          <li class="tocline2"><a href="#convertSolMod">12.2.3 Converting Solution Modifiers</a></li>
        </ul>
      </li>

      <li class="tocline2"><a href="#BasicGraphPattern">12.3 Basic Graph Patterns</a>
      <ul class="toc">
        <li class="tocline2"><a href="#BGPsparql">12.3.1 SPARQL Basic Graph Pattern Matching</a></li>
        <li class="tocline2"><a href="#BGPsparqlBNodes">12.3.2 Treatment of Blank Nodes</a></li>
      </ul>
      </li>
      <li class="tocline2"><a href="#sparqlAlgebra">12.4 SPARQL Algebra</a></li>
      <li class="tocline2"><a href="#sparqlAlgebraEval">12.5 SPARQL Evaluation Semantics</a></li>
      <li class="tocline2"><a href="#sparqlBGPExtend">12.6 Extending SPARQL Basic Graph Matching</a></li>
    </ul>
    </li>
  </ul>
</div>

<h3><a id="appendices" name="appendices">Appendices</a></h3>
<ul class="toc">
  <li class="tocline2"><a href="#grammar">A SPARQL Grammar</a><ul class="toc">
  <li class="tocline2"><a href="#queryString">A.1 SPARQL Query String References</a></li>
  <li class="tocline2"><a href="#codepointEscape">A.2 Codepoint Escape Sequences</a></li>
  <li class="tocline2"><a href="#whitespace">A.3 White Space</a></li>
  <li class="tocline2"><a href="#grammarComments">A.4 Comments</a></li>
  <li class="tocline2"><a href="#iriRefs">A.5 IRI References</a></li>
  <li class="tocline2"><a href="#grammarBNodeLabels">A.6 Blank Node Labels</a></li>
  <li class="tocline2"><a href="#grammarEscapes">A.7 Escape sequences in strings</a></li>
  <li class="tocline2"><a href="#sparqlGrammar">A.8 Grammar</a></li>
  </ul>
  </li>
  <li class="tocline2"><a href="#conformance">B Conformance</a></li>
  <li class="tocline2"><a href="#security">C Security Considerations</a> (Informative)</li>
  <li class="tocline2"><a href="#mediaType">D Internet Media Type, File Extension 
  and Macintosh File Type</a></li>
  <li class="tocline2"><a href="#references">E References</a></li>
  <li class="tocline2"><a href="#acknowledgements">F Acknowledgements</a> (Informative)</li>
  <!-- li class="tocline2"><a href="#chlog">Change Log</a></li -->
</ul>
<hr>

<h2>1 <a id="introduction" name="introduction">Introduction</a></h2>

<p>
 RDF is a directed, labeled graph data format for representing information 
 in the Web. RDF is often used to represent, among other things, personal 
 information, social networks, metadata about digital artifacts, as well as 
 to provide a means of integration over disparate sources of information. 
 This specification defines the syntax and semantics of the SPARQL query 
 language for RDF.
</p>

<p>
  The SPARQL query language for RDF is designed to meet the use cases and requirements
  identified by the RDF Data Access Working Group in 
  <cite>
  <a href="http://www.w3.org/TR/rdf-dawg-uc/" class="inform">RDF Data Access Use 
  Cases and Requirements</a></cite> [<a href="#UCNR">UCNR</a>]. 
</p>

<p>
  The SPARQL query language is closely related to the following specifications:
</p>

<ul>
<li>The <a class="inform" href="http://www.w3.org/TR/rdf-sparql-protocol/">SPARQL Protocol 
  for RDF</a> [<a href="#SPROT">SPROT</a>] specification defines the remote protocol for issuing SPARQL queries and receiving the results.</li> 
<li>The <a class="inform" href="http://www.w3.org/TR/rdf-sparql-XMLres/">SPARQL Query 
  Results XML Format</a> [<a href="#RESULTS">RESULTS</a>] specification defines an XML document format for representing the results of SPARQL SELECT and ASK queries.</li>
</ul>


<h3>1.1 <a id="docOutline" name="docOutline">Document Outline</a></h3>
<p>Unless otherwise noted in the section heading, all sections and appendices in this document are normative.</p>

<p>
This section of the document, <a href="#introduction">section 1</a>, introduces the SPARQL query 
language specification. It presents the organization of this specification 
document and the conventions used throughout the specification.
</p>

<p><a href="#basicpatterns">Section 2</a> of the specification introduces the SPARQL query language itself 
via a series of example queries and query results. <a href="#termConstraint">Section 3</a> continues 
the introduction of the SPARQL query language with more examples that 
demonstrate SPARQL's ability to express constraints on the RDF terms that 
appear in a query's results.</p>

<p><a href="#sparqlSyntax">Section 4</a> presents details of the SPARQL query language's syntax. It is a 
companion to the full grammar of the language and defines how grammatical 
constructs represent IRIs, blank nodes, literals, and variables. Section 4 
also defines the meaning of several grammatical constructs that serve as 
syntactic sugar for more verbose expressions.</p>

<p><a href="#GraphPattern">Section 5</a> introduces basic graph patterns and group graph patterns, the 
building blocks from which more complex SPARQL query patterns are 
constructed. Sections 6, 7, and 8 present constructs that combine SPARQL 
graph patterns into larger graph patterns. In particular, <a href="#optionals">Section 6</a> 
introduces the ability to make portions of a query optional; <a href="#alternatives">Section 7</a> 
introduces the ability to express the disjunction of alternative graph 
patterns; and <a href="#rdfDataset">Section 8</a> introduces the ability to constrain portions of a 
query to particular source graphs. Section 8 also presents SPARQL's 
mechanism for defining the source graphs for a query.</p>
 
<p><a href="#solutionModifiers">Section 9</a> defines the constructs that affect the solutions of a query by 
ordering, slicing, projecting, limiting, and removing duplicates from a 
sequence of solutions.</p>

<p><a href="#QueryForms">Section 10</a> defines the four types of SPARQL queries that produce results 
in different forms.</p>

<p><a href="#tests">Section 11</a> defines SPARQL's extensible value testing framework. It also 
presents the functions and operators that can be used to constrain the 
values that appear in a query's results.</p>

<p><a href="#sparqlDefinition">Section 12</a> is a formal definition of the evaluation of SPARQL graph 
patterns and solution modifiers.</p>

<p><a href="#grammar">Appendix A</a> contains the normative definition of the SPARQL query 
language's syntax, as given by a grammar expressed in EBNF notation.</p>




<h3>1.2 <a id="docConventions" name="docConventions">Document Conventions</a></h3>
<h4>1.2.1 <a id="docNamespaces" name="docNamespaces">Namespaces</a></h4>
<p>In this document, examples assume the following namespace prefix bindings unless 
otherwise stated:</p>
<div style="text-align: center;">
  <table style="border-collapse: collapse; border-color: rgb(0, 0, 0);" border="1" cellpadding="5">
    <tbody><tr>
      <th>Prefix</th>
      <th>IRI</th>
    </tr>
    <tr>
      <td><code>rdf:</code></td>
      <td><code>http://www.w3.org/1999/02/22-rdf-syntax-ns#</code></td>
    </tr>
    <tr>
      <td><code>rdfs:</code></td>
      <td><code>http://www.w3.org/2000/01/rdf-schema#</code></td>
    </tr>
    <tr>
      <td><code>xsd:</code></td>
      <td><code>http://www.w3.org/2001/XMLSchema#</code></td>
    </tr>
    <tr>
      <td><code>fn:</code></td>
      <td><code>http://www.w3.org/2005/xpath-functions#</code></td>
    </tr>
  </tbody></table>
</div>
<h4>1.2.2 <a id="docDataDesc" name="docDataDesc">Data Descriptions</a></h4>
<p>This document uses the 
<a class="inform" href="http://www.w3.org/TeamSubmission/turtle/">Turtle</a> [<a href="#TURTLE">TURTLE</a>]
data format to show each triple explicitly. Turtle allows IRIs to be abbreviated with prefixes:</p>
<pre class="data">@prefix dc:   &lt;http://purl.org/dc/elements/1.1/&gt; .
@prefix :     &lt;http://example.org/book/&gt; .
:book1  dc:title  "SPARQL Tutorial" .
</pre>
<h4>1.2.3 <a id="docResultDesc" name="docResultDesc">Result Descriptions</a></h4>
<p>Result sets are illustrated in tabular form.
</p>
<div class="result">
  <table class="resultTable" id="table39">
    <tbody><tr>
      <th>x</th>
      <th>y</th>
      <th>z</th>
    </tr>
    <tr>
      <td>"Alice"</td>
      <td><code>&lt;http://example/a&gt;</code></td>
      <td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </td>
    </tr>
  </tbody></table>
</div>
<p>A 'binding' is a pair (<a href="#defn_QueryVariable">variable</a>,
<a href="#defn_RDFTerm">RDF term</a>). In this result set, there are three
variables:
<code>x</code>, <code>y</code> and <code>z</code> (shown as column headers). Each 
solution is shown as one row in the body of the table.&nbsp; Here, there is a single 
solution, in which variable <code>x</code> is bound to <code>"Alice"</code>, variable
<code>y</code> is bound to <code>&lt;http://example/a&gt;</code>, and variable <code>z</code> 
is not bound to an RDF term. Variables are not required to be bound in a 
solution.</p>

<h4>1.2.4 <a id="docTerminology" name="docTerminology">Terminology</a></h4>

  <p>The SPARQL language includes IRIs, a subset of RDF URI References that omits spaces. Note that all IRIs 
  in SPARQL queries are absolute; they may or may not include a fragment identifier [<a href="#rfc3987">RFC3987</a>, section 3.1]. IRIs include URIs [<a href="#rfc3986">RFC3986</a>] and URLs. The abbreviated
  forms (<a href="#QSynIRI">relative IRIs and prefixed names</a>) in the SPARQL syntax are resolved to produce absolute
  IRIs.</p>
<p>The following terms are defined in
<a class="norm" href="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/">RDF
  Concepts and Abstract Syntax</a> <a href="#CONCEPTS">[CONCEPTS]</a> and used 
in SPARQL:</p>

  <ul>
    <li><a class="type IRI" href="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/#dfn-URI-reference">IRI</a> (corresponds to the Concepts and Abstract Syntax term "<code>RDF URI reference</code>")</li>
    <li><a class="type literal" href="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/#dfn-literal">literal</a></li>
    <li><a class="type lexicalForm" href="http://www.w3.org/TR/rdf-concepts/#dfn-lexical-form">lexical form</a></li>
    <li><a class="type plainLiteral" href="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/#dfn-plain-literal">plain literal</a></li>
    <li><a class="type langTag" href="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/#dfn-language-identifier">language tag</a></li>
    <li><a class="type typedLiteral" href="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/#dfn-typed-literal">typed literal</a></li>
    <li><a class="type datatypeIRI" href="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/#dfn-datatype-URI">datatype IRI</a> (corresponds to the Concepts and Abstract Syntax term "<code>datatype URI</code>")</li>
    <li><a class="type bNode" href="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/#dfn-blank-node">blank node</a></li>
  </ul>

<h2>2 <a id="basicpatterns" name="basicpatterns">Making Simple Queries</a> (Informative)</h2>
    <p>Most forms of SPARQL query contain a set of triple patterns called a <em>basic graph pattern</em>.
 Triple patterns are like RDF triples except that each of the subject, 
predicate and object may be a variable. A basic graph pattern <em>matches</em> a subgraph of the RDF data when <a href="#defn_RDFTerm">RDF terms</a> from that subgraph may be substituted for the variables and the result is RDF graph equivalent to the subgraph.</p>

<h3>2.1 <a id="WritingSimpleQueries" name="WritingSimpleQueries">Writing a Simple 
Query</a></h3>
<p>The example below shows a SPARQL query to find the title of a book from the 
given data graph. The query consists of two parts:
the <code>SELECT</code> clause identifies 
the variables to appear in the query results, and the <code>WHERE</code> clause 
provides the basic graph pattern to match against the data graph. The basic graph pattern in this example 
consists of a single triple pattern with a single variable (<code>?title</code>) in the object position.</p>
<div class="exampleGroup" id="foo">
  <p>Data:</p>
  <pre class="data">&lt;http://example.org/book/book1&gt; &lt;http://purl.org/dc/elements/1.1/title&gt; "SPARQL Tutorial" .
</pre>
  <div class="queryGroup">
    <p>Query:</p>
    <pre class="query">SELECT ?title
WHERE
{
  &lt;http://example.org/book/book1&gt; &lt;http://purl.org/dc/elements/1.1/title&gt; ?title .
}    
</pre>
    <p>This query, on the data above, has one solution:</p>
    <p>Query Result:</p>
    <div class="result">
      <table class="resultTable" id="table1">
        <tbody><tr>
          <th>title</th>
        </tr>
        <tr>
          <td>"SPARQL Tutorial"</td>
        </tr>
      </tbody></table>
    </div>
  </div>
</div>
<h3>2.2 <a id="MultipleMatches" name="MultipleMatches">Multiple Matches</a></h3>
<p>The result of a query is a <a href="#defn_sparqlSolutionSequence">solution sequence</a>, corresponding to the ways in which 
the query's graph pattern matches the data. There may be 
zero, one or multiple solutions to a query.</p>
<p>Data:</p>
<div class="exampleGroup">
  <pre class="data">@prefix foaf:  &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a  foaf:name   "Johnny Lee Outlaw" .
_:a  foaf:mbox   &lt;mailto:jlow@example.com&gt; .
_:b  foaf:name   "Peter Goodguy" .
_:b  foaf:mbox   &lt;mailto:peter@example.org&gt; .
_:c  foaf:mbox   &lt;mailto:carol@example.org&gt; .
</pre>
  <p>Query:</p>
  <div class="queryGroup">
    <pre class="query">PREFIX foaf:   &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name ?mbox
WHERE
  { ?x foaf:name ?name .
    ?x foaf:mbox ?mbox }
</pre>
    <p>Query Result:</p>
    <div class="result">
      <table class="resultTable">
        <tbody><tr>
          <th>name</th>
          <th>mbox</th>
        </tr>
        <tr>
          <td>"Johnny Lee Outlaw"</td>
          <td>&lt;mailto:jlow@example.com&gt;</td>
        </tr>
        <tr>
          <td>"Peter Goodguy"</td>
          <td>&lt;mailto:peter@example.org&gt;</td>
        </tr>
      </tbody></table>
    </div>
  </div>
</div>
<p>Each solution gives one way in which the selected variables can be bound 
to RDF terms so that the query pattern matches the data. The result set gives 
all the possible solutions. In the above example, 
the following two subsets of the data provided the two matches.</p>
<pre class="dataExcerpt untested"> _:a foaf:name  "Johnny Lee Outlaw" .
 _:a foaf:box   &lt;mailto:jlow@example.com&gt; .
</pre>
<pre class="dataExcerpt untested"> _:b foaf:name  "Peter Goodguy" .
 _:b foaf:box   &lt;mailto:peter@example.org&gt; .
</pre>
<p>This is a <a href="#BGPsparql">basic graph pattern match</a>; all the 
variables used in the query pattern must be bound in every solution.</p>

<h3>2.3 <a id="matchingRDFLiterals" name="matchingRDFLiterals">Matching RDF Literals</a></h3>
<p>The data below contains three RDF literals:</p>
<div class="exampleGroup">
  <pre class="data">@prefix dt:   &lt;http://example.org/datatype#&gt; .
@prefix ns:   &lt;http://example.org/ns#&gt; .
@prefix :     &lt;http://example.org/ns#&gt; .
@prefix xsd:  &lt;<code>http://www.w3.org/2001/XMLSchema#&gt; .</code>

:x   ns:p     "cat"@en .
:y   ns:p     "42"^^xsd:integer .
:z   ns:p     "abc"^^dt:specialDatatype .
</pre>

      <p>Note that, in Turtle, <code>"cat"@en</code> is an RDF literal with a lexical form "cat" and a language <code>en</code>; <code>"42"^^xsd:integer</code> is a typed literal with the datatype <code>http://www.w3.org/2001/XMLSchema#integer</code>; and <code>"abc"^^dt:specialDatatype</code> is a typed literal with the datatype <code>http://example.org/datatype#specialDatatype</code>.</p>

  <p>This RDF data is the data graph for the query examples in sections 2.3.1–2.3.3.</p>
  <h4>2.3.1 <a id="matchLangTags" name="matchLangTags">Matching Literals with Language Tags</a></h4>
      <p>Language tags in SPARQL are expressed using <code>@</code> and the 
      language tag, as defined in <a class="norm" href="http://www.rfc-editor.org/rfc/bcp/bcp47.txt">Best Common Practice 47</a> [<a href="#BCP47">BCP47</a>].</p>

  <p>This following query has no solution because <code>"cat"</code> is not the 
  same RDF literal as <code>"cat"@en</code>:</p>
  <div class="queryGroup">
    <pre class="query">SELECT ?v WHERE { ?v ?p "cat" }
</pre>
    <div class="result">
      <table class="resultTable">
        <tbody><tr>
          <th>&nbsp;&nbsp; v&nbsp;&nbsp;&nbsp;&nbsp; </th>
        </tr>
      </tbody></table>
    </div>
    <p>but the query below will find a solution where variable <code>v</code> is bound to
    <code>:x</code> because the language tag is specified and matches the given data:</p>
    <pre class="query">SELECT ?v WHERE { ?v ?p "cat"@en }
</pre>
    <div class="result">
      <table class="resultTable">
        <tbody><tr>
          <th>v</th>
        </tr>
        <tr>
          <td>&lt;http://example.org/ns#x&gt;</td>
        </tr>
      </tbody></table>
    </div>
  </div>
</div>

  <h4>2.3.2 <a id="matchNumber" name="matchNumber">Matching Literals with Numeric Types</a></h4>
    <p>Integers in a SPARQL query indicate an RDF typed literal with the datatype
    <code>xsd:integer</code>. For example: <code>42</code> is a shortened form 
    of&nbsp; <code>"42"^^&lt;http://www.w3.org/2001/XMLSchema#integer&gt;</code>.</p>
  <p>The pattern in the following query has a solution with variable <code>v</code> 
  bound to <code>:y</code>.</p>
  <div class="queryGroup">
    <pre class="query">SELECT ?v WHERE { ?v ?p 42 }
</pre>
    <div class="result">
      <table class="resultTable" id="table60">
        <tbody><tr>
          <th>v</th>
        </tr>
        <tr>
          <td>&lt;http://example.org/ns#y&gt;</td>
        </tr>
      </tbody></table>
    </div>
  </div>
    <p><a href="#QSynLiterals">Section 4.1.2</a> defines SPARQL shortened forms for <code>xsd:float</code> and <code>xsd:double</code>.</p>
  <h4>2.3.3 <a id="matchArbDT" name="matchArbDT">Matching Literals with Arbitrary Datatypes</a></h4>
  <p>The following query has a solution with variable <code>v</code> bound to
  <code>:z</code>. The query processor does not have to have any understanding 
  of the values in the space of the datatype. Because the lexical form and 
  datatype IRI both match, the literal matches.</p>
  <div class="queryGroup">
    <pre class="query">SELECT ?v WHERE { ?v ?p "abc"^^&lt;http://example.org/datatype#specialDatatype&gt; }
</pre>
    <div class="result">
      <table class="resultTable" id="table61">
        <tbody><tr>
          <th>v</th>
        </tr>
        <tr>
          <td>&lt;http://example.org/ns#z&gt;</td>
        </tr>
      </tbody></table>
    </div>
  </div>

<h3>2.4 <a id="BlankNodesInResults" name="BlankNodesInResults">Blank Node Labels in Query Results</a></h3>
<p>
  Query results can contain blank nodes. Blank nodes in the example
  result sets in this document are written in the form
  "_:" followed by a blank node label.
</p>

<p>Blank node labels are scoped to a result set (as defined in "<a class="inform" href="http://www.w3.org/TR/rdf-sparql-XMLres/">SPARQL 
Query Results XML Format</a>") or, for the <code>CONSTRUCT</code> query 
form, the result graph. 
Use of the same label within a 
result set indicates the same blank node.</p>
<div class="exampleGroup">
  Data:
  <pre class="data">@prefix foaf:  &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a  foaf:name   "Alice" .
_:b  foaf:name   "Bob" .
</pre>
  <div class="queryGroup">
    Query:
    <pre class="query">PREFIX foaf:   &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?x ?name
WHERE  { ?x foaf:name ?name }
</pre>
    <div class="result">
      <table class="resultTable" id="table56">
        <tbody><tr>
          <th>x</th>
          <th>name</th>
        </tr>
        <tr>
          <td>_:c</td>
          <td>"Alice"</td>
        </tr>
        <tr>
          <td>_:d</td>
          <td>"Bob"</td>
        </tr>
      </tbody></table>
    </div>
  </div>
  <p>The results above could equally be given with different blank node labels because 
  the labels in the results only indicate whether RDF terms in the solutions are 
  the same or different.</p>
  <div class="result untested">
    <table class="resultTable" id="table57">
      <tbody><tr>
        <th>x</th>
        <th>name</th>
      </tr>
      <tr>
        <td>_:r</td>
        <td>"Alice"</td>
      </tr>
      <tr>
        <td>_:s</td>
        <td>"Bob"</td>
      </tr>
    </tbody></table>
  </div>
</div>
<p>These two results have the same information: the blank nodes used to match the 
query are different in the two solutions. There need not be any relation between a 
label
<code>_:a</code> in the result set and a blank node in the data graph 
with the same label.</p>

<p>An application writer should not expect blank node labels in a query to refer to a particular blank node in the data.</p>


<h3>2.5 <a id="constructGraph" name="constructGraph">Building RDF Graphs</a></h3>
<p>SPARQL has several <a href="#QueryForms">query forms</a>.
The <code>SELECT</code> query form 
returns variable bindings. The <code>CONSTRUCT</code> query form
returns an RDF graph. The graph is built based on a template
which is used to generate RDF triples based on the results of matching
the graph pattern of the query.</p>

<div class="exampleGroup">
<p>Data:</p>
  <pre class="data">@prefix org:    &lt;http://example.com/ns#&gt; .

_:a  org:employeeName   "Alice" .
_:a  org:employeeId     12345 .

_:b  org:employeeName   "Bob" .
_:b  org:employeeId     67890 .</pre>
  <div class="queryGroup">
<p>Query:</p>
    <pre class="query">PREFIX foaf:   &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX org:    &lt;http://example.com/ns#&gt;

CONSTRUCT { ?x foaf:name ?name }
WHERE  { ?x org:employeeName ?name }</pre>
<p>Results:</p>
    <div class="result">
      <pre class="resultGraph">@prefix org: &lt;http://example.com/ns#&gt; .
      
_:x foaf:name "Alice" .
_:y foaf:name "Bob" .</pre>
      </div>
  </div>

  <p>which can be serialized in
  <a href="http://www.w3.org/TR/rdf-syntax-grammar/">RDF/XML</a> as:</p>
  
  <div class="result">
      <pre class="resultGraph" style="text-align: left;">&lt;rdf:RDF
    xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    xmlns:foaf="http://xmlns.com/foaf/0.1/"
    &gt;
  &lt;rdf:Description&gt;
    &lt;foaf:name&gt;Alice&lt;/foaf:name&gt;
  &lt;/rdf:Description&gt;
  &lt;rdf:Description&gt;
    &lt;foaf:name&gt;Bob&lt;/foaf:name&gt;
  &lt;/rdf:Description&gt;
&lt;/rdf:RDF&gt;</pre>
  </div>
  </div>



<h2>3 <a id="termConstraint" name="termConstraint">RDF Term Constraints</a> (Informative)</h2>
  <p>Graph pattern matching produces a solution sequence, where each 
solution has a set of bindings of variables to RDF terms. SPARQL <code>FILTER</code>s
  restrict solutions to those for which the filter expression evaluates to <code>TRUE</code>.</p>

    <p>This section provides an informal introduction to SPARQL <code>FILTER</code>s; their semantics are defined in <a href="#tests">Section 11. Testing Values</a>. The examples in this section share one input graph:</p>

<div class="exampleGroup">
  Data:
  <pre class="data">@prefix dc:   &lt;http://purl.org/dc/elements/1.1/&gt; .
@prefix :     &lt;http://example.org/book/&gt; .
@prefix ns:   &lt;http://example.org/ns#&gt; .

:book1  dc:title  "SPARQL Tutorial" .
:book1  ns:price  42 .
:book2  dc:title  "The Semantic Web" .
:book2  ns:price  23 .
</pre>
  <h3>3.1 <a name="restrictString" id="restrictString">Restricting the Values of Strings</a></h3>
  <p>SPARQL <code>FILTER</code> functions like <code><a href="#funcex-regex">regex</a></code> can test RDF literals. <code>regex</code> matches only plain 
  literals with no language tag.
  <code>regex</code> can be used to match the lexical forms of other literals by 
  using the <a href="#func-str">str</a> 
  function.</p>
  <p>Query:</p>
  <div class="queryGroup">
    <pre class="query">PREFIX  dc:  &lt;http://purl.org/dc/elements/1.1/&gt;
SELECT  ?title
WHERE   { ?x dc:title ?title
          FILTER regex(?title, "^SPARQL") 
        }
</pre>
    <p>Query Result:</p>
    <div class="result">
      <table class="resultTable" id="table63">
        <tbody><tr>
          <th>title</th>
        </tr>
        <tr>
          <td>"SPARQL Tutorial"</td>
        </tr>
      </tbody></table>
    </div>
  </div>
  <p>Regular expression matches may be made case-insensitive with the "<code>i</code>" 
  flag.</p>
  <p>Query:</p>
  <div class="queryGroup">
    <pre class="query">PREFIX  dc:  &lt;http://purl.org/dc/elements/1.1/&gt;
SELECT  ?title
WHERE   { ?x dc:title ?title
          FILTER regex(?title, "web", "i" ) 
        }
</pre>
    <p>Query Result:</p>
    <div class="result">
      <table class="resultTable" id="table64">
        <tbody><tr>
          <th>title</th>
        </tr>
        <tr>
          <td>"The Semantic Web"</td>
        </tr>
      </tbody></table>
    </div>
  </div>
      <p>The regular expression language is <a href="http://www.w3.org/TR/xpath-functions/#regex-syntax">defined by XQuery 1.0 and XPath 2.0 Functions and Operators</a> and is based on <a href="http://www.w3.org/TR/xmlschema-2/#regexs">XML Schema Regular Expressions</a>.</p>
  <h3>3.2 <a name="restrictNumber" id="restrictNumber">Restricting Numeric Values</a></h3>
  <p>SPARQL <code>FILTER</code>s can restrict on arithmetic expressions.</p>
  <p>Query:</p>
  <div class="queryGroup">
    <pre class="query">PREFIX  dc:  &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX  ns:  &lt;http://example.org/ns#&gt;
SELECT  ?title ?price
WHERE   { ?x ns:price ?price .
          FILTER (?price &lt; 30.5)
          ?x dc:title ?title . }
</pre>
    <p>Query Result:</p>
    <div class="result">
      <table class="resultTable" id="table58">
        <tbody><tr>
          <th>title</th>
          <th>price</th>
        </tr>
        <tr>
          <td>"The Semantic Web"</td>
          <td>23</td>
        </tr>
      </tbody></table>
    </div>
  </div>
</div>
<p>By constraining the <code>price</code> variable, only <code>:book2</code> matches 
the query because only <code>:book2</code> has a price less than <code>30.5</code>, 
as the filter condition requires. </p>

<h3>3.3 <a id="otherTermConstraints" name="otherTermConstraints">Other Term Constraints</a></h3>

    <p>In addition to <span class="type numeric">numeric</span> types, SPARQL supports 
	types <code>xsd:string</code>, <code>xsd:boolean</code> and <code>xsd:dateTime</code> (see <a href="#operandDataTypes">11.1 Operand Data Types</a>). <a href="#OperatorMapping">11.3 Operator Mapping</a> lists a set of test functions, including <code>BOUND</code>, <code>isLITERAL</code> and <code>langMATCHES</code> and accessors, including <code>STR</code>, <code>LANG</code> and <code>DATATYPE</code>. <a href="#FunctionMapping">11.5 Constructor Functions</a> lists a set of XML Schema constructor functions that are in the SPARQL language to cast values from one type to another.</p>

<h2>4 <a id="sparqlSyntax" name="sparqlSyntax">SPARQL Syntax</a></h2>
<p>This section covers the syntax used by SPARQL for <a href="#sparqlBasicTerms">
RDF terms</a> and <a href="#sparqlTriplePatterns">triple patterns</a>. The full grammar 
is given in <a href="#grammar">appendix A</a>.</p>
<h3>4.1 <a id="syntaxTerms" name="syntaxTerms">RDF Term Syntax</a></h3>
<h4>4.1.1 <a id="QSynIRI" name="QSynIRI">Syntax for IRIs</a></h4>

    <p>The <a href="#rIRIref">IRIref</a> production designates the set of IRIs [<a href="#rfc3987">RFC3987</a>]; IRIs are a generalization of URIs [<a href="#rfc3986">RFC3986</a>] and are fully compatible with URIs and URLs. The <a href="#rPrefixedName">PrefixedName</a>
 production designates a prefixed name. The mapping from a prefixed name
 to an IRI is described below. IRI references (relative or absolute 
IRIs) are designated by the <a href="#rIRI_REF">IRI_REF</a> production, 
where the '&lt;' and '&gt;' delimiters do not form part of the IRI 
reference.  Relative IRIs match the irelative-ref reference in section 
2.2 ABNF for IRI References and IRIs in [<a href="#rfc3987">RFC3987</a>] and are resolved to IRIs as described below.</p>

<div class="grammarExtract">
  Grammar rules:<div class="grammarTable">
    <table id="table109">
<tbody><tr>
  <td><code class="gRuleLabel">[67]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rIRIref">IRIref</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rIRI_REF">IRI_REF</a> |	<a href="#rPrefixedName">PrefixedName</a></code></td>
</tr>

<tr>
  <td><code class="gRuleLabel">[68]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rPrefixedName">PrefixedName</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rPNAME_LN">PNAME_LN</a> | <a href="#rPNAME_NS">PNAME_NS</a></code></td>
</tr>

<tr>
  <td><code class="gRuleLabel">[69]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rBlankNode">BlankNode</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rBLANK_NODE_LABEL">BLANK_NODE_LABEL</a> |	<a href="#rANON">ANON</a></code></td>
</tr>

<tr>
  <td><code class="gRuleLabel">[70]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rIRI_REF">IRI_REF</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'&lt;' ([^&lt;&gt;"{}|^`\]-[#x00-#x20])* '&gt;'</span></code></td>
</tr>

<tr>
  <td><code class="gRuleLabel">[71]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rPNAME_NS">PNAME_NS</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rPN_PREFIX">PN_PREFIX</a>? ':'</code></td>
</tr>

<tr>
  <td><code class="gRuleLabel">[72]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rPNAME_LN">PNAME_LN</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rPNAME_NS">PNAME_NS</a> <a href="#rPN_LOCAL">PN_LOCAL</a></code></td>
</tr>
    </tbody></table>
  </div>
</div>

<p>The set of RDF terms defined in RDF Concepts and Abstract Syntax
   includes RDF URI references while SPARQL terms include IRIs. RDF URI
   references containing "<code>&lt;</code>", "<code>&gt;</code>", '<code>"</code>' (double 
quote), space, "<code>{</code>", "<code>}</code>", "<code>|</code>",
"<code>\</code>", "<code>^</code>", and 
"<code>`</code>" are not IRIs. The behavior of a SPARQL query against RDF
   statements composed of such RDF URI references is not defined.</p>
<h5><a id="prefNames" name="prefNames">Prefixed names</a></h5>
<p>The <code>PREFIX</code> keyword associates a prefix label with an IRI. A prefixed 
name is a prefix label and a local part, separated by a colon "<code>:</code>". 
A prefixed name is mapped to an IRI by concatenating the IRI associated with the prefix and the local part. 
The prefix label or the local part may be empty. Note that <a href="#rPN_LOCAL">SPARQL local names</a> allow leading digits while <a href="http://www.w3.org/TR/2006/REC-xml-names11-20060816/#NT-LocalPart">XML local names</a> do not.</p>

<h5><a id="relIRIs" name="relIRIs">Relative IRIs</a></h5>
<p>Relative IRIs are combined with base IRIs as per
<a class="norm" href="http://www.ietf.org/rfc/rfc3986.txt">Uniform Resource Identifier 
(URI): Generic Syntax</a> [<a href="#rfc3986">RFC3986</a>] using only the basic 
algorithm in Section 5.2 . Neither Syntax-Based Normalization nor Scheme-Based Normalization 
(described in sections 6.2.2 and 6.2.3 of RFC3986) are performed. Characters additionally 
allowed in IRI references are treated in the same way that unreserved characters 
are treated in URI references, per section 6.5 of
<a class="norm" href="http://www.ietf.org/rfc/rfc3987.txt">Internationalized Resource 
Identifiers (IRIs)</a> [<a href="#rfc3987">RFC3987</a>].</p>
<p>The <code>BASE</code> keyword defines the Base IRI used to resolve relative IRIs 
per RFC3986 section 5.1.1, "Base URI Embedded in Content". Section 5.1.2, "Base 
URI from the Encapsulating Entity" defines how the Base IRI may come from an encapsulating 
document, such as a SOAP envelope with an xml:base directive or a mime multipart 
document with a Content-Location header. The "Retrieval URI" identified in 5.1.3, 
Base "URI from the Retrieval URI", is the URL from which a particular SPARQL query 
was retrieved. If none of the above specifies the Base URI, the default Base URI 
(section 5.1.4, "Default Base URI") is used.</p>
<p>The following fragments are some of the different ways to write the same IRI:</p>
<pre class="data">&lt;http://example.org/book/book1&gt;
</pre>
<pre class="data">BASE &lt;http://example.org/book/&gt;
&lt;book1&gt;
</pre>
<pre class="data">PREFIX book: &lt;http://example.org/book/&gt;
book:book1</pre>
<h4>4.1.2 <a id="QSynLiterals" name="QSynLiterals">Syntax for Literals</a></h4>
<p>The general syntax for literals is a string (enclosed in either double 
quotes, <code>"..."</code>, or single quotes, <code>'...'</code>), with either an optional 
language tag (introduced by <code>@</code>) or an optional datatype IRI or prefixed 
name (introduced by <code>^^</code>).</p>
<p>As a convenience, integers can be written directly (without quotation
 marks and an explicit datatype IRI) and are interpreted as typed 
literals of datatype <code>xsd:integer</code>; decimal numbers for which there is '.' 
in the number but no exponent are interpreted as <code>xsd:decimal</code>; and 
numbers with exponents are interpreted as <code>xsd:double</code>. Values of 
type <code>xsd:boolean</code> can also be written as <code>true</code> or <code>
false</code>.</p>
<p>To facilitate writing literal values which themselves contain quotation marks 
or which are long and contain newline characters, SPARQL provides an additional 
quoting construct in which literals are enclosed in three single- or double-quotation 
marks.</p>
<p>Examples of literal syntax in SPARQL include:</p>
<ul>
  <li><code>"chat"</code></li>
  <li><code>'chat'@fr</code> with language tag "fr"</li>
  <li><code>"xyz"^^&lt;http://example.org/ns/userDatatype&gt;</code></li>
  <li><code>"abc"^^appNS:appDataType</code></li>
  <li><code>'''The librarian said, "Perhaps you would enjoy 'War and Peace'."'''</code></li>
  <li><code>1</code>, which is the same as <code>"1"^^xsd:integer</code></li>
  <li><code>1.3</code>, which is the same as <code>"1.3"^^xsd:decimal</code></li>
  <li><code>1.300</code>, which is the same as <code>"1.300"^^xsd:decimal</code></li>
  <li><code>1.0e6</code>, which is the same as <code>"1.0e6"^^xsd:double</code></li>
  <li><code>true</code>, which is the same as <code>"true"^^xsd:boolean</code></li>
  <li><code>false</code>, which is the same as <code>"false"^^xsd:boolean</code></li>
</ul>
<div class="grammarExtract">
  Grammar rules:<div class="grammarTable">
    <table id="table110">
      <tbody><tr>
  <td><code class="gRuleLabel">[60]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rRDFLiteral">RDFLiteral</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rString">String</a> ( <a href="#rLANGTAG">LANGTAG</a> | ( <span class="token">'^^'</span> <a href="#rIRIref">IRIref</a> ) )?</code></td>
      </tr>
      <tr>
  <td><code class="gRuleLabel">[61]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rNumericLiteral">NumericLiteral</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rNumericLiteralUnsigned">NumericLiteralUnsigned</a> | 
  <br>
  <a href="#rNumericLiteralPositive">NumericLiteralPositive</a> | <br>
  <a href="#rNumericLiteralNegative">NumericLiteralNegative</a></code></td>
      </tr>
      <tr>
  <td><code class="gRuleLabel">[62]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rNumericLiteralUnsigned">NumericLiteralUnsigned</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rINTEGER">INTEGER</a> |	<a href="#rDECIMAL">DECIMAL</a> |	<a href="#rDOUBLE">DOUBLE</a></code></td>
      </tr>
      <tr>
  <td><code class="gRuleLabel">[63]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rNumericLiteralPositive">NumericLiteralPositive</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rINTEGER_POSITIVE">INTEGER_POSITIVE</a> |	
  <br>
  <a href="#rDECIMAL_POSITIVE">DECIMAL_POSITIVE</a> |	<br>
  <a href="#rDOUBLE_POSITIVE">DOUBLE_POSITIVE</a></code></td>
      </tr>
      <tr>
  <td><code class="gRuleLabel">[64]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rNumericLiteralNegative">NumericLiteralNegative</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rINTEGER_NEGATIVE">INTEGER_NEGATIVE</a> |	
  <br>
  <a href="#rDECIMAL_NEGATIVE">DECIMAL_NEGATIVE</a> |	<br>
  <a href="#rDOUBLE_NEGATIVE">DOUBLE_NEGATIVE</a></code></td>
      </tr>
      <tr>
  <td><code class="gRuleLabel">[65]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rBooleanLiteral">BooleanLiteral</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'true'</span> |	<span class="token">'false'</span></code></td>
      </tr>
      <tr>
  <td><code class="gRuleLabel">[66]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rString">String</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rSTRING_LITERAL1">STRING_LITERAL1</a> | <a href="#rSTRING_LITERAL2">STRING_LITERAL2</a> | 
  <br>
  <a href="#rSTRING_LITERAL_LONG1">STRING_LITERAL_LONG1</a> | <a href="#rSTRING_LITERAL_LONG2">STRING_LITERAL_LONG2</a></code></td>
      </tr>
      <tr>
  <td><code class="gRuleLabel">[76]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rLANGTAG">LANGTAG</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">'@' [a-zA-Z]+ ('-' [a-zA-Z0-9]+)*</code></td>
      </tr>
      <tr>
  <td><code class="gRuleLabel">[77]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rINTEGER">INTEGER</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">[0-9]+</code></td>
      </tr>
      <tr>
  <td><code class="gRuleLabel">[78]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rDECIMAL">DECIMAL</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">[0-9]+ '.' [0-9]* | '.' [0-9]+</code></td>
      </tr>
      <tr>
  <td><code class="gRuleLabel">[79]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rDOUBLE">DOUBLE</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">[0-9]+ '.' [0-9]* <a href="#rEXPONENT">EXPONENT</a> |<br>
  '.' ([0-9])+ <a href="#rEXPONENT">EXPONENT</a> |<br>
  ([0-9])+ <a href="#rEXPONENT">EXPONENT</a></code></td>
      </tr>
      <tr>
  <td><code class="gRuleLabel">[80]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rINTEGER_POSITIVE">INTEGER_POSITIVE</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'+'</span> <a href="#rINTEGER">INTEGER</a></code></td>
      </tr>
      <tr>
  <td><code class="gRuleLabel">[81]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rDECIMAL_POSITIVE">DECIMAL_POSITIVE</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'+'</span> <a href="#rDECIMAL">DECIMAL</a></code></td>
      </tr>
      <tr>
  <td><code class="gRuleLabel">[82]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rDOUBLE_POSITIVE">DOUBLE_POSITIVE</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'+'</span> <a href="#rDOUBLE">DOUBLE</a></code></td>
      </tr>
      <tr>
  <td><code class="gRuleLabel">[83]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rINTEGER_NEGATIVE">INTEGER_NEGATIVE</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'-'</span> <a href="#rINTEGER">INTEGER</a></code></td>
      </tr>
      <tr>
  <td><code class="gRuleLabel">[84]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rDECIMAL_NEGATIVE">DECIMAL_NEGATIVE</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'-'</span> <a href="#rDECIMAL">DECIMAL</a></code></td>
      </tr>
      <tr>
  <td><code class="gRuleLabel">[85]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rDOUBLE_NEGATIVE">DOUBLE_NEGATIVE</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'-'</span> <a href="#rDOUBLE">DOUBLE</a></code></td>
      </tr>
      <tr>
  <td><code class="gRuleLabel">[86]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rEXPONENT">EXPONENT</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">[eE] [+-]? [0-9]+</code></td>
      </tr>
      <tr>
  <td><code class="gRuleLabel">[87]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rSTRING_LITERAL1">STRING_LITERAL1</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">"'" ( ([^#x27#x5C#xA#xD]) | <a href="#rECHAR">ECHAR</a> )* "'"</code></td>
      </tr>
      <tr>
  <td><code class="gRuleLabel">[88]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rSTRING_LITERAL2">STRING_LITERAL2</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">'"' ( ([^#x22#x5C#xA#xD]) | <a href="#rECHAR">ECHAR</a> )* '"'</code></td>
      </tr>
    </tbody></table>
  </div>
</div>

    <p>
  Tokens matching the productions <a href="#rINTEGER">INTEGER</a>, <a href="#rDECIMAL">DECIMAL</a>, <a href="#rDOUBLE">DOUBLE</a> and
  <a href="#rBooleanLiteral">BooleanLiteral</a> are equivalent to a typed
  literal with the lexical value of the token and the corresponding
  datatype (<code>xsd:integer</code>, <code>xsd:decimal</code>, <code>xsd:double</code>, <code>xsd:boolean</code>).
    </p>

<h4>4.1.3 <a id="QSynVariables" name="QSynVariables">Syntax for Query Variables</a></h4>
<p>Query variables in SPARQL queries have global scope; use of a given variable 
name anywhere in a query identifies the same variable. Variables are prefixed by 
either "?" or "$"; the "?" or "$" is not part of the variable name. 
In a query, <code>$abc</code> and <code>?abc</code> identify the same variable. The
<a href="#rVARNAME">possible names</a> for variables are given in the
<a href="#grammar">SPARQL grammar</a>.</p>
<div class="grammarExtract">
  Grammar rules:<div class="grammarTable">
    <table id="table111">
      <tbody><tr>
        <td><code class="gRuleLabel">[44]</code></td>
  <td><code class="gRuleHead"><a href="#rVar">Var</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rVAR1">VAR1</a> | <a href="#rVAR2">VAR2</a></code></td>
      </tr>
      <tr>
  <td><code class="gRuleLabel">[74]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rVAR1">VAR1</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">'?' <a href="#rVARNAME">VARNAME</a></code></td>
      </tr>
      <tr>
  <td><code class="gRuleLabel">[75]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rVAR2">VAR2</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">'$' <a href="#rVARNAME">VARNAME</a></code></td>
      </tr>
      <tr>
  <td><code class="gRuleLabel">[97]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rVARNAME">VARNAME</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">( <a href="#rPN_CHARS_U">PN_CHARS_U</a>  | [0-9] ) ( <a href="#rPN_CHARS_U">PN_CHARS_U</a> | [0-9] | #x00B7 | [#x0300-#x036F] | [#x203F-#x2040] )*</code></td>
      </tr>
    </tbody></table>
  </div>
</div>
<h4>4.1.4 <a id="QSynBlankNodes" name="QSynBlankNodes">Syntax for Blank Nodes</a></h4>
<p><a class="norm" href="http://www.w3.org/TR/rdf-concepts/#section-blank-nodes">Blank 
nodes</a> in graph patterns act as non-distinguished variables, not as references to specific blank nodes in the 
data being queried.</p>
    <p>Blank nodes are indicated by either the label form, such as "<code>_:abc</code>", or the abbreviated form "<code>[]</code>". A blank 
node that is used in only one place in the query syntax can be indicated with
<code>[]</code>. A unique blank node will be used to form the triple 
pattern. Blank node labels are written as "<code>_:abc</code>" for a blank node with 
label "<code>abc</code>". The same blank node label cannot be used 
    in two different basic graph patterns in the same query.</p>
<p>The <code>[:p :v]</code> construct can be used in triple patterns. It creates 
a blank node label which is used as the subject of all contained predicate-object 
pairs. The created blank node can also be used in further triple patterns in the 
subject and object positions.</p>
<p>The following two forms</p>
<pre class="query untested">[ :p "v" ] .
</pre>
<pre class="query untested">[] :p "v" .
</pre>
<p>allocate a unique blank node label (here "<code>b57</code>") and are equivalent 
to writing:</p>
<pre class="query untested">_:b57 :p "v" .
</pre>
<p>This allocated blank node label can be used as the subject or object of further 
triple patterns. For example, as a subject:</p>
<pre class="query untested">[ :p "v" ] :q "w" .
</pre>
<p>which is equivalent to the two triples:</p>
<pre class="query untested">_:b57 :p "v" .
_:b57 :q "w" .
</pre>
<p>and as an object:</p>
<pre class="query untested">:x :q [ :p "v" ] .
</pre>
<p>which is equivalent to the two triples:</p>
<pre class="query untested">:x  :q _:b57 .
_:b57 :p "v" .
</pre>
<p>Abbreviated blank node syntax can be combined with other abbreviations for 
<a href="#predObjLists">common 
subjects</a> and <a href="#objLists">common predicates</a>.</p>
<pre class="query untested">  [ foaf:name  ?name ;
    foaf:mbox  &lt;mailto:alice@example.org&gt; ]
</pre>
<p>This is the same as writing the following basic graph pattern for some uniquely 
allocated blank node label, "<code>b18</code>":</p>
<pre class="query untested">  _:b18  foaf:name  ?name .
  _:b18  foaf:mbox  &lt;mailto:alice@example.org&gt; .
</pre>
<div class="grammarExtract">
  Grammar rules:<div class="grammarTable">
    <table id="table112">
      <tbody><tr>
  <td><code class="gRuleLabel">[39]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rBlankNodePropertyList">BlankNodePropertyList</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'['</span><a href="#rPropertyListNotEmpty">PropertyListNotEmpty</a><span class="token">']'</span></code></td>
      </tr>
      <tr>
  <td><code class="gRuleLabel">[69]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rBlankNode">BlankNode</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rBLANK_NODE_LABEL">BLANK_NODE_LABEL</a> |	<a href="#rANON">ANON</a></code></td>
      </tr>
      <tr>
  <td><code class="gRuleLabel">[73]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rBLANK_NODE_LABEL">BLANK_NODE_LABEL</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">'_:' <a href="#rPN_LOCAL">PN_LOCAL</a></code></td>
      </tr>
      <tr>
  <td><code class="gRuleLabel">[94]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rANON">ANON</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">'['  <a href="#rWS">WS</a>* ']'</code></td>
      </tr>
    </tbody></table>
  </div>
</div>
<h3>4.2 <a id="QSynTriples" name="QSynTriples">Syntax for Triple Patterns</a></h3>
<p><a href="#defn_TriplePattern">Triple Patterns</a> are written as a whitespace-separated list of a subject, 
predicate and object; there are abbreviated ways of writing some common triple pattern 
constructs.</p>
<p>The following examples express the same query:</p>
<pre class="query">PREFIX  dc: &lt;http://purl.org/dc/elements/1.1/&gt;
SELECT  ?title
WHERE   { &lt;http://example.org/book/book1&gt; dc:title ?title }  
</pre>
<pre class="query">PREFIX  dc: &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX  : &lt;http://example.org/book/&gt;

SELECT  $title
WHERE   { :book1  dc:title  $title }
</pre>
<pre class="query">BASE    &lt;http://example.org/book/&gt;
PREFIX  dc: &lt;http://purl.org/dc/elements/1.1/&gt;

SELECT  $title
WHERE   { &lt;book1&gt;  dc:title  ?title }
</pre>
<div class="grammarExtract">Grammar rules:<div class="grammarTable">
  <table id="table113">
    <tbody><tr>
  <td><code class="gRuleLabel">[32]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rTriplesSameSubject">TriplesSameSubject</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rVarOrTerm">VarOrTerm</a> <a href="#rPropertyListNotEmpty">PropertyListNotEmpty</a> |<br>
  <a href="#rTriplesNode">TriplesNode</a> <a href="#rPropertyList">PropertyList</a></code></td>
    </tr>
    <tr>
  <td><code class="gRuleLabel">[33]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rPropertyListNotEmpty">PropertyListNotEmpty</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rVerb">Verb</a> <a href="#rObjectList">ObjectList</a> ( <span class="token">';'</span> ( <a href="#rVerb">Verb</a> <a href="#rObjectList">ObjectList</a> )? )*</code></td>
    </tr>
    <tr>
  <td><code class="gRuleLabel">[34]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rPropertyList">PropertyList</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rPropertyListNotEmpty">PropertyListNotEmpty</a>?</code></td>
    </tr>
    <tr>
  <td><code class="gRuleLabel">[35]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rObjectList">ObjectList</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rObject">Object</a> ( <span class="token">','</span> <a href="#rObject">Object</a> )*</code></td>
    </tr>
    <tr>
  <td><code class="gRuleLabel">[37]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rVerb">Verb</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rVarOrIRIref">VarOrIRIref</a> | <span class="token">'a'</span></code></td>
    </tr>
  </tbody></table>
  </div>
</div>
<h4>4.2.1 <a id="predObjLists" name="predObjLists">Predicate-Object Lists</a></h4>
<p>Triple patterns with a common subject can be written so that the subject is only 
written once and is used for more than one triple pattern by employing the "<code>;</code>" 
notation.</p>
<pre class="query untested">    ?x  foaf:name  ?name ;
        foaf:mbox  ?mbox .
</pre>
<p>This is the same as writing the triple patterns:</p>
<pre class="query untested">    ?x  foaf:name  ?name .
    ?x  foaf:mbox  ?mbox .
</pre>
<h4>4.2.2 <a id="objLists" name="objLists">Object Lists</a></h4>
<p>If triple patterns share both subject and predicate, the objects may be separated
by "<code>,</code>".</p>
<pre class="query untested">    ?x foaf:nick  "Alice" , "Alice_" .
</pre>
<p>is the same as writing the triple patterns:</p>
<pre class="query untested">   ?x  foaf:nick  "Alice" .
   ?x  foaf:nick  "Alice_" .
</pre>
<p>Object lists can be combined with predicate-object lists:</p>
<pre class="query untested">   ?x  foaf:name ?name ; foaf:nick  "Alice" , "Alice_" .
</pre>
<p>is equivalent to:</p>
<pre class="query untested">   ?x  foaf:name  ?name .
   ?x  foaf:nick  "Alice" .
   ?x  foaf:nick  "Alice_" .
</pre>
<h4>4.2.3 <a id="collections" name="collections">RDF Collections</a></h4>
<p>
<a class="norm" href="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#collections">
RDF collections</a> can be written in triple patterns using the syntax "(element1 element2 ...)". The 
form "<code>()</code>" is an alternative for the IRI <code>
<a href="http://www.w3.org/1999/02/22-rdf-syntax-ns#nil">http://www.w3.org/1999/02/22-rdf-syntax-ns#nil</a></code>. 
When used with collection elements, such as <code>(1 ?x 3 4)</code>, 
triple patterns 
with blank nodes are allocated for the collection. The blank node at the
 head 
of the collection can be used as a subject or object in other triple 
patterns. The blank nodes allocated by the collection syntax do not 
occur elsewhere in the query.</p>
<pre class="query untested">(1 ?x 3 4) :p "w" .
</pre>
<p>is syntactic sugar for (noting that <code>b0</code>, <code>b1</code>, <code>b2</code> and <code>b3</code> do not occur anywhere else in the 
query):</p>
<pre class="query untested">    _:b0  rdf:first  1 ;
          rdf:rest   _:b1 .
    _:b1  rdf:first  ?x ;
          rdf:rest   _:b2 .
    _:b2  rdf:first  3 ;
          rdf:rest   _:b3 .
    _:b3  rdf:first  4 ;
          rdf:rest   rdf:nil .
    _:b0  :p         "w" . 
</pre>
<p>RDF collections can be nested and can involve other syntactic forms:</p>
<pre class="query untested">(1 [:p :q] ( 2 ) ) .
</pre>
<p>is syntactic sugar for:</p>
<pre class="query untested">    _:b0  rdf:first  1 ;
          rdf:rest   _:b1 .
    _:b1  rdf:first  _:b2 .
    _:b2  :p         :q .
    _:b1  rdf:rest   _:b3 .
    _:b3  rdf:first  _:b4 .
    _:b4  rdf:first  2 ;
          rdf:rest   rdf:nil .
    _:b3  rdf:rest   rdf:nil .
</pre>
<div class="grammarExtract">
  Grammar rules:<div class="grammarTable">
    <table id="table124">
      <tbody><tr>
  <td><code class="gRuleLabel">[40]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rCollection">Collection</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'('</span> <a href="#rGraphNode">GraphNode</a>+ <span class="token">')'</span></code></td>
      </tr>
      <tr>
  <td><code class="gRuleLabel">[92]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rNIL">NIL</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">'(' <a href="#rWS">WS</a>* ')'</code></td>
      </tr>
    </tbody></table>
  </div>
</div>
<h4>4.2.4 <a name="abbrevRdfType" id="abbrevRdfType">rdf:type</a></h4>
<p>The keyword "<code>a</code>" can be used as a predicate in a triple pattern and 
is an alternative for the IRI&nbsp; <code>
<a href="http://www.w3.org/1999/02/22-rdf-syntax-ns#type">http://www.w3.org/1999/02/22-rdf-syntax-ns#type</a></code>. 
This keyword is case-sensitive.</p>
<pre class="query untested">  ?x  a  :Class1 .
  [ a :appClass ] :p "v" .
</pre>
<p>is syntactic sugar for:</p>
<pre class="query untested">  ?x    rdf:type  :Class1 .
  _:b0  rdf:type  :appClass .
  _:b0  :p        "v" .
</pre>

<h2>5 <a id="GraphPattern" name="GraphPattern">Graph Patterns</a></h2>

<p>SPARQL is based around graph pattern matching. More complex graph patterns
can be formed by combining smaller patterns in various ways:</p>

<ul>
  <li><a href="#BasicGraphPatterns">Basic Graph Patterns</a>,
  where a set of triple 
  patterns must match</li>
  <li><a href="#GroupPatterns">Group Graph Pattern</a>, where a set of graph 
  patterns must all match</li>
  <li><a href="#optionals">Optional Graph patterns</a>, where additional patterns 
  may extend the solution</li>
  <li><a href="#alternatives">Alternative Graph Pattern</a>, where two or more possible 
  patterns are tried</li>
  <li><a href="#queryDataset">Patterns on Named Graphs</a>, where patterns are matched 
  against named graphs</li>
</ul>

<p>In this section we describe the two forms that combine patterns by 
conjunction: basic graph patterns, which combine triples patterns, and group 
graph patterns, which combine all other graph patterns.</p>

    <p>The outer-most graph pattern in a query is called the query pattern. It is grammatically identified by <code>GroupGraphPattern</code> in</p>

<div class="grammarExtract">
  <div class="grammarTable">
    <table>
  <tbody><tr valign="baseline">
    <td><code class="gRuleLabel">[13]&nbsp;&nbsp;</code></td>
    <td><code class="gRuleHead"><a href="#rWhereClause">WhereClause</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code class="gRuleBody"><span class="token">'WHERE'</span>? <a href="#rGroupGraphPattern">GroupGraphPattern</a></code></td>
  </tr>
    </tbody></table>
  </div>
</div>

<h3>5.1 <a id="BasicGraphPatterns" name="BasicGraphPatterns">Basic Graph Patterns</a></h3>

<p>Basic graph patterns are sets of triple patterns. SPARQL graph pattern 
matching is defined in terms of combining the results from matching basic graph patterns.</p>

<p>A sequence of triple patterns interrupted by a filter comprises a single
basic graph pattern. Any graph pattern terminates a basic graph pattern.</p>

<h4>5.1.1 <a id="bgpBNodeLabels" name="bgpBNodeLabels">Blank Node Labels</a></h4>

<p>When using blank nodes of the form <code>_:abc</code>,&nbsp; labels for blank 
nodes are scoped to the basic graph pattern.&nbsp; A label can be used in only a 
single basic graph pattern in any query.
</p>

<h4>5.1.2 <a id="bgpExtend" name="bgpExtend">Extending Basic Graph Pattern Matching</a></h4>

<p>SPARQL is defined for matching RDF graphs with simple entailment. SPARQL can 
be extended to other forms of entailment given certain conditions as
<a href="#sparqlBGPExtend">described below</a>.
</p>


<h3>5.2 <a id="GroupPatterns" name="GroupPatterns">Group Graph Patterns</a></h3>

<p>In a SPARQL query string, a group graph pattern is delimited with braces:
<code>{}</code>. For example, this query's query pattern is a group graph pattern of one basic 
graph pattern.</p><div class="exampleGroup">
  <div class="queryGroup">
    <pre class="query">PREFIX foaf:&nbsp;&nbsp;&nbsp; &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name ?mbox
WHERE&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ?x foaf:name ?name .
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ?x foaf:mbox ?mbox .
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
</pre></div></div><div class="exampleGroup">
  <div class="queryGroup">
    The same solutions would be obtained from a query that grouped the triple patterns
    into two basic graph patterns. For example, the query below has a different
    structure but would yield the same solutions as the previous query:
    <pre class="query">PREFIX foaf:&nbsp;&nbsp;&nbsp; &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name ?mbox
WHERE&nbsp; { { ?x foaf:name ?name . }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { ?x foaf:mbox ?mbox . }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</pre></div></div><div class="grammarExtract">
  Grammar rules:<div class="grammarTable">
  <table id="table118">
    <tbody>
      <tr>
	<td>
	  <code class="gRuleLabel">[20]&nbsp;&nbsp;</code>
	</td>
	<td>
	  <code class="gRuleHead"><a href="#rGroupGraphPattern">GroupGraphPattern</a></code>
	</td>
	<td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
	<td>
	  <code class="gRuleBody"><span class="token">'{'</span> <a href="#rTriplesBlock">TriplesBlock</a>? ( ( <a href="#rGraphPatternNotTriples">GraphPatternNotTriples</a> | <a href="#rFilter">Filter</a> ) <span class="token">'.'</span>? <a href="#rTriplesBlock">TriplesBlock</a>? )* <span class="token">'}'</span></code>
	</td>
      </tr>
      <tr>
	<td>
	  <code class="gRuleLabel">[21]&nbsp;&nbsp;</code>
	</td>
	<td>
	  <code class="gRuleHead"><a href="#rTriplesBlock">TriplesBlock</a></code>
	</td>
	<td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
	<td><code class="gRuleBody"><a href="#rTriplesSameSubject">TriplesSameSubject</a> ( <span class="token">'.'</span> <a href="#rTriplesBlock">TriplesBlock</a>? )?</code>
	</td>
      </tr>
      <tr>
	<td><code class="gRuleLabel">[22]&nbsp;&nbsp;</code></td>
	<td><code class="gRuleHead"><a href="#rGraphPatternNotTriples">GraphPatternNotTriples</a></code></td>
	<td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
	<td>
	  <code class="gRuleBody"><a href="#rOptionalGraphPattern">OptionalGraphPattern</a> | <a href="#rGroupOrUnionGraphPattern">GroupOrUnionGraphPattern</a> | <a href="#rGraphGraphPattern">GraphGraphPattern</a></code>
	</td>
      </tr>
    </tbody>
  </table>
  </div>
</div>
  
<h4>5.2.1 <a name="emptyGroupPattern" id="emptyGroupPattern">Empty Group Pattern</a></h4>

<p>The group pattern:</p>
<pre class="query untested">{ }</pre>

<p>matches any graph (including the empty graph) with one solution that does not bind any 
variables. For example:</p>

<pre class="query untested">SELECT ?x
WHERE {}
</pre>

<p>matches with one solution in which variable <code>x</code> is not bound.</p>

<h4>5.2.2 <a name="scopeFilters" id="scopeFilters">Scope of Filters</a></h4>

<p>A constraint, expressed by the keyword <code>FILTER</code>, is a 
restriction on solutions over the whole group in which the filter appears. The 
following patterns all have the same solutions:</p>

<div class="exampleGroup">
<div class="queryGroup">
  <pre class="query">&nbsp;{&nbsp; ?x foaf:name ?name .
    ?x foaf:mbox ?mbox .
&nbsp;&nbsp;&nbsp; FILTER regex(?name, "Smith")
 }
  </pre>
</div>
</div>

<div class="exampleGroup">
  <div class="queryGroup">
    <pre class="query">&nbsp;{&nbsp; FILTER regex(?name, "Smith")
    ?x foaf:name ?name .
    ?x foaf:mbox ?mbox .
&nbsp;}
</pre>
</div>
</div>
<div class="exampleGroup">
  <div class="queryGroup">
    <pre class="query">&nbsp;{&nbsp; ?x foaf:name ?name .
&nbsp;&nbsp;&nbsp; FILTER regex(?name, "Smith")
    ?x foaf:mbox ?mbox .
 }
</pre>
</div>
</div>

<h4>5.2.3 <a id="groupExamples" name="groupExamples">Group Graph Pattern Examples</a></h4>

<div class="exampleGroup">
  <div class="queryGroup">
    <pre class="query">&nbsp; {
&nbsp;&nbsp;&nbsp; ?x foaf:name ?name .
&nbsp;&nbsp;&nbsp; ?x foaf:mbox ?mbox .
&nbsp; }</pre>
  </div>
</div>

<p>is a group of one basic graph pattern and that basic graph pattern consists 
    of two triple patterns.</p>

<div class="exampleGroup">
    <div class="queryGroup">
      <pre class="query">&nbsp; {
&nbsp;&nbsp;&nbsp; ?x foaf:name ?name . FILTER regex(?name, "Smith")
&nbsp;&nbsp;&nbsp; ?x foaf:mbox ?mbox .
&nbsp; }</pre>

</div>
</div>

<p>is a group of one basic graph pattern and a filter, and that basic graph 
pattern consists of two triple patterns; the filter does not break the 
basic graph pattern into two basic graph patterns.</p>

<div class="exampleGroup">
  <div class="queryGroup">
    <pre class="query">&nbsp; {
&nbsp;&nbsp;&nbsp; ?x foaf:name ?name .
&nbsp;&nbsp;&nbsp; {}
&nbsp;&nbsp;&nbsp; ?x foaf:mbox ?mbox .
&nbsp; }</pre>
</div>
</div>

<p>is a group of three elements, a basic graph pattern of one triple pattern, 
an empty group, and another basic graph pattern of one triple pattern.
</p>

<h2>6 <a id="optionals" name="optionals">Including Optional Values</a></h2>
<p>Basic graph patterns allow applications to make queries where the 
entire query 
pattern must match for there to be a solution. For every solution of a 
query containing only group graph patterns with at least one basic graph
 pattern, 
every variable is bound to an RDF Term in a solution. However, regular, 
complete structures cannot be assumed in all RDF graphs. It is useful to
 be able 
to have queries that allow information to be added to the solution where
 the information 
is available, but do not reject the solution because some part of the 
query 
pattern does not match. Optional matching provides this facility: if the
 optional 
part does not match, it creates no bindings but does not eliminate
the solution.</p>
<h3>6.1 <a id="OptionalMatching" name="OptionalMatching">Optional Pattern Matching</a></h3>
<p>Optional parts of the graph pattern may be specified syntactically with the OPTIONAL 
keyword applied to a graph pattern:</p>
<pre class="query untested"><i>pattern</i> OPTIONAL { <i>pattern</i> }
</pre>
<div class="exampleGroup">
  <p>The syntactic form:</p>
<pre class="query untested">{ OPTIONAL { <i>pattern</i> } }
</pre>
<p>is equivalent to:</p>
<pre class="query untested">{ { } OPTIONAL { <i>pattern</i> } }
</pre>
<div class="grammarExtract">
  Grammar rule:<div class="grammarTable">
    <table id="table116">
      <tbody><tr>
  <td><code class="gRuleLabel">[23]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rOptionalGraphPattern">OptionalGraphPattern</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'OPTIONAL'</span> <a href="#rGroupGraphPattern">GroupGraphPattern</a></code></td>
      </tr>
    </tbody></table>
  </div>
</div>
<p>The <code>OPTIONAL</code> keyword is left-associative :</p>
<pre class="query untested"><i>pattern</i> OPTIONAL { <i>pattern</i> } OPTIONAL { pattern }
</pre>
<p>is the same as:</p>
<pre class="query untested">{ <i>pattern</i> OPTIONAL { <i>pattern</i> } } OPTIONAL { pattern }
</pre>

  <p>In an optional match, either the optional graph pattern matches a graph, thereby 
defining and adding bindings to one or more solutions, or it leaves a solution unchanged without adding 
any additional bindings.</p>
  <p>Data:</p>
  <pre class="data">@prefix foaf:       &lt;http://xmlns.com/foaf/0.1/&gt; .
@prefix rdf:        &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .

_:a  rdf:type        foaf:Person .
_:a  foaf:name       "Alice" .
_:a  foaf:mbox       &lt;mailto:alice@example.com&gt; .
_:a  foaf:mbox       &lt;mailto:alice@work.example&gt; .

_:b  rdf:type        foaf:Person .
_:b  foaf:name       "Bob" .
</pre>
  <div class="queryGroup">
    Query:<pre class="query">PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name ?mbox
WHERE  { ?x foaf:name  ?name .
         OPTIONAL { ?x  foaf:mbox  ?mbox }
       }
</pre>
    <p>With the data above, the query result is:</p>
    <div class="result">
      <table class="resultTable" id="table92">
        <tbody><tr>
          <th>name</th>
          <th>mbox</th>
        </tr>
        <tr>
          <td>"Alice"</td>
          <td>&lt;mailto:alice@example.com&gt;</td>
        </tr>
        <tr>
          <td>"Alice"</td>
          <td>&lt;mailto:alice@work.example&gt;</td>
        </tr>
        <tr>
          <td>"Bob"</td>
          <td></td>
        </tr>
      </tbody></table>
    </div>
  </div>
</div>
<p>There is no value of <code>mbox</code> in the solution where the name is
<code>"Bob"</code>.</p>
<p>This query finds the names of people in the data. If there is a triple with predicate
<code>mbox</code> and the same subject, a solution will contain the object of that triple 
as well. In this example, only a single triple pattern is given in the optional match 
part of the query but, in general, the optional part may be any graph pattern. The entire
optional graph pattern must match for the optional graph pattern to affect 
the query solution.</p>
<h3>6.2 <a id="OptionalAndConstraints" name="OptionalAndConstraints">Constraints 
in Optional Pattern Matching</a></h3>
<p>Constraints can be given in an optional graph pattern. For example:</p>
<div class="exampleGroup">
  <pre class="data">@prefix dc:   &lt;http://purl.org/dc/elements/1.1/&gt; .
@prefix :     &lt;http://example.org/book/&gt; .
@prefix ns:   &lt;http://example.org/ns#&gt; .

:book1  dc:title  "SPARQL Tutorial" .
:book1  ns:price  42 .
:book2  dc:title  "The Semantic Web" .
:book2  ns:price  23 .
</pre>
  <div class="queryGroup">
    <pre class="query">PREFIX  dc:  &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX  ns:  &lt;http://example.org/ns#&gt;
SELECT  ?title ?price
WHERE   { ?x dc:title ?title .
          OPTIONAL { ?x ns:price ?price . FILTER (?price &lt; 30) }
        }
</pre>
    <div class="result">
      <table class="resultTable" id="table93">
        <tbody><tr>
          <th>title</th>
          <th>price</th>
        </tr>
        <tr>
          <td>"SPARQL Tutorial"</td>
          <td></td>
        </tr>
        <tr>
          <td>"The Semantic Web"</td>
          <td>23</td>
        </tr>
      </tbody></table>
    </div>
  </div>
</div>
<p>No price appears for the book with title "SPARQL Tutorial" because the optional 
graph pattern did not lead to a solution involving the variable "<code>price</code>".</p>
<h3>6.3 <a id="MultipleOptionals" name="MultipleOptionals">Multiple Optional Graph 
Patterns</a></h3>
<p>Graph patterns are defined recursively. A graph pattern may have zero or more 
optional graph patterns, and any part of a query pattern may have an optional part. 
In this example, there are two optional graph patterns.</p>
<div class="exampleGroup">
  Data:<pre class="data">@prefix foaf:       &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a  foaf:name       "Alice" .
_:a  foaf:homepage   &lt;http://work.example.org/alice/&gt; .

_:b  foaf:name       "Bob" .
_:b  foaf:mbox       &lt;mailto:bob@work.example&gt; .
</pre>
  <div class="queryGroup">
    Query:<pre class="query">PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name ?mbox ?hpage
WHERE  { ?x foaf:name  ?name .
         OPTIONAL { ?x foaf:mbox ?mbox } .
         OPTIONAL { ?x foaf:homepage ?hpage }
       }
</pre>
    <p>Query result:</p>
    <div class="result">
      <table class="resultTable" id="table94">
        <tbody><tr>
          <th>name</th>
          <th>mbox</th>
          <th>hpage</th>
        </tr>
        <tr>
          <td>"Alice"</td>
          <td></td>
          <td>&lt;http://work.example.org/alice/&gt;</td>
        </tr>
        <tr>
          <td>"Bob"</td>
          <td>&lt;mailto:bob@work.example&gt;</td>
          <td></td>
        </tr>
      </tbody></table>
    </div>
  </div>
</div>

<h2>7 <a id="alternatives" name="alternatives">Matching Alternatives</a></h2>
<p>SPARQL provides a means of combining graph patterns so that one of several alternative 
graph patterns may match. If more than one of the alternatives matches, all the 
possible pattern solutions are found.</p>
<p>Pattern alternatives are syntactically specified with the <code>UNION</code> keyword.</p>
<div class="exampleGroup">
  Data:<pre class="data">@prefix dc10:  &lt;http://purl.org/dc/elements/1.0/&gt; .
@prefix dc11:  &lt;http://purl.org/dc/elements/1.1/&gt; .

_:a  dc10:title     "SPARQL Query Language Tutorial" .
_:a  dc10:creator   "Alice" .

_:b  dc11:title     "SPARQL Protocol Tutorial" .
_:b  dc11:creator   "Bob" .

_:c  dc10:title     "SPARQL" .
_:c  dc11:title     "SPARQL (updated)" .
</pre>
  <div class="queryGroup">
    Query:<pre class="query">PREFIX dc10:  &lt;http://purl.org/dc/elements/1.0/&gt;
PREFIX dc11:  &lt;http://purl.org/dc/elements/1.1/&gt;

SELECT ?title
WHERE  { { ?book dc10:title  ?title } UNION { ?book dc11:title  ?title } }
</pre>
    <p>Query result:</p>
    <div class="result">
      <table class="resultTable" id="table97">
        <tbody><tr>
          <th>title</th>
        </tr>
        <tr>
          <td>"SPARQL Protocol Tutorial"</td>
        </tr>
        <tr>
          <td>"SPARQL"</td>
        </tr>
        <tr>
          <td>"SPARQL (updated)"</td>
        </tr>
        <tr>
          <td>"SPARQL Query Language Tutorial"</td>
        </tr>
      </tbody></table>
    </div>
  </div>
  <p>This query finds titles of the books in the data, whether the title is recorded 
  using <a class="inform" href="http://dublincore.org/">Dublin Core</a> properties 
  from version 1.0 or version 1.1. To determine exactly how the information was 
  recorded, a query could use different variables for the two alternatives:</p> 
  <div class="queryGroup">
    <pre class="query">PREFIX dc10:  &lt;http://purl.org/dc/elements/1.0/&gt;
PREFIX dc11:  &lt;http://purl.org/dc/elements/1.1/&gt;

SELECT ?x ?y
WHERE  { { ?book dc10:title ?x } UNION { ?book dc11:title  ?y } }
</pre>
    <div class="result">
      <table class="resultTable" id="table98">
        <tbody><tr>
          <th>x</th>
          <th>y</th>
        </tr>
        <tr>
          <td></td>
          <td>"SPARQL (updated)"</td>
        </tr>
        <tr>
          <td></td>
          <td>"SPARQL Protocol Tutorial"</td>
        </tr>
        <tr>
          <td>"SPARQL"</td>
          <td></td>
        </tr>
        <tr>
          <td>"SPARQL Query Language Tutorial"</td>
          <td></td>
        </tr>
      </tbody></table>
    </div>
  </div>
  <p>This will return results with the variable <code>x</code> bound for solutions from the left branch of the <code>UNION</code>, and <code>y</code> bound 
  for the solutions from the right branch. If neither part of the <code>UNION</code> 
  pattern matched, then the graph pattern would not match.</p>
  <p>The <code>UNION</code> pattern combines graph patterns; each alternative possibility can contain more 
	than one triple 
  pattern:</p>
  <div class="queryGroup">
    <pre class="query">PREFIX dc10:  &lt;http://purl.org/dc/elements/1.0/&gt;
PREFIX dc11:  &lt;http://purl.org/dc/elements/1.1/&gt;

SELECT ?title ?author
WHERE  { { ?book dc10:title ?title .  ?book dc10:creator ?author }
         UNION
         { ?book dc11:title ?title .  ?book dc11:creator ?author }
       }
</pre>
    <div class="result">
      <table class="resultTable" id="table99">
        <tbody><tr>
          <th>author</th>
          <th>title</th>
        </tr>
        <tr>
          <td>"Alice"</td>
          <td>"SPARQL Protocol Tutorial"</td>
        </tr>
        <tr>
          <td>"Bob"</td>
          <td>"SPARQL Query Language Tutorial"</td>
        </tr>
      </tbody></table>
    </div>
  </div>
</div>
<p>This query will only match a book if it has both a title and creator predicate 
from the same version of Dublin Core.</p>
<div class="grammarExtract">
  Grammar rule:<div class="grammarTable">
    <table id="table117">
      <tbody><tr>
  <td><code class="gRuleLabel">[25]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rGroupOrUnionGraphPattern">GroupOrUnionGraphPattern</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rGroupGraphPattern">GroupGraphPattern</a> 
  <br>
  ( <span class="token">'UNION'</span> <a href="#rGroupGraphPattern">GroupGraphPattern</a> )*</code></td>
      </tr>
    </tbody></table>
  </div>
</div>

<h2>8 <a id="rdfDataset" name="rdfDataset">RDF Dataset</a></h2>
<p>The RDF data model expresses information as graphs consisting of triples with 
subject, predicate and object. Many RDF data stores hold multiple RDF graphs and 
record information about each graph, allowing an application to make queries that 
involve information from more than one graph.</p>
<p>A SPARQL query is executed against an <em>RDF Dataset</em> which represents a 
collection of graphs. An RDF Dataset comprises one graph, the default graph, which 
does not have a name, and zero or more named graphs, where each named graph is identified by 
an IRI. A SPARQL 
query can match different parts of the query pattern against different graphs as 
described in section <a href="#queryDataset">8.3 Querying the Dataset</a>. </p>
<p>An RDF Dataset may contain zero named graphs; an RDF Dataset always contains one default graph. 
A query does not need to involve 
matching the default graph; the query can just involve matching named graphs.</p>
<p>The graph that is used for matching a basic graph pattern is the <i>active 
graph</i>. In the previous sections, all queries have been shown executed 
against a single graph, the default graph of an RDF dataset as the active graph. 
The <code>GRAPH</code> keyword is used to make the active graph one of all of 
the named graphs in the dataset for part of the query.</p>
<h3>8.1 <a name="exampleDatasets" id="exampleDatasets">Examples of RDF Datasets</a></h3>
<p>The definition of RDF Dataset does not restrict the relationships of named and 
default graphs. Information can be repeated in different graphs; relationships between 
graphs can be exposed. Two useful arrangements are:</p>
<ul>
  <li>to have information in the default graph that includes provenance information 
  about the named graphs</li>
  <li>to include the information in the named graphs in the default graph as well.</li>
</ul>
<div class="exampleGroup">
  <b>Example 1:</b><pre class="data"># <b>Default graph</b>
@prefix dc: &lt;http://purl.org/dc/elements/1.1/&gt; .

&lt;http://example.org/bob&gt;    dc:publisher  "Bob" .
&lt;http://example.org/alice&gt;  dc:publisher  "Alice" .
</pre>
  <pre class="data"># <b>Named graph: http://example.org/bob</b>
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a foaf:name "Bob" .
_:a foaf:mbox &lt;mailto:bob@oldcorp.example.org&gt; .
</pre>
  <pre class="data"># <b>Named graph: http://example.org/alice</b>
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a foaf:name "Alice" .
_:a foaf:mbox &lt;mailto:alice@work.example.org&gt; .
</pre>
</div>
<p>In this example, the default graph contains the names of the publishers of two 
named graphs. The triples in the named graphs are not visible in the default graph 
in this example.</p>
<p id="ex_2"><b>Example 2:</b></p>
<p>RDF data can be combined by the
<a class="norm" href="http://www.w3.org/TR/rdf-mt/#graphdefs">RDF merge</a>
[<a href="#RDF-MT">RDF-MT</a>] of graphs. One possible arrangement of graphs in 
an RDF Dataset is to have the default graph be the RDF merge of some or all of 
the information in the named graphs.</p>
<p>In this next example, the named graphs contain the same triples as before. The 
RDF dataset includes an RDF merge of the named graphs in the default graph, re-labeling 
blank nodes to keep them distinct.</p>
<div class="exampleGroup">
  <pre class="data"># <b>Default graph</b>
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

_:x foaf:name "Bob" .
_:x foaf:mbox &lt;mailto:bob@oldcorp.example.org&gt; .

_:y foaf:name "Alice" .
_:y foaf:mbox &lt;mailto:alice@work.example.org&gt; .
</pre>
  <pre class="data"># <b>Named graph: http://example.org/bob</b>
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a foaf:name "Bob" .
_:a foaf:mbox &lt;mailto:bob@oldcorp.example.org&gt; .
</pre>
  <pre class="data"># <b>Named graph: http://example.org/alice</b>
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a foaf:name "Alice" .
_:a foaf:mbox &lt;<a href="mailto:alice@work.example">mailto:alice@work.example</a>&gt; .</pre>
  <p>In an RDF merge, blank nodes in the merged graph are not shared with blank 
  nodes from the graphs being merged.</p>
</div>
<h3>8.2 <a id="specifyingDataset" name="specifyingDataset">Specifying RDF Datasets</a></h3>
<p>A SPARQL query may specify the dataset to be used for matching by using the
<code>FROM</code> clause and the <code>FROM NAMED</code> clause to describe the 
RDF dataset. If a query provides such a dataset description, then it is used in 
place of any dataset that the query service would use if no dataset description 
is provided in a query. The RDF dataset may also be
<a class="inform" href="http://www.w3.org/TR/rdf-sparql-protocol/#specify-dataset">
specified in a SPARQL protocol request</a>, in which case the protocol description 
overrides any description in the query itself. A query service may refuse a query 
request if the dataset description is not acceptable to the service.</p>
<p>The <code>FROM</code> and <code>FROM NAMED</code> keywords allow a query to specify 
an RDF dataset by reference; they indicate that the dataset should include graphs 
that are obtained from representations of the resources identified by the given 
IRIs (i.e. the absolute form of the given IRI references). The dataset resulting 
from a number of <code>FROM</code> and <code>FROM NAMED</code> clauses is:</p>
<ul>
  <li>a default graph consisting of the RDF merge of the graphs referred to in the
  <code>FROM</code> clauses, and</li>
  <li>a set of (IRI, graph) pairs, one from each <code>FROM NAMED</code> clause.</li>
</ul>
<p>If there is no <code>FROM</code> clause, but there is one or more <code>FROM NAMED</code> 
clauses, then the dataset includes an empty graph for the default graph.</p>
<div class="grammarExtract">
  Grammar rules:<div class="grammarTable">
    <table id="table101">
      <tbody><tr>
  <td><code class="gRuleLabel">[9]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rDatasetClause">DatasetClause</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'FROM'</span> ( <a href="#rDefaultGraphClause">DefaultGraphClause</a> | <a href="#rNamedGraphClause">NamedGraphClause</a> )</code></td>
      </tr>
      <tr>
  <td><code class="gRuleLabel">[10]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rDefaultGraphClause">DefaultGraphClause</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rSourceSelector">SourceSelector</a></code></td>
      </tr>
      <tr>
  <td><code class="gRuleLabel">[11]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rNamedGraphClause">NamedGraphClause</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'NAMED'</span> <a href="#rSourceSelector">SourceSelector</a></code></td>
      </tr>
      <tr>
  <td><code class="gRuleLabel">[12]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rSourceSelector">SourceSelector</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rIRIref">IRIref</a></code></td>
      </tr>
    </tbody></table>
  </div>
</div>
<h4>8.2.1 <a id="unnamedGraph" name="unnamedGraph">Specifying the Default Graph</a></h4>
<p>Each <code>FROM</code> clause contains an IRI that indicates a graph to be 
used to form the default graph. This does not put the graph in as a named graph.</p>
<p>In this example, the RDF Dataset contains a single default graph and no named graphs:</p>
<div class="exampleGroup">
  <pre class="data"><b># Default graph (stored at http://example.org/foaf/aliceFoaf)
</b>@prefix  foaf:  &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a  foaf:name     "Alice" .
_:a  foaf:mbox     &lt;mailto:alice@work.example&gt; .
</pre>
  <div class="queryGroup">
    <pre class="query">PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT  ?name
FROM    &lt;http://example.org/foaf/aliceFoaf&gt;
WHERE   { ?x foaf:name ?name }
</pre>
    <div class="result">
      <table class="resultTable" id="table102">
        <tbody><tr>
          <th>name</th>
        </tr>
        <tr>
          <td>"Alice"</td>
        </tr>
      </tbody></table>
    </div>
  </div>
</div>
<p>If a query provides more than one <code>FROM</code> clause, providing more than 
one IRI to indicate the default graph, then the default graph is based on the
<a class="norm" href="http://www.w3.org/TR/rdf-mt/#graphdefs">RDF merge</a> of the 
graphs obtained from representations of the resources identified by the given IRIs.</p>
<h4>8.2.2 <a id="namedGraphs" name="namedGraphs">Specifying Named Graphs</a></h4>
<p>A query can supply IRIs for the named graphs in the RDF Dataset using the
<code>FROM NAMED</code> clause. Each IRI is used to provide one named graph in the 
RDF Dataset. Using the same IRI in two or more <code>FROM NAMED</code> clauses results 
in one named graph with that IRI appearing in the dataset.</p>
<pre class="data"><b># Graph: http://example.org/bob</b>
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a foaf:name "Bob" .
_:a foaf:mbox &lt;mailto:bob@oldcorp.example.org&gt; .
</pre>
<pre class="data"># <b>Graph: http://example.org/alice</b>
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a foaf:name "Alice" .
_:a foaf:mbox &lt;mailto:alice@work.example&gt; .
</pre>
<div class="queryGroup">
  <pre class="query">...
FROM NAMED &lt;http://example.org/alice&gt;
FROM NAMED &lt;http://example.org/bob&gt;
...</pre>
</div>
<p>The <code>FROM NAMED</code> syntax suggests that the IRI identifies the corresponding 
graph, but the relationship between an IRI and a graph in an RDF dataset 
is indirect. The IRI identifies a resource, and the resource is represented by a 
graph (or, more precisely: by a document that serializes a graph). For
<a class="inform" href="http://www.w3.org/TR/webarch/#intro">further details</a> 
see [<a href="#WEBARCH">WEBARCH</a>].</p>
<h4>8.2.3 <a id="specDataset" name="specDataset">Combining FROM and FROM NAMED</a></h4>
<p>The <code>FROM</code> clause and <code>FROM NAMED</code> clause can be used in 
the same query.</p>
<div class="exampleGroup">
  <pre class="data"># <b>Default graph (stored at http://example.org/dft.ttl)
</b>@prefix dc: &lt;http://purl.org/dc/elements/1.1/&gt; .

&lt;http://example.org/bob&gt;    dc:publisher  "Bob Hacker" .
&lt;http://example.org/alice&gt;  dc:publisher  "Alice Hacker" .
</pre>
  <pre class="data"># <b>Named graph: http://example.org/bob</b>
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a foaf:name "Bob" .
_:a foaf:mbox &lt;mailto:bob@oldcorp.example.org&gt; .
</pre>
  <pre class="data"># <b>Named graph: http://example.org/alice</b>
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a foaf:name "Alice" .
_:a foaf:mbox &lt;mailto:alice@work.example.org&gt; .
</pre>
    <pre class="query">PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX dc: &lt;http://purl.org/dc/elements/1.1/&gt;

SELECT ?who ?g ?mbox
FROM &lt;http://example.org/dft.ttl&gt;
FROM NAMED &lt;http://example.org/alice&gt;
FROM NAMED &lt;http://example.org/bob&gt;
WHERE
{
   ?g dc:publisher ?who .
   GRAPH ?g { ?x foaf:mbox ?mbox }
}
</pre>
</div>
<p>The RDF Dataset for this query contains a default graph and two named graphs. 
The <code>GRAPH</code> keyword is described below.</p>

<p>The actions required to construct the dataset are not determined by the
dataset description alone.  If an IRI is given twice in a dataset
description, either by using two <code>FROM</code> clauses, or a <code>FROM</code> clause and a
<code>FROM NAMED</code> clause, then it does not assume that exactly one or exactly
two attempts are made to obtain an RDF graph associated with the IRI.
Therefore, no assumptions can be made about blank node identity in
triples obtained from the two occurrences in the dataset description.
In general, no assumptions can be made about the equivalence of the graphs.
</p>
<h3>8.3 <a id="queryDataset" name="queryDataset">Querying the Dataset</a></h3>
<p>When querying a collection of graphs, the <code>GRAPH</code> keyword is used 
to match patterns against named graphs. <code>GRAPH</code> can provide an IRI to select 
one graph or use a variable which will range over the IRI of all the named graphs in the query's RDF dataset.</p>
<p>The use of <code>GRAPH</code> changes the active graph for matching basic 
graph patterns within part of the query. Outside the use of <code>GRAPH</code>, 
the default graph is matched by basic graph patterns.</p>
<p>The following two graphs will be used in examples:</p>
<div class="exampleGroup">
  <pre class="data"><b># Named graph: http://example.org/foaf/aliceFoaf
</b>@prefix  foaf:     &lt;http://xmlns.com/foaf/0.1/&gt; .
@prefix  rdf:      &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .
@prefix  rdfs:     &lt;http://www.w3.org/2000/01/rdf-schema#&gt; .

_:a  foaf:name     "Alice" .
_:a  foaf:mbox     &lt;mailto:alice@work.example&gt; .
_:a  foaf:knows    _:b .

_:b  foaf:name     "Bob" .
_:b  foaf:mbox     &lt;mailto:bob@work.example&gt; .
_:b  foaf:nick     "Bobby" .
_:b  rdfs:seeAlso  &lt;http://example.org/foaf/bobFoaf&gt; .

&lt;http://example.org/foaf/bobFoaf&gt;
     rdf:type      foaf:PersonalProfileDocument .
</pre>
  <pre class="data"><b># Named graph: http://example.org/foaf/bobFoaf
</b>@prefix  foaf:     &lt;http://xmlns.com/foaf/0.1/&gt; .
@prefix  rdf:      &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .
@prefix  rdfs:     &lt;http://www.w3.org/2000/01/rdf-schema#&gt; .

_:z  foaf:mbox     &lt;mailto:bob@work.example&gt; .
_:z  rdfs:seeAlso  &lt;http://example.org/foaf/bobFoaf&gt; .
_:z  foaf:nick     "Robert" .

&lt;http://example.org/foaf/bobFoaf&gt;
     rdf:type      foaf:PersonalProfileDocument .
</pre>
  <div class="grammarExtract">
    Grammar rule:<div class="grammarTable">
      <table id="table104">
        <tbody><tr>
  <td><code class="gRuleLabel">[24]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rGraphGraphPattern">GraphGraphPattern</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'GRAPH'</span> <a href="#rVarOrIRIref">VarOrIRIref</a> <a href="#rGroupGraphPattern">GroupGraphPattern</a></code></td>
        </tr>
      </tbody></table>
    </div>
  </div>
  <h4>8.3.1 <a id="accessByLabel" name="accessByLabel">Accessing Graph Names</a></h4>
  <p>The query below matches the graph pattern against each of the named graphs in the 
  dataset and forms solutions which have the <code>src</code> variable bound to 
  IRIs of the graph being matched. The graph pattern is matched with the active 
  graph being each of the named graphs in the dataset. </p>
  <div class="queryGroup">
    <pre class="query">PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;

SELECT ?src ?bobNick
FROM NAMED &lt;http://example.org/foaf/aliceFoaf&gt;
FROM NAMED &lt;http://example.org/foaf/bobFoaf&gt;
WHERE
  {
    GRAPH ?src
    { ?x foaf:mbox &lt;mailto:bob@work.example&gt; .
      ?x foaf:nick ?bobNick
    }
  }
</pre>
    <p>The query result gives the name of the graphs where the information was found 
    and the value for Bob's nick:</p>
    <div class="result">
      <table class="resultTable" id="table105">
        <tbody><tr>
          <th>src</th>
          <th>bobNick</th>
        </tr>
        <tr>
          <td>&lt;http://example.org/foaf/aliceFoaf&gt;</td>
          <td>"Bobby"</td>
        </tr>
        <tr>
          <td>&lt;http://example.org/foaf/bobFoaf&gt;</td>
          <td>"Robert"</td>
        </tr>
      </tbody></table>
    </div>
  </div>
  <h4>8.3.2 <a id="restrictByLabel" name="restrictByLabel">Restricting by Graph 
  IRI</a></h4>
  <p>The query can restrict the matching applied to a specific graph by 
supplying 
  the graph IRI. This sets the active graph to the graph named by the 
IRI. This query looks for Bob's nick as given in the graph <code>http://example.org/foaf/bobFoaf</code>.</p>
  <div class="queryGroup">
    <pre class="query">PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX data: &lt;http://example.org/foaf/&gt;

SELECT ?nick
FROM NAMED &lt;http://example.org/foaf/aliceFoaf&gt;
FROM NAMED &lt;http://example.org/foaf/bobFoaf&gt;
WHERE
  {
     GRAPH data:bobFoaf {
         ?x foaf:mbox &lt;mailto:bob@work.example&gt; .
         ?x foaf:nick ?nick }
  }
</pre>
    <p>which yields a single solution:</p>
    <div class="result">
      <table class="resultTable" id="table106">
        <tbody><tr>
          <th>nick</th>
        </tr>
        <tr>
          <td>"Robert"</td>
        </tr>
      </tbody></table>
    </div>
  </div>
  <h4>8.3.3 <a id="restrictInQuery" name="restrictInQuery">Restricting Possible Graph IRIs</a></h4>
  <p>A variable used in the <code>GRAPH</code> clause may also be used in another
  <code>GRAPH</code> clause or in a graph pattern matched against the default graph 
  in the dataset.</p>
  <p>The query below uses the graph 
  with IRI <code>http://example.org/foaf/aliceFoaf</code> to find the profile document 
  for Bob; it then matches another pattern against that graph. The pattern in the 
  second <code>GRAPH</code> clause finds the blank node (variable <code>w</code>) 
  for the person with the same mail box (given by variable <code>mbox</code>) as 
  found in the first <code>GRAPH</code> clause (variable <code>whom</code>), because 
  the blank node used to match for variable <code>whom</code> from Alice's FOAF 
  file is not the same as the blank node in the profile document (they are in different 
  graphs).</p>
  <div class="queryGroup">
    <pre class="query">PREFIX  data:  &lt;http://example.org/foaf/&gt;
PREFIX  foaf:  &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX  rdfs:  &lt;http://www.w3.org/2000/01/rdf-schema#&gt;

SELECT ?mbox ?nick ?ppd
FROM NAMED &lt;http://example.org/foaf/aliceFoaf&gt;
FROM NAMED &lt;http://example.org/foaf/bobFoaf&gt;
WHERE
{
  GRAPH data:aliceFoaf
  {
    ?alice foaf:mbox &lt;mailto:alice@work.example&gt; ;
           foaf:knows ?whom .
    ?whom  foaf:mbox ?mbox ;
           rdfs:seeAlso ?ppd .
    ?ppd  a foaf:PersonalProfileDocument .
  } .
  GRAPH ?ppd
  {
      ?w foaf:mbox ?mbox ;
         foaf:nick ?nick
  }
}
</pre>
    <div class="result">
      <table class="resultTable" id="table107">
        <tbody><tr>
          <th>mbox</th>
          <th>nick</th>
          <th>ppd</th>
        </tr>
        <tr>
          <td>&lt;mailto:bob@work.example&gt;</td>
          <td>"Robert"</td>
          <td>&lt;http://example.org/foaf/bobFoaf&gt;</td>
        </tr>
      </tbody></table>
    </div>
  </div>
</div>
<p>Any triple in Alice's FOAF file giving Bob's <code>nick</code> is not used to 
provide a nick for Bob because the pattern involving variable <code>nick</code> 
is restricted by <code>ppd</code> to a particular Personal Profile Document.</p>
<h4>8.3.4 <a id="namedAndDefaultGraph" name="namedAndDefaultGraph">Named and Default 
Graphs</a></h4>
<p>Query patterns can involve both the default graph and the named graphs. In this 
example, an aggregator has read in a Web resource on two different occasions. Each 
time a graph is read into the aggregator, it is given an IRI by the local system. 
The graphs are nearly the same but the email address for "Bob" has changed.</p>
<p>In this example, the default graph is being used to record the provenance information and the 
RDF data actually read is kept in two separate graphs, each of which is given a 
different IRI by the system. The RDF dataset consists of two named graphs and the 
information about them.</p>
<p>RDF Dataset:</p>
<div class="exampleGroup">
  <pre class="data"># <b>Default graph</b>
@prefix dc: &lt;http://purl.org/dc/elements/1.1/&gt; .
@prefix g:  &lt;tag:example.org,2005-06-06:&gt; .
@prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt; .

g:graph1 dc:publisher "Bob" .
g:graph1 dc:date "2004-12-06"^^xsd:date .

g:graph2 dc:publisher "Bob" .
g:graph2 dc:date "2005-01-10"^^xsd:date .
</pre>
  <pre class="data"># <b>Graph: locally allocated IRI: tag:example.org,2005-06-06:graph1</b>
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a foaf:name "Alice" .
_:a foaf:mbox &lt;mailto:alice@work.example&gt; .

_:b foaf:name "Bob" .
_:b foaf:mbox &lt;mailto:bob@oldcorp.example.org&gt; .
</pre>
  <pre class="data"># <b>Graph: locally allocated IRI: tag:example.org,2005-06-06:graph2</b>
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a foaf:name "Alice" .
_:a foaf:mbox &lt;mailto:alice@work.example&gt; .

_:b foaf:name "Bob" .
_:b foaf:mbox &lt;mailto:bob@newcorp.example.org&gt; .
</pre>
  <p>This query finds email addresses, detailing the name of the person and the 
  date the information was discovered.</p>
  <div class="queryGroup">
    <pre class="query">PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX dc:   &lt;http://purl.org/dc/elements/1.1/&gt;

SELECT ?name ?mbox ?date
WHERE
  {  ?g dc:publisher ?name ;
        dc:date ?date .
    GRAPH ?g
      { ?person foaf:name ?name ; foaf:mbox ?mbox }
  }
</pre>
    <p>The results show that the email address for "Bob" has changed.</p>
    <div class="result">
      <table class="resultTable" id="table108">
        <tbody><tr>
          <th>name</th>
          <th>mbox</th>
          <th>date</th>
        </tr>
        <tr>
          <td>"Bob"</td>
          <td>&lt;mailto:bob@oldcorp.example.org&gt;</td>
          <td>"2004-12-06"^^xsd:date</td>
        </tr>
        <tr>
          <td>"Bob"</td>
          <td>&lt;mailto:bob@newcorp.example.org&gt;</td>
          <td>"2005-01-10"^^xsd:date</td>
        </tr>
      </tbody></table>
    </div>
  </div>
</div>
<p>The IRI for the date datatype has been abbreviated in the results for clarity.</p>

<h2>9 <a name="solutionModifiers" id="solutionModifiers">Solution Sequences and Modifiers</a></h2>
<p>Query patterns generate an unordered collection of solutions, each
<a href="#defn_sparqlSolutionMapping">solution</a> being a partial function from variables to RDF terms. 
These solutions are then treated as a sequence (a solution sequence), initially in no specific order; 
any sequence modifiers are then applied to create another sequence. Finally, this 
latter sequence is used to generate one of the results of a
<a href="#QueryForms">SPARQL query form</a>.</p>
<p>A <span class="definedTerm">solution sequence modifier</span> is one of:</p>
<ul>
  <li><a href="#modOrderBy">Order</a> modifier: put the solutions in order</li>
  <li><a href="#modProjection">Projection</a> modifier: choose certain 
  variables</li>
  <li><a href="#modDistinct">Distinct</a> modifier: ensure solutions in the 
  sequence are unique</li>
  <li><a href="#modReduced">Reduced</a> modifier: permit elimination of some non-unique solutions</li>
  <li><a href="#modOffset">Offset</a> modifier: control where the solutions 
  start from in the overall sequence of solutions</li>
  <li><a href="#modResultLimit">Limit</a> modifier: restrict the number of solutions</li>
</ul>
<p>Modifiers are applied in the order given by the list above.</p>
<div class="grammarExtract">
  Grammar rules:<div class="grammarTable">
    <table id="table125">
      <tbody><tr>
  <td><code class="gRuleLabel">[5]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rSelectQuery">SelectQuery</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'SELECT'</span> ( <span class="token">
  'DISTINCT'</span> | <span class="token"> 'REDUCED'</span> )? ( <a href="#rVar">Var</a>+ | <span class="token">'*'</span> 
  ) <a href="#rDatasetClause">DatasetClause</a>* <a href="#rWhereClause">
  WhereClause</a> <a href="#rSolutionModifier">SolutionModifier</a></code></td>
      </tr>
      <tr>
  <td><code class="gRuleLabel">[14]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rSolutionModifier">SolutionModifier</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rOrderClause">OrderClause</a>? <a href="#rLimitOffsetClauses">
  LimitOffsetClauses</a>?</code></td>
      </tr>
      <tr>
  <td><code class="gRuleLabel">[15]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rLimitOffsetClauses">LimitOffsetClauses</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">( <a href="#rLimitClause">LimitClause</a> <a href="#rOffsetClause">
  OffsetClause</a>? | <a href="#rOffsetClause">OffsetClause</a> <a href="#rLimitClause">
  LimitClause</a>? )</code></td>
      </tr>
      <tr>
  <td><code class="gRuleLabel">[16]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rOrderClause">OrderClause</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'ORDER'</span> <span class="token">
  'BY'</span> <a href="#rOrderCondition">OrderCondition</a>+</code></td>
      </tr>
      </tbody></table>
  </div>
</div>

<h3>9.1 <a id="modOrderBy" name="modOrderBy">ORDER BY</a></h3>

<p>The <code>ORDER BY</code> clause establishes the order of a solution sequence.</p>

<p>Following the <code>ORDER BY</code> clause is a sequence of order comparators, composed of an expression and an optional order modifier (either <code>ASC()</code> or <code>DESC()</code>). Each ordering comparator is either ascending (indicated by the <code>ASC()</code> modifier or by no modifier) or descending (indicated by the <code>DESC()</code> modifier).</p>

<div class="exampleGroup">
  <div class="queryGroup">
    <pre class="query">PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;

SELECT ?name
WHERE { ?x foaf:name ?name }
ORDER BY ?name
</pre>
  </div>
</div>
<div class="exampleGroup">
  <div class="queryGroup">
    <pre class="query">PREFIX     :    &lt;http://example.org/ns#&gt;
PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX xsd:     &lt;http://www.w3.org/2001/XMLSchema#&gt;

SELECT ?name
WHERE { ?x foaf:name ?name ; :empId ?emp }
ORDER BY DESC(?emp)
</pre>
  </div>
</div>
<div class="exampleGroup">
  <div class="queryGroup">
    <pre class="query">PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;

SELECT ?name
WHERE { ?x foaf:name ?name ; :empId ?emp }
ORDER BY ?name DESC(?emp)
</pre>
  </div>
</div>

<p>The <a href="#op_lt">"&lt;" operator</a> (see the <a href="#OperatorMapping">Operator Mapping</a> and <a href="#operatorExtensibility">11.3.1 Operator Extensibility</a>) defines 
the relative order of pairs of <code>numerics</code>, <code>simple literals</code>, <code>xsd:strings</code>, <code>xsd:booleans</code> 
and <code>xsd:dateTimes</code>. Pairs of IRIs are ordered by comparing them as <code>simple literals</code>.</p>

<p>SPARQL also fixes an order between some kinds of RDF terms that would not otherwise be ordered:</p>
<ol>
  <li>(Lowest) no value assigned to the variable or expression in this solution.</li>
  <li>Blank nodes</li>
  <li>IRIs</li>
  <li>RDF literals</li>
</ol>
    
    <p>A plain literal is lower than an RDF literal with type <code>xsd:string</code> of the same lexical form.</p>

    <p>SPARQL does not define a total ordering of all possible RDF 
terms. Here are a few examples of pairs of terms for which the relative 
order is undefined:</p>

    <ul>
      <li>"a" and "a"@en_gb (a simple literal and a literal with a language tag)</li>
      <li>"a"@en_gb and "b"@en_gb (two literals with language tags)</li>
      <li>"a" and "a"^^xsd:string (a simple literal and an xsd:string)</li>
      <li>"a" and "1"^^xsd:integer (a simple literal and a literal with a supported data type)</li>
      <li>"1"^^my:integer and "2"^^my:integer (two unsupported data types)</li>
      <li>"1"^^xsd:integer and "2"^^my:integer (a supported data type and an unsupported data type)</li>
    </ul>

    <p>This list of variable bindings is in ascending order:</p>

    <div class="result">
    <table class="resultTable">
      <thead>
	<tr><th>RDF Term</th><th>Reason</th></tr>
      </thead>
      <tbody>
	<tr><td></td><td>Unbound results sort earliest.</td></tr>
	<tr><td><code>_:z</code></td><td>Blank nodes follow unbound.</td></tr>
	<tr><td><code>_:a</code></td><td>There is no relative ordering of blank nodes.</td></tr>
	<tr><td><code>&lt;http://script.example/Latin&gt;</code></td><td>IRIs follow blank nodes.</td></tr>
	<tr><td><code>&lt;http://script.example/Кириллица&gt;</code></td><td>The character in the 23rd position, "К", has a unicode codepoint 0x41A, which is higher than 0x4C ("L").</td></tr>
	<tr><td><code>&lt;http://script.example/漢字&gt;  </code></td><td>The character in the 23rd position, "漢", has a unicode codepoint 0x6F22, which is higher than 0x41A ("К").</td></tr>
	<tr><td><code>"http://script.example/Latin"</code></td><td>Simple literals follow IRIs.</td></tr>
	<tr><td><code>"http://script.example/Latin"^^xsd:string</code></td><td>xsd:strings follow simple literals.</td></tr>
      </tbody>
    </table>
    </div>

<p>The ascending order of two solutions with respect to an ordering 
comparator is established by substituting the solution bindings into the
 expressions and comparing them with the <a href="#op_lt">"&lt;" operator</a>. The descending order is the reverse of the ascending order.</p>

<p>The relative order of two solutions is the relative order of the two 
solutions with respect to the first ordering comparator in the sequence.
 For solutions where the substitutions of the solution bindings produce 
the same RDF term, the order is the relative order of the two solutions 
with respect to the next ordering comparator. The relative order of two 
solutions is undefined if no order expression evaluated for the two 
solutions produces distinct RDF terms.</p>

<p>Ordering a sequence of solutions always results in a sequence with the same number 
of solutions in it.</p>

<p>Using <code>ORDER BY</code> on a solution sequence for a <code>CONSTRUCT</code> or
<code>DESCRIBE</code> query has no direct effect because only <code>SELECT</code> returns 
a sequence of results. Used in combination with <code>LIMIT</code> and <code>OFFSET</code>, 
<code>ORDER BY</code> can be used to return results generated from a different slice of the solution sequence.
An <code>ASK</code> query does not include <code>ORDER BY</code>, <code>LIMIT</code> or <code>OFFSET</code>.
</p>

<div class="grammarExtract">
  Grammar rules:<div class="grammarTable">
    <table>
<tbody><tr>
  <td><code class="gRuleLabel">[16]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rOrderClause">OrderClause</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'ORDER'</span> <span class="token">'BY'</span> <a href="#rOrderCondition">OrderCondition</a>+</code></td>
</tr>
<tr>
  <td><code class="gRuleLabel">[17]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rOrderCondition">OrderCondition</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">   ( ( <span class="token">'ASC'</span> | <span class="token">'DESC'</span> ) <a href="#rBrackettedExpression">BrackettedExpression</a> )<br>| ( <a href="#rConstraint">Constraint</a> | <a href="#rVar">Var</a> ) </code></td>
</tr>
<tr>
  <td><code class="gRuleLabel">[18]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rLimitClause">LimitClause</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'LIMIT'</span> <a href="#rINTEGER">INTEGER</a></code></td>
</tr>
<tr>
  <td><code class="gRuleLabel">[19]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rOffsetClause">OffsetClause</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'OFFSET'</span> <a href="#rINTEGER">INTEGER</a></code></td>
</tr>

    </tbody></table>
  </div>
</div>


<h3>9.2 <a id="modProjection" name="modProjection">Projection</a></h3>
<p>The solution sequence can be transformed into one involving only a subset of 
the variables. For each solution in the sequence, a new solution is formed using 
a specified selection of the variables using the SELECT query form.</p>
<p>The following example shows a query to extract just the names of people described 
in an RDF graph using FOAF properties.</p>
<div class="exampleGroup">
  <pre class="data">@prefix foaf:        &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a  foaf:name       "Alice" .
_:a  foaf:mbox       &lt;mailto:alice@work.example&gt; .

_:b  foaf:name       "Bob" .
_:b  foaf:mbox       &lt;mailto:bob@work.example&gt; .
</pre>
  <div class="queryGroup">
    <pre class="query">PREFIX foaf:       &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name
WHERE
 { ?x foaf:name ?name }
</pre>
    <div class="result">
      <table class="resultTable">
        <tbody><tr>
          <th>name</th>
        </tr>
        <tr>
          <td>"Bob"</td>
        </tr>
        <tr>
          <td>"Alice"</td>
        </tr>
      </tbody></table>
    </div>
  </div>
</div>

<h3>9.3 <a id="modDuplicates" name="modDuplicates">Duplicate Solutions</a></h3>

<p>A solution sequence with no <code>DISTINCT</code> or <code>REDUCED</code> query modifier 
will preserve duplicate solutions.</p>

<div class="exampleGroup">
  <pre class="data">@prefix  foaf:  &lt;http://xmlns.com/foaf/0.1/&gt; .

_:x    foaf:name   "Alice" .
_:x    foaf:mbox   &lt;mailto:alice@example.com&gt; .

_:y    foaf:name   "Alice" .
_:y    foaf:mbox   &lt;mailto:asmith@example.com&gt; .

_:z    foaf:name   "Alice" .
_:z    foaf:mbox   &lt;mailto:alice.smith@example.com&gt; .
</pre>
  <div class="queryGroup">
    <pre class="query">PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name WHERE { ?x foaf:name ?name }
</pre>
    <div class="result">
      <table class="resultTable">
        <tbody><tr>
          <th>name</th>
        </tr>
        <tr>
          <td>"Alice"</td>
        </tr>
        <tr>
          <td>"Alice"</td>
        </tr>
        <tr>
          <td>"Alice"</td>
        </tr>
      </tbody></table>
    </div>
  </div>

      <p>The modifiers <code>DISTINCT</code> and <code>REDUCED</code> affect whether duplicates are included in the query results.</p>

<h4>9.3.1 <a id="modDistinct" name="modDistinct">DISTINCT</a></h4>

<p>The <code>DISTINCT</code> solution modifier eliminates duplicate 
solutions. Specifically, each solution that binds the same variables to 
the same RDF terms as another solution is eliminated from the solution 
set.</p>
  <div class="queryGroup">
    <pre class="query">PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT DISTINCT ?name WHERE { ?x foaf:name ?name }
</pre>
    <div class="result">
      <table class="resultTable">
        <tbody><tr>
          <th>name</th>
        </tr>
        <tr>
          <td>"Alice"</td>
        </tr>
      </tbody></table>
    </div>
  </div>
<p id="defunSELECT">Note that, per the <a href="#solutionModifiers">order of solution sequence modifiers</a>, duplicates are eliminated before either limit or offset is applied.</p>

<h4>9.3.2 <a id="modReduced" name="modReduced">REDUCED</a></h4>
    <p>While the <code>DISTINCT</code> modifier ensures that duplicate solutions are eliminated from the solution set, <code>REDUCED</code> simply permits them to be eliminated. The cardinality of any set of variable bindings in an <code>REDUCED</code> solution set is at least one and not more than the cardinality of the solution set with no <code>DISTINCT</code> or <code>REDUCED</code> modifier. For example, using the data above, the query</p>

  <div class="queryGroup">
    <pre class="query">PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT REDUCED ?name WHERE { ?x foaf:name ?name }
</pre>
<p>may have one, two (shown here) or three solutions:</p>
    <div class="result">
      <table class="resultTable">
        <tbody><tr>
          <th>name</th>
        </tr>
        <tr>
          <td>"Alice"</td>
        </tr>
        <tr>
          <td>"Alice"</td>
        </tr>
      </tbody></table>
    </div>
  </div>
</div>

<h3>9.4 <a id="modOffset" name="modOffset">OFFSET</a></h3>
<p><code>OFFSET</code> causes the solutions generated to start after the specified 
number of solutions. An <code>OFFSET</code> of zero has no effect.</p>
<p>Using <code>
LIMIT</code> and <code>OFFSET</code> to select different subsets of the query solutions 
will not be useful unless the order is made predictable by using <code>ORDER BY</code>.</p>
<div class="exampleGroup">
  <div class="queryGroup">
    <pre class="query">PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;

SELECT  ?name
WHERE   { ?x foaf:name ?name }
ORDER BY ?name
LIMIT   5
OFFSET  10</pre>
  </div>
</div>

<h3>9.5 <a id="modResultLimit" name="modResultLimit">LIMIT</a></h3>
<p>The <code>LIMIT</code> clause puts an upper bound on the number of solutions returned. If the 
number of actual solutions is greater than the limit, then at most the limit number 
of solutions will be returned.</p>
<div class="exampleGroup">
  <div class="queryGroup">
    <pre class="query">PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;

SELECT ?name
WHERE { ?x foaf:name ?name }
LIMIT 20
</pre>
  </div>
</div>
<p>A <code>LIMIT</code> of 0 would cause no results to be returned. A limit may not be negative.</p>


<h2>10 <a id="QueryForms" name="QueryForms">Query Forms</a></h2>
<p>SPARQL has four query forms. These query forms use the solutions from 
pattern matching to form result sets or RDF graphs. The query forms are:</p>
<blockquote>
  <dl>
    <dt><a href="#select">SELECT</a></dt>
    <dd>Returns all, or a subset of, the variables bound in a query pattern match.</dd>
    <dt><a href="#construct">CONSTRUCT</a></dt>
    <dd>Returns an RDF graph constructed by substituting variables in a set of triple 
    templates.</dd>
    <dt><a href="#ask">ASK</a></dt>
    <dd>Returns a boolean indicating whether a query pattern matches or not.</dd>
    <dt><a href="#describe">DESCRIBE</a></dt>
    <dd>Returns an RDF graph that describes the resources found.</dd>
  </dl>
</blockquote>
<p>The <a class="inform" href="http://www.w3.org/TR/rdf-sparql-XMLres/">SPARQL Variable 
Binding Results XML Format</a> can be used to serialize the result set from a <code>
SELECT</code> query or the boolean result of an <code>ASK</code> query.</p>


<h3>10.1 <a name="select">SELECT</a></h3>
<p>The SELECT form of results returns variables and their bindings directly. The syntax <code>SELECT 
*</code> is an abbreviation that selects all of the variables in a query.</p>
<div class="exampleGroup">
  <pre class="data">@prefix  foaf:  &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a    foaf:name   "Alice" .
_:a    foaf:knows  _:b .
_:a    foaf:knows  _:c .

_:b    foaf:name   "Bob" .

_:c    foaf:name   "Clare" .
_:c    foaf:nick   "CT" .

</pre>
  <div class="queryGroup">
    <pre class="query">PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?nameX ?nameY ?nickY
WHERE
  { ?x foaf:knows ?y ;
       foaf:name ?nameX .
    ?y foaf:name ?nameY .
    OPTIONAL { ?y foaf:nick ?nickY }
  }
</pre>
    <div class="result">
      <table class="resultTable" id="table33">
        <tbody><tr>
          <th>nameX</th>
          <th>nameY</th>
          <th>nickY</th>
        </tr>
        <tr>
          <td>"Alice"</td>
          <td>"Bob"</td>
          <td></td>
        </tr>
        <tr>
          <td>"Alice"</td>
          <td>"Clare"</td>
          <td>"CT"</td>
        </tr>
      </tbody></table>
    </div>
    <p>Result sets can be accessed by a local API but also can be serialized into 
    either XML or an RDF graph. An XML format is described in
    <a class="inform" href="http://www.w3.org/TR/rdf-sparql-XMLres/">SPARQL Query 
    Results XML Format</a>, and gives for this example:</p>
    <div class="result">
      <pre class="resultSet">&lt;?xml version="1.0"?&gt;
&lt;sparql xmlns="http://www.w3.org/2005/sparql-results#"&gt;
  &lt;head&gt;
    &lt;variable name="nameX"/&gt;
    &lt;variable name="nameY"/&gt;
    &lt;variable name="nickY"/&gt;
  &lt;/head&gt;
  &lt;results&gt;
    &lt;result&gt;
      &lt;binding name="nameX"&gt;
        &lt;literal&gt;Alice&lt;/literal&gt;
      &lt;/binding&gt;
      &lt;binding name="nameY"&gt;
        &lt;literal&gt;Bob&lt;/literal&gt;
      &lt;/binding&gt;
   &lt;/result&gt;
    &lt;result&gt;
      &lt;binding name="nameX"&gt;
        &lt;literal&gt;Alice&lt;/literal&gt;
      &lt;/binding&gt;
      &lt;binding name="nameY"&gt;
        &lt;literal&gt;Clare&lt;/literal&gt;
      &lt;/binding&gt;
      &lt;binding name="nickY"&gt;
        &lt;literal&gt;CT&lt;/literal&gt;
      &lt;/binding&gt;
    &lt;/result&gt;
  &lt;/results&gt;
&lt;/sparql&gt;
</pre>
    </div>
  </div>
</div>
<div class="grammarExtract">
  Grammar rule:<div class="grammarTable">
  <table>

<tbody><tr valign="baseline">
  <td><code class="gRuleLabel">[5]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rSelectQuery">SelectQuery</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'SELECT'</span> ( <span class="token">'DISTINCT'</span> | <span class="token"> 'REDUCED'</span> )? ( <a href="#rVar">Var</a>+ | <span class="token">'*'</span> )<br>
  <a href="#rDatasetClause">DatasetClause</a>* <a href="#rWhereClause">WhereClause</a> <a href="#rSolutionModifier">SolutionModifier</a></code></td>
</tr>

    </tbody></table>
  </div>
</div>

<h3>10.2 <a id="construct" name="construct">CONSTRUCT</a></h3>
<p>The <code>CONSTRUCT</code> query form returns a single RDF graph specified by 
a graph template. The result is an RDF graph formed by taking each query solution 
in the solution sequence, substituting for the variables in the graph template, 
and combining the triples into a single RDF graph by set union.</p>
<p>If any such instantiation produces a triple containing an unbound variable or 
an illegal RDF construct, such as a literal in subject or predicate position, then 
that triple is not included in the output RDF graph. The graph template can contain 
triples with no variables (known as ground or explicit triples), and these also appear 
in the output RDF graph returned by the CONSTRUCT query form.</p>
<div class="exampleGroup">
  <pre class="data">@prefix  foaf:  &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a    foaf:name   "Alice" .
_:a    foaf:mbox   &lt;mailto:alice@example.org&gt; .
</pre>
  <div class="queryGroup">
    <pre class="query">PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX vcard:   &lt;http://www.w3.org/2001/vcard-rdf/3.0#&gt;
CONSTRUCT   { &lt;http://example.org/person#Alice&gt; vcard:FN ?name }
WHERE       { ?x foaf:name ?name }
</pre>
    <p>creates vcard properties from the FOAF information:</p>
    <div class="result">
      <pre class="resultGraph" style="text-align: left;">@prefix vcard: &lt;http://www.w3.org/2001/vcard-rdf/3.0#&gt; .

&lt;http://example.org/person#Alice&gt; vcard:FN "Alice" .
</pre>
    </div>
  </div>
</div>

<h3>10.2.1 <a id="tempatesWithBNodes" name="tempatesWithBNodes">Templates with Blank Nodes</a></h3>
<p>A template can create an RDF graph containing blank nodes. The blank node labels 
are scoped to the template for each solution. If the same label occurs twice in 
a template, then there will be one blank node created for each query solution, but 
there will be different blank nodes for triples generated by different query 
solutions.</p>
<div class="exampleGroup">
  <pre class="data">@prefix  foaf:  &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a    foaf:givenname   "Alice" .
_:a    foaf:family_name "Hacker" .

_:b    foaf:firstname   "Bob" .
_:b    foaf:surname     "Hacker" .
</pre>
  <div class="queryGroup">
    <pre class="query">PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX vcard:   &lt;http://www.w3.org/2001/vcard-rdf/3.0#&gt;

CONSTRUCT { ?x  vcard:N _:v .
            _:v vcard:givenName ?gname .
            _:v vcard:familyName ?fname }
WHERE
 {
    { ?x foaf:firstname ?gname } UNION  { ?x foaf:givenname   ?gname } .
    { ?x foaf:surname   ?fname } UNION  { ?x foaf:family_name ?fname } .
 }
</pre>
    <p>creates vcard properties corresponding to the FOAF information:</p>
    <div class="result">
      <pre class="resultGraph" style="text-align: left;">@prefix vcard: &lt;http://www.w3.org/2001/vcard-rdf/3.0#&gt; .

_:v1 vcard:N         _:x .
_:x vcard:givenName  "Alice" .
_:x vcard:familyName "Hacker" .

_:v2 vcard:N         _:z .
_:z vcard:givenName  "Bob" .
_:z vcard:familyName "Hacker" .
</pre>
    </div>
  </div>
</div>
<p>The use of variable <code>x</code> in the template, which in this example will be bound to 
blank nodes with labels <code>_:a</code> and <code>_:b</code> in the data, 
causes different blank node labels (<code>_:v1</code> and <code>_:v2</code>) in the resulting RDF graph.</p> 

<h3>10.2.2 <a id="accessingRdfGraphs" name="accessingRdfGraphs">Accessing Graphs in the RDF Dataset</a></h3>
<p>Using <code>CONSTRUCT</code>, it is possible to extract parts or the whole of 
graphs from the target RDF dataset. This first example returns the graph (if it 
is in the dataset) with IRI label <code>http://example.org/aGraph</code>; otherwise, 
it returns an empty graph.</p>
<div class="exampleGroup">
  <div class="queryGroup">
    <pre class="query">CONSTRUCT { ?s ?p ?o } WHERE { GRAPH &lt;http://example.org/aGraph&gt; { ?s ?p ?o } . }
</pre>
  </div>
</div>
<p>The access to the graph can be conditional on other information. For example, if the 
default graph contains metadata about the named graphs in the dataset, then a query 
like the following one can extract one graph based on information about the named 
graph:</p>
<div class="exampleGroup">
  <div class="queryGroup">
    <pre class="query">PREFIX  dc: &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX app: &lt;http://example.org/ns#&gt;
CONSTRUCT { ?s ?p ?o } WHERE
 {
   GRAPH ?g { ?s ?p ?o } .
   { ?g dc:publisher &lt;http://www.w3.org/&gt; } .
   { ?g dc:date ?date } .
   FILTER ( app:customDate(?date) &gt; "2005-02-28T00:00:00Z"^^xsd:dateTime ) .
 }
</pre>
  </div>
</div>
<p>where <code>app:customDate</code> identified an <a href="#extensionFunctions">
extension function</a> to turn the data format into an <code>xsd:dateTime</code> 
RDF term.</p>
<div class="grammarExtract">
  Grammar rule:<div class="grammarTable">
  <table>

<tbody><tr valign="baseline">
  <td><code class="gRuleLabel">[6]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rConstructQuery">ConstructQuery</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'CONSTRUCT'</span> <a href="#rConstructTemplate">ConstructTemplate</a><br>
  <a href="#rDatasetClause">DatasetClause</a>* <a href="#rWhereClause">WhereClause</a> <a href="#rSolutionModifier">SolutionModifier</a></code></td>
</tr>

    </tbody></table>
  </div>
</div>

<h3>10.2.3 <a id="SolModandCONSTRUCT" name="SolModandCONSTRUCT">Solution Modifiers and CONSTRUCT</a></h3>
<p>The solution modifiers of a query affect the results of a <code>CONSTRUCT</code> 
query. In this example, the output graph from the <code>CONSTRUCT</code> template 
is formed from just two of the solutions from graph pattern matching. The query outputs 
a graph with the names of the people with the top two sites, rated by hits. The triples 
in the RDF graph are not ordered.</p>
<div class="exampleGroup">
  <pre class="data">@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .
@prefix site: &lt;http://example.org/stats#&gt; .

_:a foaf:name "Alice" .
_:a site:hits 2349 .

_:b foaf:name "Bob" .
_:b site:hits 105 .

_:c foaf:name "Eve" .
_:c site:hits 181 .
</pre>
  <div class="queryGroup">
    <pre class="query">PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX site: &lt;http://example.org/stats#&gt;

CONSTRUCT { [] foaf:name ?name }
WHERE
{ [] foaf:name ?name ;
     site:hits ?hits .
}
ORDER BY desc(?hits)
LIMIT 2
</pre>
    <div class="result">
      <pre class="resultGraph">@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .
_:x foaf:name "Alice" .
_:y foaf:name "Eve" .
</pre>
    </div>
  </div>
</div>

<h3>10.3 <a id="ask" name="ask">ASK</a></h3>
<p>Applications can use the <code>ASK</code> form to test whether or not a query 
pattern has a solution. No information is returned about the possible query solutions, 
just whether or not a solution exists.</p>
<div class="exampleGroup">
  <pre class="data">@prefix foaf:       &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a  foaf:name       "Alice" .
_:a  foaf:homepage   &lt;http://work.example.org/alice/&gt; .

_:b  foaf:name       "Bob" .
_:b  foaf:mbox       &lt;mailto:bob@work.example&gt; .
</pre>
  <div class="queryGroup">
    <pre class="query">PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;
ASK  { ?x foaf:name  "Alice" }
</pre>
    <div class="result">
      <pre class="resultAsk">yes
</pre>
    </div>
    <p>The <a class="inform" href="http://www.w3.org/TR/rdf-sparql-XMLres/">SPARQL 
    Query Results XML Format</a> form of this result set gives:</p>
    <div class="result">
      <pre class="resultSet">&lt;?xml version="1.0"?&gt;
&lt;sparql xmlns="http://www.w3.org/2005/sparql-results#"&gt;
  &lt;head&gt;&lt;/head&gt;
  &lt;results&gt;
    &lt;boolean&gt;true&lt;/boolean&gt;
  &lt;/results&gt;
&lt;/sparql&gt;
</pre>
    </div>
  </div>
  <p>On the same data, the following returns no match because Alice's <code>mbox</code> 
  is not mentioned.</p>
  <div class="queryGroup">
    <pre class="query">PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;
ASK  { ?x foaf:name  "Alice" ;
          foaf:mbox  &lt;mailto:alice@work.example&gt; }
</pre>
    <div class="result">
      <pre class="resultAsk">no
</pre>
    </div>
  </div>
</div>
<div class="grammarExtract">
  Grammar rule:<div class="grammarTable">
    <table id="table126">
      <tbody><tr>
  <td><code class="gRuleLabel">[8]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rAskQuery">AskQuery</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'ASK'</span> <a href="#rDatasetClause">DatasetClause</a>* <a href="#rWhereClause">WhereClause</a></code></td>
      </tr>
    </tbody></table>
  </div>
</div>

<h3>10.4 <a id="describe" name="describe">DESCRIBE</a> (Informative)</h3>
<p>The <code>DESCRIBE</code> form returns a single result RDF graph containing RDF 
data about resources. This data is not prescribed by a SPARQL query, where the query 
client would need to know the structure of the RDF in the data source, but, instead, 
is determined by the SPARQL query processor. The query pattern is used to create 
a result set. The <code>DESCRIBE</code> form takes each of the resources identified 
in a solution, together with any resources directly named by IRI, and assembles 
a single RDF graph by taking a "description" which can come from any 
information available including the target RDF Dataset. The 
description is determined by the query service. The syntax <code>DESCRIBE *</code> 
is an abbreviation that describes all of the variables in a query.</p>

<h4>10.4.1 <a id="explititURIs" name="explititURIs">Explicit IRIs</a></h4>
<p>The <code>DESCRIBE</code> clause itself can take IRIs to identify the resources. 
The simplest <code>DESCRIBE</code> query is just an IRI in the <code>DESCRIBE</code> 
clause:</p>
<div class="exampleGroup">
  <div class="queryGroup">
    <pre class="query">DESCRIBE &lt;http://example.org/&gt;
</pre>
  </div>
</div>

<h4>10.4.2 <a id="identifyingResources" name="identifyingResources">Identifying Resources</a></h4>
<p>The resources to be described can also be taken from the bindings to a query variable in a result set. This enables description 
of resources whether they are identified by IRI or by blank node in the dataset:</p>
<div class="exampleGroup">
  <div class="queryGroup">
    <pre class="query">PREFIX foaf:   &lt;http://xmlns.com/foaf/0.1/&gt;
DESCRIBE ?x
WHERE    { ?x foaf:mbox &lt;mailto:alice@org&gt; }
</pre>
  </div>
</div>
<p>The property <code>foaf:mbox</code> is defined as being an inverse function property 
in the FOAF vocabulary. If treated as such, this query will return information about 
at most one person. If, however, the query pattern has multiple solutions, the RDF 
data for each is the union of all RDF graph descriptions.</p>
<div class="exampleGroup">
  <div class="queryGroup">
    <pre class="query">PREFIX foaf:   &lt;http://xmlns.com/foaf/0.1/&gt;
DESCRIBE ?x
WHERE    { ?x foaf:name "Alice" }
</pre>
  </div>
</div>
<p>More than one IRI or variable can be given:</p>
<div class="exampleGroup">
  <div class="queryGroup">
    <pre class="query">PREFIX foaf:   &lt;http://xmlns.com/foaf/0.1/&gt;
DESCRIBE ?x ?y &lt;http://example.org/&gt;
WHERE    {?x foaf:knows ?y}
</pre>
  </div>
</div>

<h4>10.4.3 <a id="descriptionsOfResources" name="descriptionsOfResources">Descriptions of Resources</a></h4>
<p>The RDF returned is determined by the information publisher. It is the useful 
information the service has about a resource. It may include information about other 
resources: for example, the RDF data for a book may also include details about the author.</p>
<p>A simple query such as</p>
<div class="exampleGroup">
  <div class="queryGroup">
    <pre class="query">PREFIX ent:  &lt;http://org.example.com/employees#&gt;
DESCRIBE ?x WHERE { ?x ent:employeeId "1234" }
</pre>
    <p>might return a description of the employee and some other potentially useful 
    details:</p>
    <div class="result">
      <pre class="resultGraph">@prefix foaf:   &lt;http://xmlns.com/foaf/0.1/&gt; .
@prefix vcard:  &lt;http://www.w3.org/2001/vcard-rdf/3.0&gt; .
@prefix exOrg:  &lt;http://org.example.com/employees#&gt; .
@prefix <code>rdf:    &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .
@prefix owl:    &lt;http://www.w3.org/2002/07/owl#&gt;</code>

_:a     exOrg:employeeId    "1234" ;
       
        <code>foaf:mbox_sha1sum   "ABCD1234" ;</code>
        vcard:N
         [ vcard:Family       "Smith" ;
           vcard:Given        "John"  ] .

<code>foaf:mbox_sha1sum  rdf:type  owl:InverseFunctionalProperty .</code>
</pre>
    </div>
  </div>
</div>
<p>which includes the blank node closure for the
<a href="http://www.w3.org/TR/vcard-rdf" class="inform">vcard</a> vocabulary vcard:N. 
Other possible mechanisms for deciding what information to return include Concise 
Bounded Descriptions [<a href="#CBD">CBD</a>].</p>
<p>For a vocabulary such as FOAF, where the resources are typically blank nodes, 
returning sufficient information to identify a node such as the InverseFunctionalProperty
<code>foaf:mbox_sha1sum</code> as well as information like name and other details recorded 
would be appropriate. In the example, the match to the WHERE clause was returned, 
but this is not required.</p>
<div class="grammarExtract">
  Grammar rule:<div class="grammarTable">
    <table id="table87">
      <tbody><tr>
  <td><code class="gRuleLabel">[7]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rDescribeQuery">DescribeQuery</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'DESCRIBE'</span> ( <a href="#rVarOrIRIref">VarOrIRIref</a>+ | <span class="token">'*'</span> )<br>
  <a href="#rDatasetClause">DatasetClause</a>* <a href="#rWhereClause">WhereClause</a>? <a href="#rSolutionModifier">SolutionModifier</a></code></td>
      </tr>
    </tbody></table>
  </div>
</div>

<h2>11 <a id="tests" name="tests">Testing Values</a></h2>

    <p>SPARQL <code>FILTERs</code> restrict the solutions of a graph pattern match according to a given <a href="#rExpression">expression</a>. Specifically,
    <code>FILTERs</code> eliminate any solutions that, when substituted into the expression, either result in an effective boolean value of <code>false</code> or produce an error. Effective boolean values are defined in section <a href="#ebv">11.2.2 <em>Effective Boolean Value</em></a> and errors are defined in XQuery 1.0: An XML Query Language [<a href="#XQUERY">XQUERY</a>] section <a class="norm" href="http://www.w3.org/TR/2007/REC-xquery-20070123/#dt-type-error">2.3.1, <em>Kinds of Errors</em></a>. These errors have no affect outside of <code>FILTER</code> evaluation.</p>

  <div class="exampleGroup">
    <p>RDF literals may have a <a>datatype IRI</a>:</p>

  <pre class="data">@prefix a:          &lt;http://www.w3.org/2000/10/annotation-ns#&gt; .
@prefix dc:         &lt;http://purl.org/dc/elements/1.1/&gt; .

_:a   a:annotates   &lt;http://www.w3.org/TR/rdf-sparql-query/&gt; .
_:a   dc:date       "2004-12-31T19:00:00-05:00" .

_:b   a:annotates   &lt;http://www.w3.org/TR/rdf-sparql-query/&gt; .
_:b   dc:date       "2004-12-31T19:01:00-05:00"^^&lt;http://www.w3.org/2001/XMLSchema#dateTime&gt; .</pre>
    <p>The object of the first <code>dc:date</code> triple has no type information. The second has the datatype <code>xsd:dateTime</code>.</p>

    <p>SPARQL expressions are constructed according to the grammar and 
provide access to functions (named by IRI) and operator functions 
(invoked by keywords and symbols in the SPARQL grammar). SPARQL 
operators can be used to compare the values of typed literals:</p>

  <div class="queryGroup">
  <pre class="query">PREFIX a:      &lt;http://www.w3.org/2000/10/annotation-ns#&gt;
PREFIX dc:     &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX xsd:    &lt;http://www.w3.org/2001/XMLSchema#&gt;

SELECT ?annot
WHERE { ?annot  a:annotates  &lt;http://www.w3.org/TR/rdf-sparql-query/&gt; .
        ?annot  dc:date      ?date .
        FILTER ( ?date &gt; "2005-01-01T00:00:00Z"^^xsd:dateTime ) }</pre></div></div>

    <p>The SPARQL operators are listed in <a href="#OperatorMapping">section 11.3</a> and are associated with their productions in the grammar.</p>

    <p>In addition, SPARQL provides the ability to invoke arbitrary 
functions, including a subset of the XPath casting functions, listed in <a href="#FunctionMapping">section 11.5</a>. These functions are invoked by name (an IRI) within a SPARQL query. For example:</p>

  <pre class="query untested">... FILTER ( xsd:dateTime(?date) &lt; xsd:dateTime("2005-01-01T00:00:00Z") ) ...</pre>

    <p>The following typographical conventions are used in this section:</p>

    <ul>
      <li>XPath operators are labeled with the prefix <code>op:</code>. XPath operators have no namespace; <code>op:</code> is a labeling convention.</li>
      <li>Operators introduced by this specification are indicated with the <span class="SPARQLoperator">SPARQLoperator class</span>.</li>
    </ul>

    <h3>11.1 <a id="operandDataTypes" name="operandDataTypes">Operand Data Types</a></h3>

    <p>SPARQL functions and operators operate on RDF terms and SPARQL 
variables. A subset of these functions and operators are taken from the <a class="norm" href="http://www.w3.org/TR/xpath-functions/">XQuery 1.0 and XPath 2.0 Functions and Operators</a> [<a href="#FUNCOP">FUNCOP</a>] and have XML Schema <a href="http://www.w3.org/TR/xpath20/#dt-typed-value">typed value</a> arguments and return types.

RDF <code class="type typedLiteral">typed literals</code> passed as arguments to these functions and operators are mapped to XML Schema typed values with a <a href="http://www.w3.org/TR/xpath20/#dt-string-value">string value</a> of the <code class="type lexicalForm">lexical form</code> and an <a href="http://www.w3.org/TR/xmlschema-2/#dt-atomic">atomic datatype</a> corresponding to the <span class="type datatypeIRI">datatype IRI</span>. The returned typed values are mapped back to RDF <code class="type typedLiteral">typed literals</code> the same way.</p>

    <p>SPARQL has additional operators which operate on specific subsets
 of RDF terms. When referring to a type, the following terms denote a <code class="type typedLiteral">typed literal</code> with the corresponding <a class="norm" href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/">XML Schema</a> [<a class="norm" href="#XSDT">XSDT</a>] <span class="type datatypeIRI">datatype IRI</span>:</p>

    <ul>
      <li><code><a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-integer">xsd:integer</a></code></li>
      <li><code><a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-decimal">xsd:decimal</a></code><!-- and derived types:<ul>
	  <li><code><a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-nonPositiveInteger">xsd:nonPositiveInteger</a></code></li>
	  <li><code><a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-negativeInteger">xsd:negativeInteger</a></code></li>
	  <li><code><a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-long">xsd:long</a></code></li>
	  <li><code><a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-int">xsd:int</a></code></li>
	  <li><code><a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-short">xsd:short</a></code></li>
	  <li><code><a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-byte">xsd:byte</a></code></li>
	  <li><code><a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-nonNegativeInteger">xsd:nonNegativeInteger</a></code></li>
	  <li><code><a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-unsignedLong">xsd:unsignedLong</a></code></li>
	  <li><code><a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-unsignedInt">xsd:unsignedInt</a></code></li>
	  <li><code><a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-unsignedShort">xsd:unsignedShort</a></code></li>
	  <li><code><a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-unsignedByte">xsd:unsignedByte</a></code></li>
	  <li><code><a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-positiveInteger">xsd:positiveInteger</a></code></li>
	</ul> --></li>
      <li><code><a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-float">xsd:float</a></code></li>
      <li><code><a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-double">xsd:double</a></code></li>
      <li><code><a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-string">xsd:string</a></code></li>
      <li><code><a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-boolean">xsd:boolean</a></code></li>
      <li><code><a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-dateTime">xsd:dateTime</a></code></li>
    </ul>

    <p>The following terms identify additional types used in SPARQL value tests:</p>

    <ul>
      <li><span class="type numeric">numeric</span> denotes <code class="type typedLiteral">typed literals</code> with datatypes <code>xsd:integer</code>, <code>xsd:decimal</code>, <code>xsd:float</code>, and <code>xsd:double</code>.</li>
      <li><span class="type simpleLiteral">simple literal</span> denotes a <code class="type plainLiteral">plain literal</code> with no <code class="type langTag">language tag</code>.</li>
      <li><span class="type RDFterm">RDF term</span> denotes the types <code class="type IRI">IRI</code>, <code class="type literal">literal</code>, and <code class="type bNode">blank node</code>.</li>
      <li><span class="type variable">variable</span> denotes a SPARQL variable.</li>
    </ul>

  <!-- blockquote>
    <dl>
      <dt class="type numeric">numeric</dt> <dd><code class="type typedLiteral">typed literals</code> with datatypes <code>xsd:integer</code>, <code>xsd:decimal</code>, <code>xsd:float</code>, and <code>xsd:double</code></dd>
      <dt></dt>
      <dt class="type simpleLiteral">simple literal</dt> <dd>a <code class="type plainLiteral">plain literal</code> with no <code class="type langTag">language tag</code>.</dd>
      <dt class="type RDFterm">RDF term</dt> <dd>the types <code class="type IRI">IRI</code>, <code class="type literal">literal</code>, and <code class="type bNode">blank node</code></dd>
      <dt class="type variable">variable</dt> <dd>a SPARQL variable</dd>

    </dl>
  </blockquote -->

    <p>The following types are derived from <span class="type numeric">numeric</span> types and are valid arguments to functions and operators taking <span class="type numeric">numeric</span> arguments:</p>

    <ul>
      <li><a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-nonPositiveInteger"><code>xsd:nonPositiveInteger</code></a></li>
      <li><a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-negativeInteger"><code>xsd:negativeInteger</code></a></li>
      <li><a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-long"><code>xsd:long</code></a></li>
      <li><a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-int"><code>xsd:int</code></a></li>
      <li><a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-short"><code>xsd:short</code></a></li>
      <li><a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-byte"><code>xsd:byte</code></a></li>
      <li><a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-nonNegativeInteger"><code>xsd:nonNegativeInteger</code></a></li>
      <li><a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-unsignedLong"><code>xsd:unsignedLong</code></a></li>
      <li><a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-unsignedInt"><code>xsd:unsignedInt</code></a></li>
      <li><a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-unsignedShort"><code>xsd:unsignedShort</code></a></li>
      <li><a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-unsignedByte"><code>xsd:unsignedByte</code></a></li>
      <li><a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-positiveInteger"><code>xsd:positiveInteger</code></a></li>
    </ul>

    <p>SPARQL language extensions may treat additional types as being derived from XML schema data types.</p>

    <h3>11.2 <a id="evaluation" name="evaluation">Filter Evaluation</a></h3>

    <p>SPARQL provides a subset of the functions and operators defined by XQuery <a href="http://www.w3.org/TR/xquery/#mapping" class="norm">Operator Mapping</a>. XQuery 1.0 section <a href="http://www.w3.org/TR/xquery/#id-expression-processing" class="norm">2.2.3 Expression Processing</a>
 describes the invocation of XPath functions. The following rules 
accommodate the differences in the data and execution models between 
XQuery and SPARQL:</p>

    <ul>
      <li>Unlike XPath/XQuery, SPARQL functions do not process node 
sequences. When interpreting the semantics of XPath functions, assume 
that each argument is a sequence of a single node.</li>

      <li>Functions invoked with an argument of the wrong type will produce a <a href="http://www.w3.org/TR/xquery/#dt-type-error" class="norm">type error</a>. Effective boolean value arguments (labeled "xsd:boolean (EBV)" in the operator mapping table below), are coerced to <code>xsd:boolean</code> using the <a href="#ebv">EBV rules</a> in section 11.2.2 .</li>

      <li>Apart from <a href="#func-bound">BOUND</a>, all functions and operators operate on RDF Terms and will produce a type error if any arguments are unbound.</li>

      <li>Any expression other than <a href="#func-logical-or">logical-or</a> (<code>||</code>) or <a href="#func-logical-and">logical-and</a> (<code>&amp;&amp;</code>) that encounters an error will produce that error.</li>

      <li>A <a href="#func-logical-or">logical-or</a> that encounters an
 error on only one branch will return TRUE if the other branch is TRUE 
and an error if the other branch is FALSE.</li>

      <li>A <a href="#func-logical-and">logical-and</a> that encounters 
an error on only one branch will return an error if the other branch is 
TRUE and FALSE if the other branch is FALSE.</li>

      <li>A <a href="#func-logical-or">logical-or</a> or <a href="#func-logical-and">logical-and</a> that encounters errors on both branches will produce <em>either</em> of the errors.</li>

    </ul>

    <p>The logical-and and logical-or truth table for true (<span class="truth">T</span>), false (<span class="truth">F</span>), and error (<span class="truth error">E</span>) is as follows:</p>

    <table id="truthTable" class="truthTable">
      <thead>
	<tr><th>A</th><th>B</th><th>A || B</th><th>A &amp;&amp; B</th></tr>
      </thead>
      <tbody>
	<tr><th>T</th><th>T</th><td>T</td><td>T</td></tr>
	<tr><th>T</th><th>F</th><td>T</td><td>F</td></tr>
	<tr><th>F</th><th>T</th><td>T</td><td>F</td></tr>
	<tr><th>F</th><th>F</th><td>F</td><td>F</td></tr>
      </tbody>
      <tbody>
	<tr><th>T</th><th><span class="error">E</span></th><td>T</td><td><span class="error">E</span></td></tr>
	<tr><th><span class="error">E</span></th><th>T</th><td>T</td><td><span class="error">E</span></td></tr>
	<tr><th>F</th><th><span class="error">E</span></th><td><span class="error">E</span></td><td>F</td></tr>
	<tr><th><span class="error">E</span></th><th>F</th><td><span class="error">E</span></td><td>F</td></tr>
	<tr><th><span class="error">E</span></th><th><span class="error">E</span></th><td><span class="error">E</span></td><td><span class="error">E</span></td></tr>
      </tbody>
    </table>

    <h4>11.2.1 <a id="invocation" name="invocation">Invocation</a></h4>
    <p>SPARQL defines a syntax for invoking <a>functions</a> and <a>operators</a> on a list of arguments. These are invoked as follows:</p>
    <ul>
      <li>Argument expressions are evaluated, producing argument values. The order of argument evaluation is not defined.</li>
      <li>Numeric arguments are promoted as necessary to fit the expected types for that function or operator.</li>
      <li>The function or operator is invoked on the argument values.</li>
    </ul>

    <p>If any of these steps fails, the invocation generates an error. The effects of errors are defined in <a href="#evaluation">Filter Evaluation</a>.</p>

    <h4>11.2.2 <a id="ebv" name="ebv">Effective Boolean Value</a> (EBV)</h4>

    <p>Effective boolean value is used to calculate the arguments to the logical functions <a href="#func-logical-and">logical-and</a>, <a href="#func-logical-or">logical-or</a>, and <a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-not">fn:not</a>, as well as evaluate the result of a <code>FILTER</code> expression.</p>

    <p>The XQuery <a href="http://www.w3.org/TR/xquery/#id-ebv"> Effective Boolean Value</a> rules rely on the definition of XPath's <a href="http://www.w3.org/TR/xpath-functions/#func-boolean">fn:boolean</a>. The following rules reflect the rules for <code>fn:boolean</code> applied to the argument types present in SPARQL Queries:</p>

    <ul>
      <li>The EBV of any literal whose type is <code>xsd:boolean</code> or <span class="type ">numeric</span> is false if the lexical form is not valid for that datatype (e.g. "abc"^^xsd:integer).</li>
      <li>If the argument is a <span class="type typedLiteral">typed literal</span> with a <span class="type datatype">datatype</span> of <code>xsd:boolean</code>, the EBV is the value of that argument.</li>
      <li>If the argument is a <span class="type plainLiteral">plain literal</span> or a <span class="type typedLiteral">typed literal</span> with a <span class="type datatype">datatype</span> of <code>xsd:string</code>, the EBV is false if the operand value has zero length; otherwise the EBV is true.</li>
      <li>If the argument is a <span class="type numeric">numeric</span> type or a <span class="type typedLiteral">typed literal</span> with a datatype derived from a <span class="type numeric">numeric</span> type, the EBV is false if the operand value is NaN or is numerically equal to zero; otherwise the EBV is true.</li>
      <li>All other arguments, including unbound arguments, produce a type error.</li>
    </ul>

    <p>An EBV of <code>true</code> is represented as a <span class="type typedLiteral">typed literal</span> with a datatype of <code>xsd:boolean</code> and a lexical value of "true"; an EBV of false is represented as a <span class="type typedLiteral">typed literal</span> with a datatype of <code>xsd:boolean</code> and a lexical value of "false".</p>

    <h3>11.3 <a id="OperatorMapping" name="OperatorMapping">Operator Mapping</a></h3>

    <p>The SPARQL grammar identifies a set of operators (for instance, <span class="token">&amp;&amp;</span>, <span class="token">*</span>, <span class="token">isIRI</span>)
 used to construct constraints. The following table associates each of 
these grammatical productions with the appropriate operands and an 
operator function defined by either <a class="norm" href="http://www.w3.org/TR/xpath-functions/">XQuery 1.0 and XPath 2.0 Functions and Operators</a> [<a href="#FUNCOP">FUNCOP</a>] or the SPARQL operators specified in <a href="#SparqlOps">section 11.4</a>.
 When selecting the operator definition for a given set of parameters, 
the definition  with the most specific parameters applies. For instance,
 when evaluating <code>xsd:integer = xsd:signedInt</code>, the definition for <code>=</code> with two <code>numeric</code> parameters applies, rather than the one with two <span class="type RDFterm">RDF terms</span>.
 The table is arranged so that the upper-most viable candiate is the 
most specific. Operators invoked without appropriate operands result in a
 type error.</p>

    <p>SPARQL follows XPath's scheme for numeric type promotions and subtype substitution for arguments to numeric operators. The <a href="http://www.w3.org/TR/xpath20/#mapping">XPath Operator Mapping</a> rules for <span class="type numeric">numeric</span> operands (<code>xsd:integer</code>, <code>xsd:decimal</code>, <code>xsd:float</code>, <code>xsd:double</code>, and types derived from a <span class="type numeric">numeric</span> type) apply to SPARQL operators as well (see <a class="norm" href="http://www.w3.org/TR/xpath20/">XML Path Language (XPath) 2.0</a> [<a href="#XPATH20">XPATH20</a>] for defintions of <a class="norm" href="http://www.w3.org/TR/xpath20/#promotion">numeric type promotions</a> and <a class="norm" href="http://www.w3.org/TR/xpath20/#dt-subtype-substitution">subtype substitution</a>). Some of the operators are associated with nested function expressions, e.g. <code>fn:not(op:numeric-equal(A, B))</code>. Note that per the XPath definitions, <code>fn:not</code> and <code>op:numeric-equal</code> produce an error if their argument is an error.</p>

    <p>The collation for <code>fn:compare</code> is <a href="http://www.w3.org/TR/xpath-functions/#collations">defined by XPath</a> and identified by <code>http://www.w3.org/2005/xpath-functions/collation/codepoint</code>. This collation allows for string comparison based on code point values. Codepoint string equivalence can be tested with <span class="type RDFterm">RDF term</span> equivalence.</p>

    <table summary="SPARQL Unary Operators" class="FAndOTable">
      <caption>SPARQL Unary Operators</caption>
      <tbody>
	<tr><th class="major" scope="col">Operator</th>
	  <th class="major" scope="col">Type(A)</th><th class="major" scope="col">Function</th><th class="major" scope="col">Result type</th></tr>
	<tr><th colspan="4" class="subHeading" scope="col">XQuery Unary Operators</th></tr>
	<tr><th scope="row"><a href="#rUnaryExpression" title="UnaryExpression"><span class="FAOTtoken">!</span> A</a>
	  </th>
	  <td>xsd:boolean <a href="#ebv-arg">(EBV)</a></td><td class="xpathOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-not">fn:not</a>(A)</td><td>xsd:boolean</td></tr>
	<tr><th scope="row"><a href="#rUnaryExpression" title="UnaryExpression"><span class="FAOTtoken">+</span> A</a>
	  </th>
	  <td><span class="type numeric">numeric</span></td><td class="xpathOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-numeric-unary-plus">op:numeric-unary-plus</a>(A)</td><td><span class="type numeric">numeric</span></td></tr>
	<tr><th scope="row"><a href="#rUnaryExpression" title="UnaryExpression"><span class="FAOTtoken">-</span> A</a>
	  </th>
	  <td><span class="type numeric">numeric</span></td><td class="xpathOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-numeric-unary-minus">op:numeric-unary-minus</a>(A)</td><td><span class="type numeric">numeric</span></td></tr>


	<tr><th colspan="5" class="subHeading" scope="col">SPARQL Tests, defined in <a href="#SparqlOps">section 11.4</a></th></tr>

	<tr><th scope="row"><a href="#rBuiltInCall" title="CallExpression"><span class="FAOTtoken">BOUND</span></a>(A)
	  </th>
	  <td><span class="type variable">variable</span></td><td class="xpathOp"><a href="#func-bound" class="SPARQLoperator">bound</a>(A)</td><td>xsd:boolean</td></tr>
	<tr><th scope="row"><a href="#rBuiltInCall" title="CallExpression"><span class="FAOTtoken">isIRI</span></a>(A)<br><a href="#rBuiltInCall" title="CallExpression"><span class="FAOTtoken">isURI</span></a>(A)
	  </th>
	  <td><span class="type RDFterm">RDF term</span></td><td class="xpathOp"><a href="#func-isIRI" class="SPARQLoperator">isIRI</a>(A)</td><td>xsd:boolean</td></tr>

	<tr><th scope="row"><a href="#rBuiltInCall" title="CallExpression"><span class="FAOTtoken">isBLANK</span></a>(A)
	  </th>
	  <td><span class="type RDFterm">RDF term</span></td><td class="xpathOp"><a href="#func-isBlank" class="SPARQLoperator">isBlank</a>(A)</td><td>xsd:boolean</td></tr>
	<tr><th scope="row"><a href="#rBuiltInCall" title="CallExpression"><span class="FAOTtoken">isLITERAL</span></a>(A)
	  </th>
	  <td><span class="type RDFterm">RDF term</span></td><td class="xpathOp"><a href="#func-isLiteral" class="SPARQLoperator">isLiteral</a>(A)</td><td>xsd:boolean</td></tr>

	<tr><th colspan="5" class="subHeading" scope="col">SPARQL Accessors, defined in <a href="#SparqlOps">section 11.4</a></th></tr>
	<tr><th scope="row"><a href="#rBuiltInCall" title="CallExpression"><span class="FAOTtoken">STR</span></a>(A)
	  </th>
	  <td><span class="type literal">literal</span></td><td class="xpathOp"><a href="#func-str" class="SPARQLoperator">str</a>(A)</td><td><span class="type simpleLiteral">simple literal</span></td></tr>
	<tr><th scope="row"><a href="#rBuiltInCall" title="CallExpression"><span class="FAOTtoken">STR</span></a>(A)
	  </th>
	  <td><span class="type IRI">IRI</span></td><td class="xpathOp"><a href="#func-str" class="SPARQLoperator">str</a>(A)</td><td><span class="type simpleLiteral">simple literal</span></td></tr>
	<tr><th scope="row"><a href="#rBuiltInCall" title="CallExpression"><span class="FAOTtoken">LANG</span></a>(A)
	  </th>
	  <td><span class="type literal">literal</span></td><td class="xpathOp"><a href="#func-lang" class="SPARQLoperator">lang</a>(A)</td><td><span class="type simpleLiteral">simple literal</span></td></tr>

	<tr><th scope="row"><a href="#rBuiltInCall" title="CallExpression"><span class="FAOTtoken">DATATYPE</span></a>(A)
	  </th>
	  <td><span class="type typedLiteral">typed literal</span></td><td class="xpathOp"><a href="#func-datatype" class="SPARQLoperator">datatype</a>(A)</td><td><span class="type IRI">IRI</span></td></tr>
	<tr><th scope="row"><a href="#rBuiltInCall" title="CallExpression"><span class="FAOTtoken">DATATYPE</span></a>(A)
	  </th>
	  <td><span class="type simpleLiteral">simple literal</span></td><td class="xpathOp"><a href="#func-datatype" class="SPARQLoperator">datatype</a>(A)</td><td><span class="type IRI">IRI</span></td></tr>
      </tbody>
    </table>

    <table summary="SPARQL Binary Operators" class="FAndOTable">
      <caption>SPARQL Binary Operators</caption>
      <tbody>
	<tr><th class="major" scope="col">Operator</th>
	  <th class="major" scope="col">Type(A)</th><th class="major" scope="col">Type(B)</th><th class="major" scope="col">Function</th><th class="major" scope="col">Result type</th></tr>
	<tr><th colspan="5" class="subHeading" scope="col">Logical Connectives, defined in <a href="#SparqlOps">section 11.4</a></th></tr>

	<tr><th><a href="#rConditionalOrExpression" title="ConditionalOrExpression">A <span class="FAOTtoken">||</span> B</a></th>
	  <td>xsd:boolean <a href="#ebv-arg">(EBV)</a></td><td>xsd:boolean <a href="#ebv-arg">(EBV)</a></td><td class="sparqlOp"><a href="#func-logical-or" class="SPARQLoperator">logical-or</a>(A, B)</td><td>xsd:boolean</td></tr>
	<tr><th><a href="#rConditionalAndExpression" title="ConditionalAndExpression">A <span class="FAOTtoken">&amp;&amp;</span> B</a></th>
	  <td>xsd:boolean <a href="#ebv-arg">(EBV)</a></td><td>xsd:boolean <a href="#ebv-arg">(EBV)</a></td><td class="sparqlOp"><a href="#func-logical-and" class="SPARQLoperator">logical-and</a>(A, B)</td><td>xsd:boolean</td></tr>

	<tr><th colspan="5" class="subHeading" scope="col">XPath Tests</th></tr>

	<!-- eq -->
	<tr><th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">=</span> B</a></th>
	  <td><span class="type numeric">numeric</span></td><td><span class="type numeric">numeric</span></td><td class="xpathOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-numeric-equal">op:numeric-equal</a>(A, B)</td><td>xsd:boolean</td></tr>
	<tr><th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">=</span> B</a></th>
	  <td><span class="type simpleLiteral">simple literal</span></td><td><span class="type simpleLiteral">simple literal</span></td><td class="xpathOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-numeric-equal">op:numeric-equal</a>(<a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-compare">fn:compare</a>(A, B), 0)</td><td>xsd:boolean</td></tr>
	<tr><th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">=</span> B</a></th>
	  <td>xsd:string</td><td>xsd:string</td><td class="xpathOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-numeric-equal">op:numeric-equal</a>(<a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-compare">fn:compare</a>(<a href="#func-str" class="FAOTtoken">STR</a>(A), <a href="#func-str" class="FAOTtoken">STR</a>(B)), 0)</td><td>xsd:boolean</td></tr>
	<tr><th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">=</span> B</a></th>
	  <td>xsd:boolean</td><td>xsd:boolean</td><td class="xpathOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-boolean-equal">op:boolean-equal</a>(A, B)</td><td>xsd:boolean</td></tr>
	<tr><th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">=</span> B</a></th>
	  <td>xsd:dateTime</td><td>xsd:dateTime</td><td class="xpathOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-dateTime-equal">op:dateTime-equal</a>(A, B)</td><td>xsd:boolean</td></tr>


	<!-- ne -->
	<tr><th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">!=</span> B</a></th>
	  <td><span class="type numeric">numeric</span></td><td><span class="type numeric">numeric</span></td><td class="xpathOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-not">fn:not</a>(<a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-numeric-equal">op:numeric-equal</a>(A, B))</td><td>xsd:boolean</td></tr>
	<tr><th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">!=</span> B</a></th>
	  <td><span class="type simpleLiteral">simple literal</span></td><td><span class="type simpleLiteral">simple literal</span></td><td class="xpathOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-not">fn:not</a>(<a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-numeric-equal">op:numeric-equal</a>(<a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-compare">fn:compare</a>(A, B), 0))</td><td>xsd:boolean</td></tr>
	<tr><th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">!=</span> B</a></th>
	  <td>xsd:string</td><td>xsd:string</td><td class="xpathOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-not">fn:not</a>(<a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-numeric-equal">op:numeric-equal</a>(<a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-compare">fn:compare</a>(<a href="#func-str" class="FAOTtoken">STR</a>(A), <a href="#func-str" class="FAOTtoken">STR</a>(B)), 0))</td><td>xsd:boolean</td></tr>
	<!-- tr><th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">!=</span> B</a></th>
	  <td><span class="type simpleLiteral">simple literal</span></td><td><span class="type simpleLiteral">simple literal</span></td><td class="sparqlOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-not">fn:not</a>(<a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-numeric-equal">op:numeric-equal</a>(<a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-compare">fn:compare</a>(A, B), 0))</td><td>xsd:boolean</td></tr -->
	<tr><th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">!=</span> B</a></th>
	  <td>xsd:boolean</td><td>xsd:boolean</td><td class="xpathOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-not">fn:not</a>(<a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-boolean-equal">op:boolean-equal</a>(A, B))</td><td>xsd:boolean</td></tr>
	<tr><th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">!=</span> B</a></th>
	  <td>xsd:dateTime</td><td>xsd:dateTime</td><td class="xpathOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-not">fn:not</a>(<a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-dateTime-equal">op:dateTime-equal</a>(A, B))</td><td>xsd:boolean</td></tr>

	<!-- lt -->
	<tr id="op_lt"><th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&lt;</span> B</a></th>
	  <td><span class="type numeric">numeric</span></td><td><span class="type numeric">numeric</span></td><td class="xpathOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-numeric-less-than">op:numeric-less-than</a>(A, B)</td><td>xsd:boolean</td></tr>
	<tr><th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&lt;</span> B</a></th>
	  <td><span class="type simpleLiteral">simple literal</span></td><td><span class="type simpleLiteral">simple literal</span></td><td class="xpathOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-numeric-equal">op:numeric-equal</a>(<a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-compare">fn:compare</a>(A, B), -1)</td><td>xsd:boolean</td></tr>
	<tr><th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&lt;</span> B</a></th>
	  <td>xsd:string</td><td>xsd:string</td><td class="xpathOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-numeric-equal">op:numeric-equal</a>(<a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-compare">fn:compare</a>(<a href="#func-str" class="FAOTtoken">STR</a>(A), <a href="#func-str" class="FAOTtoken">STR</a>(B)), -1)</td><td>xsd:boolean</td></tr>
	<tr><th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&lt;</span> B</a></th>
	  <td>xsd:boolean</td><td>xsd:boolean</td><td class="xpathOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-boolean-less-than">op:boolean-less-than</a>(A, B)</td><td>xsd:boolean</td></tr>
	<tr><th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&lt;</span> B</a></th>
	  <td>xsd:dateTime</td><td>xsd:dateTime</td><td class="xpathOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-dateTime-less-than">op:dateTime-less-than</a>(A, B)</td><td>xsd:boolean</td></tr>

	<!-- gt -->
	<tr><th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&gt;</span> B</a></th>
	  <td><span class="type numeric">numeric</span></td><td><span class="type numeric">numeric</span></td><td class="xpathOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-numeric-greater-than">op:numeric-greater-than</a>(A, B)</td><td>xsd:boolean</td></tr>
	<tr><th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&gt;</span> B</a></th>
	  <td><span class="type simpleLiteral">simple literal</span></td><td><span class="type simpleLiteral">simple literal</span></td><td class="xpathOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-numeric-equal">op:numeric-equal</a>(<a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-compare">fn:compare</a>(A, B), 1)</td><td>xsd:boolean</td></tr>
	<tr><th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&gt;</span> B</a></th>
	  <td>xsd:string</td><td>xsd:string</td><td class="xpathOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-numeric-equal">op:numeric-equal</a>(<a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-compare">fn:compare</a>(<a href="#func-str" class="FAOTtoken">STR</a>(A), <a href="#func-str" class="FAOTtoken">STR</a>(B)), 1)</td><td>xsd:boolean</td></tr>
	<tr><th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&gt;</span> B</a></th>
	  <td>xsd:boolean</td><td>xsd:boolean</td><td class="xpathOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-boolean-greater-than">op:boolean-greater-than</a>(A, B)</td><td>xsd:boolean</td></tr>
	<tr><th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&gt;</span> B</a></th>
	  <td>xsd:dateTime</td><td>xsd:dateTime</td><td class="xpathOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-dateTime-greater-than">op:dateTime-greater-than</a>(A, B)</td><td>xsd:boolean</td></tr>

	<!-- le -->
	<tr><th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&lt;=</span> B</a></th>
	  <td><span class="type numeric">numeric</span></td><td><span class="type numeric">numeric</span></td><td class="xpathOp"><a href="#func-logical-or" class="SPARQLoperator">logical-or</a>(<a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-numeric-less-than">op:numeric-less-than</a>(A, B), <a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-numeric-equal">op:numeric-equal</a>(A, B))</td><td>xsd:boolean</td></tr>
	<tr><th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&lt;=</span> B</a></th>
	  <td><span class="type simpleLiteral">simple literal</span></td><td><span class="type simpleLiteral">simple literal</span></td><td class="xpathOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-not">fn:not</a>(<a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-numeric-equal">op:numeric-equal</a>(<a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-compare">fn:compare</a>(A, B), 1))</td><td>xsd:boolean</td></tr>
	<tr><th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&lt;=</span> B</a></th>
	  <td>xsd:string</td><td>xsd:string</td><td class="xpathOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-not">fn:not</a>(<a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-numeric-equal">op:numeric-equal</a>(<a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-compare">fn:compare</a>(<a href="#func-str" class="FAOTtoken">STR</a>(A), <a href="#func-str" class="FAOTtoken">STR</a>(B)), 1))</td><td>xsd:boolean</td></tr>
	<tr><th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&lt;=</span> B</a></th>
	  <td>xsd:boolean</td><td>xsd:boolean</td><td class="xpathOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-not">fn:not</a>(<a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-boolean-greater-than">op:boolean-greater-than</a>(A, B))</td><td>xsd:boolean</td></tr>
	<tr><th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&lt;=</span> B</a></th>
	  <td>xsd:dateTime</td><td>xsd:dateTime</td><td class="xpathOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-not">fn:not</a>(<a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-dateTime-greater-than">op:dateTime-greater-than</a>(A, B))</td><td>xsd:boolean</td></tr>

	<!-- ge -->
	<tr><th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&gt;=</span> B</a></th>
	  <td><span class="type numeric">numeric</span></td><td><span class="type numeric">numeric</span></td><td class="xpathOp"><a href="#func-logical-or" class="SPARQLoperator">logical-or</a>(<a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-numeric-greater-than">op:numeric-greater-than</a>(A, B), <a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-numeric-equal">op:numeric-equal</a>(A, B))</td><td>xsd:boolean</td></tr>
	<tr><th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&gt;=</span> B</a></th>
	  <td><span class="type simpleLiteral">simple literal</span></td><td><span class="type simpleLiteral">simple literal</span></td><td class="xpathOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-not">fn:not</a>(<a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-numeric-equal">op:numeric-equal</a>(<a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-compare">fn:compare</a>(A, B), -1))</td><td>xsd:boolean</td></tr>
	<tr><th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&gt;=</span> B</a></th>
	  <td>xsd:string</td><td>xsd:string</td><td class="xpathOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-not">fn:not</a>(<a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-numeric-equal">op:numeric-equal</a>(<a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-compare">fn:compare</a>(<a href="#func-str" class="FAOTtoken">STR</a>(A), <a href="#func-str" class="FAOTtoken">STR</a>(B)), -1))</td><td>xsd:boolean</td></tr>
	<tr><th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&gt;=</span> B</a></th>
	  <td>xsd:boolean</td><td>xsd:boolean</td><td class="xpathOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-not">fn:not</a>(<a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-boolean-less-than">op:boolean-less-than</a>(A, B))</td><td>xsd:boolean</td></tr>
	<tr><th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&gt;=</span> B</a></th>
	  <td>xsd:dateTime</td><td>xsd:dateTime</td><td class="xpathOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-not">fn:not</a>(<a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-dateTime-less-than">op:dateTime-less-than</a>(A, B))</td><td>xsd:boolean</td></tr>

	<tr><th colspan="5" class="subHeading" scope="col">XPath Arithmetic</th></tr>

	<tr><th scope="row"><a href="#rMultiplicativeExpression" title="MultiplicativeExpression">A <span class="FAOTtoken">*</span> B</a></th>
	  <td><span class="type numeric">numeric</span></td><td><span class="type numeric">numeric</span></td><td class="xpathOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-numeric-multiply">op:numeric-multiply</a>(A, B)</td><td><span class="type numeric">numeric</span></td></tr>
	<tr><th scope="row"><a href="#rMultiplicativeExpression" title="MultiplicativeExpression">A <span class="FAOTtoken">/</span> B</a></th>
	  <td><span class="type numeric">numeric</span></td><td><span class="type numeric">numeric</span></td><td class="xpathOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-numeric-divide">op:numeric-divide</a>(A, B)</td><td><span class="type numeric">numeric</span>; but xsd:decimal if both operands are xsd:integer</td></tr>

	<tr><th scope="row"><a href="#rAdditiveExpression" title="AdditiveExpression">A <span class="FAOTtoken">+</span> B</a></th>
	  <td><span class="type numeric">numeric</span></td><td><span class="type numeric">numeric</span></td><td class="xpathOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-numeric-add">op:numeric-add</a>(A, B)</td><td><span class="type numeric">numeric</span></td></tr>
	<tr><th scope="row"><a href="#rAdditiveExpression" title="AdditiveExpression">A <span class="FAOTtoken">-</span> B</a></th>
	  <td><span class="type numeric">numeric</span></td><td><span class="type numeric">numeric</span></td><td class="xpathOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-numeric-subtract">op:numeric-subtract</a>(A, B)</td><td><span class="type numeric">numeric</span></td></tr>


	<tr><th colspan="5" class="subHeading" scope="col">SPARQL Tests, defined in <a href="#SparqlOps">section 11.4</a></th></tr>

	<tr><th><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">=</span> B</a></th>
	  <td><span class="type RDFterm">RDF term</span></td><td><span class="type RDFterm">RDF term</span></td><td class="xpathOp"><a href="#func-RDFterm-equal" class="SPARQLoperator">RDFterm-equal</a>(A, B)</td><td>xsd:boolean</td></tr>
	<tr><th><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">!=</span> B</a></th>
	  <td><span class="type RDFterm">RDF term</span></td><td><span class="type RDFterm">RDF term</span></td><td class="xpathOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-not">fn:not</a>(<a href="#func-RDFterm-equal" class="SPARQLoperator">RDFterm-equal</a>(A, B))</td><td>xsd:boolean</td></tr>
	<tr><th scope="row"><a href="#rBuiltInCall" title="CallExpression"><span class="FAOTtoken">sameTERM</span></a>(A)
	  </th>
	  <td><span class="type RDFterm">RDF term</span></td><td><span class="type RDFterm">RDF term</span></td><td class="xpathOp"><a href="#func-sameTerm" class="SPARQLoperator">sameTerm</a>(A, B)</td><td>xsd:boolean</td></tr>

	<tr><th scope="row"><a href="#rBuiltInCall" title="CallExpression"><span class="FAOTtoken">langMATCHES</span></a>(A, B)
	  </th>
	  <td><span class="type simpleLiteral">simple literal</span></td><td><span class="type simpleLiteral">simple literal</span></td><td class="xpathOp"><a href="#func-langMatches" class="SPARQLoperator">langMatches</a>(A, B)</td><td>xsd:boolean</td></tr>

	<tr><th><a href="#rRegexExpression" title="Regular Expression"><span class="FAOTtoken">REGEX</span></a>(STRING, PATTERN)</th>
	  <td><span class="type simpleLiteral">simple literal</span></td><td><span class="type simpleLiteral">simple literal</span></td><td class="sparqlOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-matches">fn:matches</a>(STRING, PATTERN)</td><td>xsd:boolean</td></tr>

      </tbody>
  </table>

    <table summary="SPARQL Trinary Operators" class="FAndOTable">
      <caption>SPARQL Trinary Operators</caption>
      <tbody>
	<tr><th class="major" scope="col">Operator</th>
	  <th class="major" scope="col">Type(A)</th><th class="major" scope="col">Type(B)</th><th class="major" scope="col">Type(C)</th><th class="major" scope="col">Function</th><th class="major" scope="col">Result type</th></tr>
	<tr><th colspan="6" class="subHeading" scope="col">SPARQL Tests, defined in <a href="#SparqlOps">section 11.4</a></th></tr>
	<tr><th><a href="#rRegexExpression" title="Regular Expression"><span class="FAOTtoken">REGEX</span></a>(STRING, PATTERN, FLAGS)</th>
	  <td><span class="type simpleLiteral">simple literal</span></td><td><span class="type simpleLiteral">simple literal</span></td><td><span class="type simpleLiteral">simple literal</span></td><td class="sparqlOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-matches">fn:matches</a>(STRING, PATTERN, FLAGS)</td><td>xsd:boolean</td></tr>
	<!-- tr><td colspan="5">The <code>fn:matches</code> function is defined in XPath. Its use in SPARQL and an example invocation are described in <a href="#funcex-regex">section 11.4.12</a>.</td></tr -->
      </tbody>
    </table>

    <p><a id="ebv-arg" name="ebv-arg">xsd:boolean function arguments marked with "(EBV)" are coerced to xsd:boolean by evaluating the </a><a href="#ebv">effective boolean value of that argument.</a></p>

    <h4>11.3.1 <a id="operatorExtensibility" name="operatorExtensibility">Operator Extensibility</a></h4>

    <p>SPARQL language extensions may provide additional associations 
between operators and operator functions; this amounts to adding rows to
 the table above. No additional operator may yield a result that 
replaces any result other than a type error in the semantics defined 
above. The consequence of this rule is that SPARQL extensions will 
produce <em>at least</em> the same solutions as an unextended implementation, and may, for some queries, produce more solutions.</p>

    <p>Additional mappings of the '&lt;' operator are expected to 
control the relative ordering of the operands, specifically, when used 
in an <a href="#modOrderBy"><code>ORDER BY</code></a> clause.</p>

    <h3>11.4 <a id="SparqlOps" name="SparqlOps">Operators Definitions</a></h3>

    <p>This section defines the operators introduced by the SPARQL Query
 language. The examples show the behavior of the operators as invoked by
 the appropriate grammatical constructs.</p>

    <h4>11.4.1 <a id="func-bound" name="func-bound" class="SPARQLoperator">bound</a></h4>

  <pre class="prototype"> <code class="return" title="return">xsd:boolean</code>&nbsp;&nbsp;&nbsp;<code class="operator" title="operator">bound</code> (<code class="parm type" title="paramter type">variable</code> <code class="parm name" title="parameter name">var</code>)
</pre>

    <p>Returns <code>true</code> if <code>var</code> is bound to a value. Returns false otherwise. Variables with the value NaN or INF are considered bound.</p>

  <div class="exampleGroup">
  <p>Data:</p>

  <pre class="data">@prefix foaf:        &lt;http://xmlns.com/foaf/0.1/&gt; .
@prefix dc:          &lt;http://purl.org/dc/elements/1.1/&gt; .
@prefix xsd:          &lt;http://www.w3.org/2001/XMLSchema#&gt; .

_:a  foaf:givenName  "Alice".

_:b  foaf:givenName  "Bob" .
_:b  dc:date         "2005-04-04T04:04:04Z"^^xsd:dateTime .</pre>

  <div class="queryGroup">
  <pre class="query">PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX dc:   &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX xsd:   &lt;http://www.w3.org/2001/XMLSchema#&gt;
SELECT ?name
 WHERE { ?x foaf:givenName  ?givenName .
         OPTIONAL { ?x dc:date ?date } .
         FILTER ( bound(?date) ) }
</pre>

  <p>Query result:</p>

  <div class="result">
      <table class="resultTable">
        <tbody>
          <tr>
            <th>givenName</th>
          </tr>

          <tr>
            <td>"Bob"</td>
          </tr>
        </tbody>
      </table>
  </div></div>

    <p>One may test that a  graph pattern is <em>not</em> expressed by specifying an <a><code class="term">OPTIONAL</code></a> <a>graph pattern</a> that introduces a variable and testing to see that the variable is <a><code class="term">not</code></a> <a><code class="term">bound</code></a>. This is called <em>Negation as Failure</em> in logic programming.</p>

  <div class="queryGroup">
  <p>This query matches the people with a <code>name</code> but <em>no</em> expressed <code>date</code>:</p>
  <pre class="query">PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX dc:   &lt;http://purl.org/dc/elements/1.1/&gt;
SELECT ?name
 WHERE { ?x foaf:givenName  ?name .
         OPTIONAL { ?x dc:date ?date } .
         FILTER (!bound(?date)) }</pre>

  <p>Query result:</p>

  <div class="result">
      <table class="resultTable">
        <tbody>
          <tr>
            <th>name</th>
          </tr>

          <tr>
            <td>"Alice"</td>
          </tr>
        </tbody>
      </table>
  </div></div></div>

  <p>Because Bob's <code>dc:date</code> was known, <code>"Bob"</code> was not a solution to the query.</p>


    <h4>11.4.2 <a id="func-isIRI" name="func-isIRI" class="SPARQLoperator">isIRI</a></h4>

  <pre class="prototype"> <code class="return" title="return">xsd:boolean</code>&nbsp;&nbsp;&nbsp;<code class="operator" title="operator">isIRI</code> (<code class="parm type" title="paramter type">RDF term</code> <code class="parm name" title="parameter name">term</code>)
 <code class="return" title="return">xsd:boolean</code>&nbsp;&nbsp;&nbsp;<code class="operator" title="operator">isURI</code> (<code class="parm type" title="paramter type">RDF term</code> <code class="parm name" title="parameter name">term</code>)
</pre>

    <p>Returns <code>true</code> if <code>term</code> is an <span class="type IRI">IRI</span>. Returns <code>false</code> otherwise. <code class="operator" title="operator">isURI</code> is an alternate spelling for the <code class="operator" title="operator">isIRI</code> operator.</p>

  <div class="exampleGroup">
  <pre class="data">@prefix foaf:       &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a  foaf:name       "Alice".
_:a  foaf:mbox       &lt;mailto:alice@work.example&gt; .

_:b  foaf:name       "Bob" .
_:b  foaf:mbox       "bob@work.example" .
</pre>

  <div class="queryGroup">
  <p>This query matches the people with a <code>name</code> and an <code>mbox</code> which is an IRI:</p>
  <pre class="query">PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name ?mbox
 WHERE { ?x foaf:name  ?name ;
            foaf:mbox  ?mbox .
         FILTER isIRI(?mbox) }
</pre>

  <p>Query result:</p>

  <div class="result">
      <table class="resultTable">
        <tbody>
          <tr>
            <th>name</th>
            <th>mbox</th>
          </tr>

          <tr>
            <td>"Alice"</td>
            <td>&lt;mailto:alice@work.example&gt;</td>
          </tr>
        </tbody>
      </table>
  </div></div></div>

    <h4>11.4.3 <a id="func-isBlank" name="func-isBlank" class="SPARQLoperator">isBlank</a></h4>

  <pre class="prototype"> <code class="return" title="return">xsd:boolean</code>&nbsp;&nbsp;&nbsp;<code class="operator" title="operator">isBlank</code> (<code class="parm type" title="paramter type">RDF term</code> <code class="parm name" title="parameter name">term</code>)
</pre>

    <p>Returns <code>true</code> if <code>term</code> is a <span class="type bNode">blank node</span>. Returns <code>false</code> otherwise.</p>

  <div class="exampleGroup">
  <pre class="data">@prefix a:          &lt;http://www.w3.org/2000/10/annotation-ns#&gt; .
@prefix dc:         &lt;http://purl.org/dc/elements/1.1/&gt; .
@prefix foaf:       &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a   a:annotates   &lt;http://www.w3.org/TR/rdf-sparql-query/&gt; .
_:a   dc:creator    "Alice B. Toeclips" .

_:b   a:annotates   &lt;http://www.w3.org/TR/rdf-sparql-query/&gt; .
_:b   dc:creator    _:c .
_:c   foaf:given    "Bob".
_:c   foaf:family   "Smith".</pre>

  <div class="queryGroup">
  <p>This query matches the people with a <code>dc:creator</code> which uses
  predicates from the FOAF vocabulary to express the name. </p>
  <pre class="query">PREFIX a:      &lt;http://www.w3.org/2000/10/annotation-ns#&gt;
PREFIX dc:     &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX foaf:   &lt;http://xmlns.com/foaf/0.1/&gt;

SELECT ?given ?family
 WHERE { ?annot  a:annotates  &lt;http://www.w3.org/TR/rdf-sparql-query/&gt; .
         ?annot  dc:creator   ?c .
         OPTIONAL { ?c  foaf:given   ?given ; foaf:family  ?family } .
         FILTER isBlank(?c)
       }</pre>

  <p>Query result:</p>

  <div class="result">
      <table class="resultTable">
        <tbody>
          <tr>
            <th>given</th>
            <th>family</th>
          </tr>

          <tr>
            <td>"Bob"</td>
            <td>"Smith"</td>
          </tr>
        </tbody>
      </table>
  </div></div></div>

    <p>In this example, there were two objects of <code>foaf:knows</code> predicates, but only one (<code>_:c</code>) was a blank node.</p>

    <h4>11.4.4 <a id="func-isLiteral" name="func-isLiteral" class="SPARQLoperator">isLiteral</a></h4>

  <pre class="prototype"> <code class="return" title="return">xsd:boolean</code>&nbsp;&nbsp;&nbsp;<code class="operator" title="operator">isLiteral</code> (<code class="parm type" title="paramter type">RDF term</code> <code class="parm name" title="parameter name">term</code>)
</pre>

    <p>Returns <code>true</code> if <code>term</code> is a <span class="type literal">literal</span>. Returns <code>false</code> otherwise.</p>

  <div class="exampleGroup">
  <pre class="data">@prefix foaf:       &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a  foaf:name       "Alice".
_:a  foaf:mbox       &lt;mailto:alice@work.example&gt; .

_:b  foaf:name       "Bob" .
_:b  foaf:mbox       "bob@work.example" .
</pre>

  <div class="queryGroup">
  <p>This query is similar to the one in <a href="#func-isIRI">11.4.2</a> except that is matches the people with a <code>name</code> and an <code>mbox</code> which is a literal. This could be used to look for erroneous data (<code>foaf:mbox</code> should only have an 
  IRI as its object).</p>
  <pre class="query">PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name ?mbox
 WHERE { ?x foaf:name  ?name ;
           foaf:mbox  ?mbox .
         FILTER isLiteral(?mbox) }
</pre>

  <p>Query result:</p>

  <div class="result">
      <table class="resultTable">
        <tbody>
          <tr>
            <th>name</th>
            <th>mbox</th>
          </tr>

          <tr>
            <td>"Bob"</td>
            <td>"bob@work.example"</td>
          </tr>
        </tbody>
      </table>
  </div></div></div>

    <h4>11.4.5 <a id="func-str" name="func-str" class="SPARQLoperator">str</a></h4>

  <pre class="prototype"> <code class="return" title="return"><span class="type simpleLiteral">simple literal</span></code>&nbsp;&nbsp;&nbsp;<code class="operator" title="operator">str</code> (<code class="parm type" title="paramter type"><span class="type literal">literal</span></code> <code class="parm name" title="parameter name">ltrl</code>)
 <code class="return" title="return"><span class="type simpleLiteral">simple literal</span></code>&nbsp;&nbsp;&nbsp;<code class="operator" title="operator">str</code> (<code class="parm type" title="paramter type"><span class="type IRI">IRI</span></code> <code class="parm name" title="parameter name">rsrc</code>)
</pre>

    <p>Returns the <code class="type lexicalForm">lexical form</code> of <code>ltrl</code> (a <span class="type literal">literal</span>); returns the codepoint representation of <code>rsrc</code> (an <span class="type IRI">IRI</span>). This is useful for examining parts of an IRI, for instance, the host-name.</p>

  <div class="exampleGroup">
  <pre class="data">@prefix foaf:       &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a  foaf:name       "Alice".
_:a  foaf:mbox       &lt;mailto:alice@work.example&gt; .

_:b  foaf:name       "Bob" .
_:b  foaf:mbox       &lt;mailto:bob@home.example&gt; .
</pre>

  <div class="queryGroup">
  <p>This query selects the set of people who use their <code>work.example</code> address in their foaf profile:</p>
  <pre class="query">PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name ?mbox
 WHERE { ?x foaf:name  ?name ;
            foaf:mbox  ?mbox .
         FILTER regex(str(?mbox), "@work.example") }
</pre>

  <p>Query result:</p>

  <div class="result">
      <table class="resultTable">
        <tbody>
          <tr>
            <th>name</th>
            <th>mbox</th>
          </tr>

          <tr>
            <td>"Alice"</td>
            <td>&lt;mailto:alice@work.example&gt;</td>
          </tr>
        </tbody>
      </table>
  </div></div></div>

    <h4>11.4.6 <a id="func-lang" name="func-lang" class="SPARQLoperator">lang</a></h4>

  <pre class="prototype"> <code class="return" title="return"><span class="type simpleLiteral">simple literal</span></code>&nbsp;&nbsp;&nbsp;<code class="operator" title="operator">lang</code> (<code class="parm type" title="paramter type"><span class="type literal">literal</span></code> <code class="parm name" title="parameter name">ltrl</code>)
</pre>

    <p>Returns the <code class="type langTag">language tag</code> of <code>ltrl</code>, if it has one. It returns <code>""</code> if <code>ltrl</code> has no <code class="type langTag">language tag</code>. Note that the RDF data model does not include literals with an empty <code class="type langTag">language tag</code>.</p>

  <div class="exampleGroup">
  <pre class="data">@prefix foaf:       &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a  foaf:name       "Robert"@EN.
_:a  foaf:name       "Roberto"@ES.
_:a  foaf:mbox       &lt;mailto:bob@work.example&gt; .
</pre>

  <div class="queryGroup">
  <p>This query finds the Spanish <code>foaf:name</code> and <code>foaf:mbox</code>:</p>
  <pre class="query">PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name ?mbox
 WHERE { ?x foaf:name  ?name ;
            foaf:mbox  ?mbox .
         FILTER ( lang(?name) = "ES" ) }</pre>

  <p>Query result:</p>

  <div class="result">
      <table class="resultTable">
        <tbody>
          <tr>
            <th>name</th>
            <th>mbox</th>
          </tr>

          <tr>
            <td>"Roberto"@ES</td>
            <td>&lt;mailto:bob@work.example&gt;</td>
          </tr>
        </tbody>
      </table>
  </div></div></div>

    <h4>11.4.7 <a id="func-datatype" name="func-datatype" class="SPARQLoperator">datatype</a></h4>

  <pre class="prototype"> <code class="return" title="return"><span class="type IRI">IRI</span></code>&nbsp;&nbsp;&nbsp;<code class="operator" title="operator">datatype</code> (<code class="parm type" title="paramter type"><span class="type typedLiteral">typed literal</span></code> <code class="parm name" title="parameter name">typedLit</code>)
 <code class="return" title="return"><span class="type IRI">IRI</span></code>&nbsp;&nbsp;&nbsp;<code class="operator" title="operator">datatype</code> (<code class="parm type" title="paramter type"><span class="type simpleLiteral">simple literal</span></code> <code class="parm name" title="parameter name">simpleLit</code>)
</pre>

    <p>Returns the <code class="type datatypeIRI">datatype IRI</code> of <code>typedLit</code>; returns <code>xsd:string</code> if the parameter is a <span class="type simpleLiteral">simple literal</span>.</p>

  <div class="exampleGroup">
  <pre class="data">@prefix foaf:       &lt;http://xmlns.com/foaf/0.1/&gt; .
@prefix eg:         &lt;http://biometrics.example/ns#&gt; .
@prefix xsd:        &lt;http://www.w3.org/2001/XMLSchema#&gt; .

_:a  foaf:name       "Alice".
_:a  eg:shoeSize     "9.5"^^xsd:float .

_:b  foaf:name       "Bob".
_:b  eg:shoeSize     "42"^^xsd:integer .
</pre>

  <div class="queryGroup">
  <p>This query finds the <code>foaf:name</code> and <code>foaf:shoeSize</code> of everyone with a shoeSize that is an integer:</p>
  <pre class="query">PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX xsd:  &lt;http://www.w3.org/2001/XMLSchema#&gt;
PREFIX eg:   &lt;http://biometrics.example/ns#&gt;
SELECT ?name ?shoeSize
 WHERE { ?x foaf:name  ?name ; eg:shoeSize  ?shoeSize .
         FILTER ( datatype(?shoeSize) = xsd:integer ) }</pre>

  <p>Query result:</p>

  <div class="result">
      <table class="resultTable">
        <tbody>
          <tr>
            <th>name</th>
            <th>shoeSize</th>
          </tr>

          <tr>
            <td>"Bob"</td>
            <td>42</td>
          </tr>
        </tbody>
      </table>
  </div></div></div>

    <h4>11.4.8 <a id="func-logical-or" name="func-logical-or" class="SPARQLoperator">logical-or</a></h4>

  <pre class="prototype"> <code class="return" title="return">xsd:boolean</code>&nbsp;&nbsp;&nbsp;<code class="parm type" title="paramter type">xsd:boolean</code> <code class="parm name" title="parameter name">left</code> <code class="operator" title="operator">||</code> <code class="parm type" title="parameter type">xsd:boolean</code> <code class="parm name" title="parameter name">right</code>
</pre>

    <p>Returns a logical <code>OR</code> of <code>left</code> and <code>right</code>. Note that <code class="SPARQLoperator">logical-or</code> operates on the <a href="#ebv">effective boolean value</a> of its arguments.</p>

    <p>Note: see section 11.2, <a href="#evaluation">Filter Evaluation</a>, for 
    the <code>||</code> operator's treatment of errors.</p>

    <h4>11.4.9 <a id="func-logical-and" name="func-logical-and" class="SPARQLoperator">logical-and</a></h4>

  <pre class="prototype"> <code class="return" title="return">xsd:boolean</code>&nbsp;&nbsp;&nbsp;<code class="parm type" title="paramter type">xsd:boolean</code> <code class="parm name" title="parameter name">left</code> <code class="operator" title="operator">&amp;&amp;</code> <code class="parm type" title="parameter type">xsd:boolean</code> <code class="parm name" title="parameter name">right</code>
</pre>

    <p>Returns a logical <code>AND</code> of <code>left</code> and <code>right</code>. Note that <code class="SPARQLoperator">logical-and</code> operates on the <a href="#ebv">effective boolean value</a> of its arguments.</p>

    <p>Note: see section 11.2, <a href="#evaluation">Filter Evaluation</a>, for 
    the <code>&amp;&amp;</code> operator's treatment of errors.</p>

    <h4>11.4.10 <a id="func-RDFterm-equal" name="func-RDFterm-equal" class="SPARQLoperator">RDFterm-equal</a></h4>

  <pre class="prototype"> <code class="return" title="return">xsd:boolean</code>&nbsp;&nbsp;&nbsp;<code class="parm type" title="paramter type">RDF term</code> <code class="parm name" title="parameter name">term1</code> <code class="operator" title="operator">=</code> <code class="parm type" title="parameter type">RDF term</code> <code class="parm name" title="parameter name">term2</code>
</pre>

    <p>Returns TRUE if <code>term1</code> and <code>term2</code> are the same RDF term as defined in <a class="norm" href="http://www.w3.org/TR/rdf-concepts/">Resource Description Framework (RDF): Concepts and Abstract Syntax</a> [<a href="#CONCEPTS">CONCEPTS</a>]; produces a type error if the arguments are both literal but are not the same RDF term <sup><a href="#func-RDFterm-equal-foot1" class="footnote">*</a></sup>; returns FALSE otherwise. <code>term1</code> and <code>term2</code> are the same if any of the following is true:</p>

    <ul>
      <li><code class="parm name" title="parameter name">term1</code> and <code class="parm name" title="parameter name">term2</code> are equivalent <span class="IRI type">IRIs</span> as defined in <a href="http://www.w3.org/TR/rdf-concepts/#section-Graph-URIref">6.4 RDF URI References</a> 
		of [<a href="#CONCEPTS">CONCEPTS</a>].</li>
      <li><code class="parm name" title="parameter name">term1</code> and <code class="parm name" title="parameter name">term2</code> are equivalent <span class="literal type">literals</span> as defined in <a class="norm" href="http://www.w3.org/TR/rdf-concepts/#section-Literal-Equality">6.5.1 Literal Equality</a> 
		of [<a href="#CONCEPTS">CONCEPTS</a>].</li>
      <li><code class="parm name" title="parameter name">term1</code> and <code class="parm name" title="parameter name">term2</code> are the same <span class="bnode type">blank node</span> as described in <a class="norm" href="http://www.w3.org/TR/rdf-concepts/#section-blank-nodes">6.6 Blank Nodes</a> 
		of [<a href="#CONCEPTS">CONCEPTS</a>].</li>
    </ul>

  <div class="exampleGroup">
  <pre class="data">@prefix foaf:       &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a  foaf:name       "Alice".
_:a  foaf:mbox       &lt;mailto:alice@work.example&gt; .

_:b  foaf:name       "Ms A.".
_:b  foaf:mbox       &lt;mailto:alice@work.example&gt; .
</pre>

  <div class="queryGroup">
  <p>This query finds the people who have multiple <code>foaf:name</code> triples:</p>
  <pre class="query">PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name1 ?name2
 WHERE { ?x foaf:name  ?name1 ;
            foaf:mbox  ?mbox1 .
         ?y foaf:name  ?name2 ;
            foaf:mbox  ?mbox2 .
         FILTER (?mbox1 = ?mbox2 &amp;&amp; ?name1 != ?name2)
       }
</pre>

  <p>Query result:</p>

  <div class="result">
      <table class="resultTable">
        <tbody>
          <tr>
            <th>name1</th>
            <th>name2</th>
          </tr>

          <tr>
            <td>"Alice"</td>
            <td>"Ms A."</td>
          </tr>

          <tr>
            <td>"Ms A."</td>
            <td>"Alice"</td>
          </tr>
        </tbody>
      </table>
  </div></div></div>

    <p>In this query for documents that were annotated on New Year's Day
 (2004 or 2005), the RDF terms are not the same, but have equivalent 
values:</p>

  <div class="exampleGroup">
  <pre class="data">@prefix a:          &lt;http://www.w3.org/2000/10/annotation-ns#&gt; .
@prefix dc:         &lt;http://purl.org/dc/elements/1.1/&gt; .

_:b   a:annotates   &lt;http://www.w3.org/TR/rdf-sparql-query/&gt; .
_:b   dc:date       "2004-12-31T19:00:00-05:00"^^&lt;http://www.w3.org/2001/XMLSchema#dateTime&gt; .</pre>

  <div class="queryGroup">
  <pre class="query">PREFIX a:      &lt;http://www.w3.org/2000/10/annotation-ns#&gt;
PREFIX dc:     &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX xsd:    &lt;http://www.w3.org/2001/XMLSchema#&gt;

SELECT ?annotates
WHERE { ?annot  a:annotates  ?annotates .
        ?annot  dc:date      ?date .
        FILTER ( ?date = xsd:dateTime("2005-01-01T00:00:00Z") ) }</pre>

  <div class="result">
      <table class="resultTable">
        <tbody>
          <tr>
            <th>annotates</th>
          </tr>

          <tr>
            <td>&lt;http://www.w3.org/TR/rdf-sparql-query/&gt;</td>
          </tr>
        </tbody>
      </table>
  </div></div></div>

    <p><sup id="func-RDFterm-equal-foot1" class="footnote">*</sup> 
Invoking RDFterm-equal on two typed literals tests for 
    equivalent values. An extended implementation may have support for 
additional datatypes. An implementation processing a query that tests 
for equivalence on unsupported datatypes (and non-identical lexical form
 and datatype IRI) returns an error, indicating that it was unable to 
determine whether or not the values are equivalent. For example, an 
unextended implementation will produce an error when testing either

    <span class="queryExcerpt untested"><code>"iiii"^^my:romanNumeral = "iv"^^my:romanNumeral</code></span> or
    <span class="queryExcerpt untested"><code>"iiii"^^my:romanNumeral != "iv"^^my:romanNumeral</code></span>.</p>

    <h4>11.4.11 <a id="func-sameTerm" name="func-sameTerm" class="SPARQLoperator">sameTerm</a></h4>

  <pre class="prototype"> <code class="return">xsd:boolean</code>&nbsp;&nbsp;&nbsp;<code class="operator">sameTerm</code> (<code class="parm type"><span class="type RDFterm">RDF term</span></code> <code class="parm name">term1</code>, <code class="parm type"><span class="type RDFterm">RDF term</span></code> <code class="parm name">term2</code>)
</pre>

    <p>Returns TRUE if <code>term1</code> and <code>term2</code> are the same RDF term as defined in <a class="norm" href="http://www.w3.org/TR/rdf-concepts/">Resource Description Framework (RDF): Concepts and Abstract Syntax</a> [<a href="#CONCEPTS">CONCEPTS</a>]; returns FALSE otherwise.</p>

  <div class="exampleGroup">
  <pre class="data">@prefix foaf:       &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a  foaf:name       "Alice".
_:a  foaf:mbox       &lt;mailto:alice@work.example&gt; .

_:b  foaf:name       "Ms A.".
_:b  foaf:mbox       &lt;mailto:alice@work.example&gt; .
</pre>

  <div class="queryGroup">
  <p>This query finds the people who have multiple <code>foaf:name</code> triples:</p>
  <pre class="query">PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name1 ?name2
 WHERE { ?x foaf:name  ?name1 ;
            foaf:mbox  ?mbox1 .
         ?y foaf:name  ?name2 ;
            foaf:mbox  ?mbox2 .
         FILTER (sameTerm(?mbox1, ?mbox2) &amp;&amp; !sameTerm(?name1, ?name2))
       }
</pre>

  <p>Query result:</p>

  <div class="result">
      <table class="resultTable">
        <tbody>
          <tr>
            <th>name1</th>
            <th>name2</th>
          </tr>

          <tr>
            <td>"Alice"</td>
            <td>"Ms A."</td>
          </tr>

          <tr>
            <td>"Ms A."</td>
            <td>"Alice"</td>
          </tr>
        </tbody>
      </table>
  </div></div></div>

    <p>Unlike <code class="operatro">RDFterm-equal</code>, <code class="operatro">sameTerm</code> can be used to test for non-equivalent <span class="type typedLiteral">typed literals</span> with unsupported data types:</p>

  <div class="exampleGroup">
  <pre class="data">@prefix :          &lt;http://example.org/WMterms#&gt; .
@prefix t:         &lt;http://example.org/types#&gt; .

_:c1  :label        "Container 1" .
_:c1  :weight       "100"^^t:kilos .
_:c1  :displacement  "100"^^t:liters .

_:c2  :label        "Container 2" .
_:c2  :weight       "100"^^t:kilos .
_:c2  :displacement  "85"^^t:liters .

_:c3  :label        "Container 3" .
_:c3  :weight       "85"^^t:kilos .
_:c3  :displacement  "85"^^t:liters .</pre>

  <div class="queryGroup">
  <pre class="query">PREFIX  :      &lt;http://example.org/WMterms#&gt;
PREFIX  t:     &lt;http://example.org/types#&gt;

SELECT ?aLabel1 ?bLabel
WHERE { ?a  :label        ?aLabel .
        ?a  :weight       ?aWeight .
        ?a  :displacement ?aDisp .

        ?b  :label        ?bLabel .
        ?b  :weight       ?bWeight .
        ?b  :displacement ?bDisp .

        FILTER ( sameTerm(?aWeight, ?bWeight) &amp;&amp; !sameTerm(?aDisp, ?bDisp) }</pre>

  <div class="result">
      <table class="resultTable">
        <tbody>
          <tr>
            <th>aLabel</th>
            <th>bLabel</th>
          </tr>

          <tr>
            <td>"Container 1"</td>
            <td>"Container 2"</td>
          </tr>
          <tr>
            <td>"Container 2"</td>
            <td>"Container 1"</td>
          </tr>
        </tbody>
      </table>
  </div></div></div>

    <p>The test for boxes with the same weight may also be done with the '=' operator (<a href="#func-RDFterm-equal" class="SPARQLoperator">RDFterm-equal</a>) as the test for <code>"100"^^t:kilos = "85"^^t:kilos</code> will result in an error, eliminating that potential solution.</p>

   <h4>11.4.12 <a id="func-langMatches" name="func-langMatches" class="SPARQLoperator">langMatches</a></h4>

  <pre class="prototype"> <code class="return">xsd:boolean</code>&nbsp;&nbsp;&nbsp;<code class="operator">langMatches</code> (<code class="parm type"><span class="type simpleLiteral">simple literal</span></code> <code class="parm name">language-tag</code>, <code class="parm type"><span class="type simpleLiteral">simple literal</span></code> <code class="parm name">language-range</code>)
</pre>

    <p>Returns <code>true</code> if <code>language-tag</code> (first argument) matches <code>language-range</code> (second argument) per the basic filtering scheme defined in  [<a href="#rfc4647">RFC4647</a>] section 3.3.1. <code>language-range</code> is a basic language range  per <a class="norm" href="http://www.ietf.org/rfc/rfc4647.txt">Matching of Language Tags</a> [<a href="#rfc4647">RFC4647</a>] section 2.1. A <code>language-range</code> of "*" matches any non-empty <code>language-tag</code> string.</p>

  <div class="exampleGroup">
  <pre class="data">@prefix dc:       &lt;http://purl.org/dc/elements/1.1/&gt; .

_:a  dc:title         "That Seventies Show"@en .
_:a  dc:title         "Cette Série des Années Soixante-dix"@fr .
_:a  dc:title         "Cette Série des Années Septante"@fr-BE .
_:b  dc:title         "Il Buono, il Bruto, il Cattivo" .
</pre>

  <div class="queryGroup">
  <p>This query uses <code>langMatches</code> and <code>lang</code> (described in <a href="#func-lang">section 11.2.3.8</a>) to find the French titles for the show known in English as "That Seventies Show":</p>
  <pre class="query">PREFIX dc: &lt;http://purl.org/dc/elements/1.1/&gt;
SELECT ?title
 WHERE { ?x dc:title  "That Seventies Show"@en ;
            dc:title  ?title .
         FILTER langMatches( lang(?title), "FR" ) }</pre>

  <p>Query result:</p>

  <div class="result">
      <table class="resultTable">
        <tbody>
          <tr>
            <th>title</th>
          </tr>
          <tr> <td>"Cette Série des Années Soixante-dix"@fr</td> </tr>
          <tr> <td>"Cette Série des Années Septante"@fr-BE</td> </tr>
        </tbody>
      </table>
  </div></div>

  <div class="queryGroup">
  <p>The idiom <code>langMatches( lang( ?v ), "*" )</code> will not match literals without a language tag as <code>lang( ?v )</code> will return an empty string, so</p>

  <pre class="query add">PREFIX dc: &lt;http://purl.org/dc/elements/1.1/&gt;
SELECT ?title
 WHERE { ?x dc:title  ?title .
         FILTER langMatches( lang(?title), "*" ) }</pre>

  <p>will report all of the titles with a language tag:</p>

  <div class="result add">
      <table class="resultTable">
        <tbody>
          <tr>
            <th>title</th>
          </tr>
          <tr> <td>"That Seventies Show"@en</td> </tr>
          <tr> <td>"Cette Série des Années Soixante-dix"@fr</td> </tr>
          <tr> <td>"Cette Série des Années Septante"@fr-BE</td> </tr>
        </tbody>
      </table>
  </div></div></div>

    <h4>11.4.13 <a id="funcex-regex" name="funcex-regex" class="SPARQLoperator">regex</a></h4>

  <pre class="prototype"> <code class="return">xsd:boolean</code>&nbsp;&nbsp;&nbsp;<code class="operator">regex</code> (<code class="parm type"><span class="type simpleLiteral">simple literal</span></code> <code class="parm name">text</code>, <code class="parm type"><span class="type simpleLiteral">simple literal</span></code> <code class="parm name">pattern</code>)
 <code class="return">xsd:boolean</code>&nbsp;&nbsp;&nbsp;<code class="operator">regex</code> (<code class="parm type"><span class="type simpleLiteral">simple literal</span></code> <code class="parm name">text</code>, <code class="parm type"><span class="type simpleLiteral">simple literal</span></code> <code class="parm name">pattern</code>, <code class="parm type"><span class="type simpleLiteral">simple literal</span></code> <code class="parm name">flags</code>)
</pre>

    <p>Invokes the XPath <a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-matches">fn:matches</a> function to match <code>text</code> against a regular expression <code>pattern</code>. The regular expression language is defined in XQuery 1.0 and XPath 2.0 Functions and Operators section <a class="norm" href="http://www.w3.org/TR/xpath-functions/#regex-syntax">7.6.1 Regular Expression Syntax</a> [<a href="#FUNCOP">FUNCOP</a>].</p>


  <div class="exampleGroup">
  <pre class="data">@prefix foaf:       &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a  foaf:name       "Alice".
_:b  foaf:name       "Bob" .
</pre>

  <div class="queryGroup">
  <pre class="query">PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name
 WHERE { ?x foaf:name  ?name
         FILTER regex(?name, "^ali", "i") }
</pre>

  <p>Query result:</p>

  <div class="result">
      <table class="resultTable">
        <tbody>
          <tr>
            <th>name</th>
          </tr>

          <tr>
            <td>"Alice"</td>
          </tr>
        </tbody>
      </table>
  </div></div></div>

    <h3>11.5 <a id="FunctionMapping" name="FunctionMapping" class="FAndOTable">Constructor Functions</a></h3>
    <p>SPARQL imports a subset of the XPath constructor functions defined in <a class="norm" href="http://www.w3.org/TR/xpath-functions/">XQuery 1.0 and XPath 2.0 Functions and Operators</a> [<a href="#FUNCOP">FUNCOP</a>] in section <a class="norm" href="http://www.w3.org/TR/xpath-functions/#casting-from-primitive-to-primitive">17.1 Casting from primitive types to primitive types</a>. SPARQL constructors include all of the XPath constructors for the <a href="#operandDataTypes">SPARQL operand data types</a> plus the <a href="#operandDataTypes">additional datatypes</a>
 imposed by the RDF data model. Casting in SPARQL is performed by 
calling a constructor function for the target type on an operand of the 
source type.</p>

    <p>XPath defines only the casts from one XML Schema datatype to another. The remaining casts are defined as follows:</p>
    <ul>
      <li>Casting an <span class="IRI type">IRI</span> to an <code>xsd:string</code> produces a <span class="IRI typedLiteral">typed literal</span> with a lexical value of the codepoints comprising the IRI, and a datatype of <code>xsd:string</code>.</li>
      <li>Casting a <span class="simpleLiteral type">simple literal</span> to any XML Schema datatype is defined as the product of casting an <code>xsd:string</code> with the <a href="http://www.w3.org/TR/xpath20/#dt-string-value">string value</a> equal to the lexical value of the literal to the target datatype.</li>
    </ul>

    <p>The table below summarizes the casting operations that are always allowed (<span class="castY">Y</span>), never allowed (<span class="castN">N</span>) and dependent on the lexical value (<span class="castM">M</span>). For example, a casting operation from an <code>xsd:string</code> (the first row) to an <code>xsd:float</code> (the second column) is dependent on the lexical value (<span class="castM">M</span>).</p>

<blockquote>
<p>bool = <a class="norm" href="http://www.w3.org/TR/xmlschema-2/#boolean">xsd:boolean</a><br>
dbl = <a class="norm" href="http://www.w3.org/TR/xmlschema-2/#double">xsd:double</a><br>
flt = <a class="norm" href="http://www.w3.org/TR/xmlschema-2/#float">xsd:float</a><br>
dec = <a class="norm" href="http://www.w3.org/TR/xmlschema-2/#decimal">xsd:decimal</a><br>
int = <a class="norm" href="http://www.w3.org/TR/xmlschema-2/#integer">xsd:integer</a><br>
dT = <a class="norm" href="http://www.w3.org/TR/xmlschema-2/#dateTime">xsd:dateTime</a><br>
str = <a class="norm" href="http://www.w3.org/TR/xmlschema-2/#string">xsd:string</a><br>
<span class="rdfDM">IRI</span> = <span class="type IRI">IRI</span><br>
<span class="rdfDM">ltrl</span> = <code class="type simpleLiteral">simple literal</code></p>
</blockquote>

<table class="casting" summary="Casting table" border="1" cellpadding="1">
<col width="13%" span="1">
<col width="11%" span="1">
<col width="11%" span="1">
<col width="11%" span="1">
<col width="11%" span="1">
<col width="11%" span="1">
<col width="11%" span="1">
<col width="11%" span="1">
<!-- col width="3%" span="1" / -->
<!-- col width="3%" span="1" / -->
<!-- col width="3%" span="1" / -->
<thead>
<tr>
<th><span class="cancast" title="From\To">From \ To</span></th>
<th><span class="cancast" title="string">str</span></th>
<th><span class="cancast" title="float">flt</span></th>
<th><span class="cancast" title="double">dbl</span></th>
<th><span class="cancast" title="decimal">dec</span></th>
<th><span class="cancast" title="integer">int</span></th>
<th><span class="cancast" title="dateTime">dT</span></th>
<th><span class="cancast" title="boolean">bool</span></th>
<!-- th><span class="cancast rdfDM" title="IRI">IRI</span></th -->
<!-- th><span class="cancast rdfDM" title="Literal">ltrl</span></th -->
<!-- th><span class="cancast rdfDM" title="bNode">BN</span></th -->
</tr>
</thead>
<tbody>
<tr>
<th><span class="cancast" title="string">str</span></th>
<td class="castY" valign="middle" align="center"><span class="cancast" title="Cast string to string? Yes">Y</span></td>
<td class="castM" valign="middle" align="center"><span class="cancast" title="Cast string to float? Maybe">M</span></td>
<td class="castM" valign="middle" align="center"><span class="cancast" title="Cast string to double? Maybe">M</span></td>
<td class="castM" valign="middle" align="center"><span class="cancast" title="Cast string to decimal? Maybe">M</span></td>
<td class="castM" valign="middle" align="center"><span class="cancast" title="Cast string to integer? Maybe">M</span></td>
<td class="castM" valign="middle" align="center"><span class="cancast" title="Cast string to dateTime? Maybe">M</span></td>
<td class="castM" valign="middle" align="center"><span class="cancast" title="Cast string to boolean? Maybe">M</span></td>
<!-- td class="castY" align="center" valign="middle"><span class="cancast rdfDM" title="Cast string to IRI? Yes">Y</span></td -->
<!-- td class="castY" align="center" valign="middle"><span class="cancast rdfDM" title="Cast string to Literal? Yes">Y</span></td -->
<!-- td class="castN" align="center" valign="middle"><span class="cancast rdfDM" title="Cast string to bNode? No">N</span></td -->
</tr>
<tr>
<th><span class="cancast" title="float">flt</span></th>
<td class="castY" valign="middle" align="center"><span class="cancast" title="Cast float to string? Yes">Y</span></td>
<td class="castY" valign="middle" align="center"><span class="cancast" title="Cast float to float? Yes">Y</span></td>
<td class="castY" valign="middle" align="center"><span class="cancast" title="Cast float to double? Yes">Y</span></td>
<td class="castM" valign="middle" align="center"><span class="cancast" title="Cast float to decimal? Maybe">M</span></td>
<td class="castM" valign="middle" align="center"><span class="cancast" title="Cast float to integer? Maybe">M</span></td>
<td class="castN" valign="middle" align="center"><span class="cancast" title="Cast float to dateTime? No">N</span></td>
<td class="castY" valign="middle" align="center"><span class="cancast" title="Cast float to boolean? Yes">Y</span></td>
<!-- td class="castN" align="center" valign="middle"><span class="cancast rdfDM" title="Cast float to IRI? No">N</span></td -->
<!-- td class="castN" align="center" valign="middle"><span class="cancast rdfDM" title="Cast float to Literal? No">N</span></td -->
<!-- td class="castN" align="center" valign="middle"><span class="cancast rdfDM" title="Cast float to bNode? No">N</span></td -->
</tr>
<tr>
<th><span class="cancast" title="double">dbl</span></th>
<td class="castY" valign="middle" align="center"><span class="cancast" title="Cast double to string? Yes">Y</span></td>
<td class="castY" valign="middle" align="center"><span class="cancast" title="Cast double to float? Yes">Y</span></td>
<td class="castY" valign="middle" align="center"><span class="cancast" title="Cast double to double? Yes">Y</span></td>
<td class="castM" valign="middle" align="center"><span class="cancast" title="Cast double to decimal? Maybe">M</span></td>
<td class="castM" valign="middle" align="center"><span class="cancast" title="Cast double to integer? Maybe">M</span></td>
<td class="castN" valign="middle" align="center"><span class="cancast" title="Cast double to dateTime? No">N</span></td>
<td class="castY" valign="middle" align="center"><span class="cancast" title="Cast double to boolean? Yes">Y</span></td>
<!-- td class="castN" align="center" valign="middle"><span class="cancast rdfDM" title="Cast double to IRI? No">N</span></td -->
<!-- td class="castN" align="center" valign="middle"><span class="cancast rdfDM" title="Cast double to Literal? No">N</span></td -->
<!-- td class="castN" align="center" valign="middle"><span class="cancast rdfDM" title="Cast double to bNode? No">N</span></td -->
</tr>
<tr>
<th><span class="cancast" title="decimal">dec</span></th>
<td class="castY" valign="middle" align="center"><span class="cancast" title="Cast decimal to string? Yes">Y</span></td>
<td class="castY" valign="middle" align="center"><span class="cancast" title="Cast decimal to float? Yes">Y</span></td>
<td class="castY" valign="middle" align="center"><span class="cancast" title="Cast decimal to double? Yes">Y</span></td>
<td class="castY" valign="middle" align="center"><span class="cancast" title="Cast decimal to decimal? Yes">Y</span></td>
<td class="castY" valign="middle" align="center"><span class="cancast" title="Cast decimal to integer? Yes">Y</span></td>
<td class="castN" valign="middle" align="center"><span class="cancast" title="Cast decimal to dateTime? No">N</span></td>
<td class="castY" valign="middle" align="center"><span class="cancast" title="Cast decimal to boolean? Yes">Y</span></td>
<!-- td class="castN" align="center" valign="middle"><span class="cancast rdfDM" title="Cast decimal to IRI? No">N</span></td -->
<!-- td class="castN" align="center" valign="middle"><span class="cancast rdfDM" title="Cast decimal to Literal? No">N</span></td -->
<!-- td class="castN" align="center" valign="middle"><span class="cancast rdfDM" title="Cast decimal to bNode? No">N</span></td -->
</tr>
<tr>
<th><span class="cancast" title="integer">int</span></th>
<td class="castY" valign="middle" align="center"><span class="cancast" title="Cast integer to string? Yes">Y</span></td>
<td class="castY" valign="middle" align="center"><span class="cancast" title="Cast integer to float? Yes">Y</span></td>
<td class="castY" valign="middle" align="center"><span class="cancast" title="Cast integer to double? Yes">Y</span></td>
<td class="castY" valign="middle" align="center"><span class="cancast" title="Cast integer to decimal? Yes">Y</span></td>
<td class="castY" valign="middle" align="center"><span class="cancast" title="Cast integer to integer? Yes">Y</span></td>
<td class="castN" valign="middle" align="center"><span class="cancast" title="Cast integer to dateTime? No">N</span></td>
<td class="castY" valign="middle" align="center"><span class="cancast" title="Cast integer to boolean? Yes">Y</span></td>
<!-- td class="castN" align="center" valign="middle"><span class="cancast rdfDM" title="Cast integer to IRI? No">N</span></td -->
<!-- td class="castN" align="center" valign="middle"><span class="cancast rdfDM" title="Cast integer to Literal? No">N</span></td -->
<!-- td class="castN" align="center" valign="middle"><span class="cancast rdfDM" title="Cast integer to bNode? No">N</span></td -->
</tr>
<tr>
<th><span class="cancast" title="dateTime">dT</span></th>
<td class="castY" valign="middle" align="center"><span class="cancast" title="Cast dateTime to string? Yes">Y</span></td>
<td class="castN" valign="middle" align="center"><span class="cancast" title="Cast dateTime to float? No">N</span></td>
<td class="castN" valign="middle" align="center"><span class="cancast" title="Cast dateTime to double? No">N</span></td>
<td class="castN" valign="middle" align="center"><span class="cancast" title="Cast dateTime to decimal? No">N</span></td>
<td class="castN" valign="middle" align="center"><span class="cancast" title="Cast dateTime to integer? No">N</span></td>
<td class="castY" valign="middle" align="center"><span class="cancast" title="Cast dateTime to dateTime? Yes">Y</span></td>
<td class="castN" valign="middle" align="center"><span class="cancast" title="Cast dateTime to boolean? No">N</span></td>
<!-- td class="castN" align="center" valign="middle"><span class="cancast rdfDM" title="Cast dateTime to IRI? No">N</span></td -->
<!-- td class="castN" align="center" valign="middle"><span class="cancast rdfDM" title="Cast dateTime to Literal? No">N</span></td -->
<!-- td class="castN" align="center" valign="middle"><span class="cancast rdfDM" title="Cast dateTime to bNode? No">N</span></td -->
</tr>
<tr>
<th><span class="cancast" title="boolean">bool</span></th>
<td class="castY" valign="middle" align="center"><span class="cancast" title="Cast boolean to string? Yes">Y</span></td>
<td class="castY" valign="middle" align="center"><span class="cancast" title="Cast boolean to float? Yes">Y</span></td>
<td class="castY" valign="middle" align="center"><span class="cancast" title="Cast boolean to double? Yes">Y</span></td>
<td class="castY" valign="middle" align="center"><span class="cancast" title="Cast boolean to decimal? Yes">Y</span></td>
<td class="castY" valign="middle" align="center"><span class="cancast" title="Cast boolean to integer? Yes">Y</span></td>
<td class="castN" valign="middle" align="center"><span class="cancast" title="Cast boolean to dateTime? No">N</span></td>
<td class="castY" valign="middle" align="center"><span class="cancast" title="Cast boolean to boolean? Yes">Y</span></td>
<!-- td class="castN" align="center" valign="middle"><span class="cancast rdfDM" title="Cast boolean to IRI? No">N</span></td -->
<!-- td class="castN" align="center" valign="middle"><span class="cancast rdfDM" title="Cast boolean to Literal? No">N</span></td -->
<!-- td class="castN" align="center" valign="middle"><span class="cancast rdfDM" title="Cast boolean to bNode? No">N</span></td -->
</tr>
<tr>
<th><span class="cancast rdfDM" title="IRI">IRI</span></th>
<td class="castY" valign="middle" align="center"><span class="cancast rdfDM" title="Cast IRI to string? Yes">Y</span></td>
<td class="castN" valign="middle" align="center"><span class="cancast rdfDM" title="Cast IRI to float? No">N</span></td>
<td class="castN" valign="middle" align="center"><span class="cancast rdfDM" title="Cast IRI to double? No">N</span></td>
<td class="castN" valign="middle" align="center"><span class="cancast rdfDM" title="Cast IRI to decimal? No">N</span></td>
<td class="castN" valign="middle" align="center"><span class="cancast rdfDM" title="Cast IRI to integer? No">N</span></td>
<td class="castN" valign="middle" align="center"><span class="cancast rdfDM" title="Cast IRI to dateTime? No">N</span></td>
<td class="castN" valign="middle" align="center"><span class="cancast rdfDM" title="Cast IRI to boolean? No">N</span></td>
<!-- td class="castY" align="center" valign="middle"><span class="cancast rdfDM" title="Cast IRI to IRI? Yes">Y</span></td -->
<!-- td class="castY" align="center" valign="middle"><span class="cancast rdfDM" title="Cast IRI to Literal? Yes">Y</span></td -->
<!-- td class="castN" align="center" valign="middle"><span class="cancast rdfDM" title="Cast IRI to bNode? No">N</span></td -->
</tr>
<tr>
<th><span class="cancast rdfDM" title="Literal">ltrl</span></th>
<td class="castY" valign="middle" align="center"><span class="cancast rdfDM" title="Cast Literal to string? Yes">Y</span></td>
<td class="castM" valign="middle" align="center"><span class="cancast rdfDM" title="Cast Literal to float? No">M</span></td>
<td class="castM" valign="middle" align="center"><span class="cancast rdfDM" title="Cast Literal to double? No">M</span></td>
<td class="castM" valign="middle" align="center"><span class="cancast rdfDM" title="Cast Literal to decimal? No">M</span></td>
<td class="castM" valign="middle" align="center"><span class="cancast rdfDM" title="Cast Literal to integer? No">M</span></td>
<td class="castM" valign="middle" align="center"><span class="cancast rdfDM" title="Cast Literal to dateTime? No">M</span></td>
<td class="castM" valign="middle" align="center"><span class="cancast rdfDM" title="Cast Literal to boolean? No">M</span></td>
<!-- td class="castY" align="center" valign="middle"><span class="cancast rdfDM" title="Cast Literal to IRI? Yes">Y</span></td -->
<!-- td class="castY" align="center" valign="middle"><span class="cancast rdfDM" title="Cast Literal to Literal? Yes">Y</span></td -->
<!-- td class="castN" align="center" valign="middle"><span class="cancast rdfDM" title="Cast Literal to bNode? No">N</span></td -->
</tr>
<!-- tr>
<th><span class="cancast rdfDM" title="bNode">BN</span></th>
<td class="castY" align="center" valign="middle"><span class="cancast rdfDM" title="Cast bNode to string? Yes">Y</span></td>
<td class="castN" align="center" valign="middle"><span class="cancast rdfDM" title="Cast bNode to float? No">N</span></td>
<td class="castN" align="center" valign="middle"><span class="cancast rdfDM" title="Cast bNode to double? No">N</span></td>
<td class="castN" align="center" valign="middle"><span class="cancast rdfDM" title="Cast bNode to decimal? No">N</span></td>
<td class="castN" align="center" valign="middle"><span class="cancast rdfDM" title="Cast bNode to integer? No">N</span></td>
<td class="castN" align="center" valign="middle"><span class="cancast rdfDM" title="Cast bNode to dateTime? No">N</span></td>
<td class="castN" align="center" valign="middle"><span class="cancast rdfDM" title="Cast bNode to boolean? No">N</span></td>
<td class="castN" align="center" valign="middle"><span class="cancast rdfDM" title="Cast bNode to IRI? No">N</span></td>
<td class="castN" align="center" valign="middle"><span class="cancast rdfDM" title="Cast bNode to Literal? No">N</span></td>
<td class="castY" align="center" valign="middle"><span class="cancast rdfDM" title="Cast bNode to bNode? Yes">Y</span></td>
</tr -->
</tbody>
</table>

  <h3>11.6 <a id="extensionFunctions" name="extensionFunctions">Extensible Value Testing</a></h3>

    <p>A <a href="#rPrimaryExpression">PrimaryExpression</a> grammar 
rule can be a call to an extension function named by an IRI. An 
extension function takes some number of RDF terms as arguments and 
returns an RDF term. The semantics of these functions are identified by 
the IRI that identifies the function.</p>

    <p>SPARQL queries using extension functions are likely to have limited interoperability.</p>

  <p>As an example, consider a function called <code class="function">func:even</code>:</p>

  <pre class="prototype"> <code class="return">xsd:boolean</code>&nbsp;&nbsp;&nbsp;<code class="function">func:even</code> (<code class="parm type"><span class="type numeric">numeric</span></code> <code class="parm name">value</code>)
</pre>

  <div class="exampleGroup">
  <div class="queryGroup">
  <p>This function would be invoked in a FILTER as such:</p>

  <pre class="query">PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX func: &lt;http://example.org/functions#&gt;
SELECT ?name ?id
WHERE { ?x foaf:name  ?name ;
           func:empId   ?id .
        FILTER (func:even(?id)) }</pre></div></div>

    <p>For a second example, consider a function <code>aGeo:distance</code> that calculates the distance between two points, which is used here to find the places near Grenoble:</p>

  <pre class="prototype"> <code class="return">xsd:double</code>&nbsp;&nbsp;&nbsp;<code class="function">aGeo:distance</code> (<code class="parm type"><span class="type numeric">numeric</span></code> <code class="parm name">x1</code>, <code class="parm type"><span class="type numeric">numeric</span></code> <code class="parm name">y1</code>, <code class="parm type"><span class="type numeric">numeric</span></code> <code class="parm name">x2</code>, <code class="parm type"><span class="type numeric">numeric</span></code> <code class="parm name">y2</code>)
</pre>

  <div class="exampleGroup">
  <div class="queryGroup">
  <pre class="query">PREFIX aGeo: &lt;http://example.org/geo#&gt;

SELECT ?neighbor
WHERE { ?a aGeo:placeName "Grenoble" .
        ?a aGeo:location ?axLoc .
        ?a aGeo:location ?ayLoc .

        ?b aGeo:placeName ?neighbor .
        ?b aGeo:location ?bxLoc .
        ?b aGeo:location ?byLoc .

        FILTER ( aGeo:distance(?axLoc, ?ayLoc, ?bxLoc, ?byLoc) &lt; 10 ) .
      }
</pre></div></div>

  <p>An extension function might be used to test some
  application datatype not supported by the core SPARQL specification, it might
  be a transformation between datatype formats, for example into an XSD dateTime
  RDF term from another date format. </p>

  <h2>12 <a name="sparqlDefinition" id="sparqlDefinition">Definition of SPARQL</a></h2>

<p>This section defines the correct behavior for evaluation of graph patterns 
and solution modifiers, given a query string and an RDF 
dataset. It does not imply a SPARQL implementation must use the process defined 
here. </p>

  <p>The outcome of executing a SPARQL is defined by a series of steps, 
starting 
  from the SPARQL query as a string, turning that string into an 
abstract syntax 
  form, then turning the abstract syntax into a SPARQL abstract query 
comprising operators from the SPARQL algebra. This abstract query 
  is then evaluated on an RDF 
  dataset.</p>
<h3>12.1 <a id="initDefinitions" name="initDefinitions">Initial Definitions</a></h3>


  <h4>12.1.1 <a id="sparqlBasicTerms" name="sparqlBasicTerms">RDF Terms</a></h4>

  <p>SPARQL is defined in terms of IRIs [<a href="#rfc3987">RFC3987</a>]. IRIs are a subset of RDF URI References that omits spaces.</p>

  <div class="defn">
    <b>Definition:</b> <a id="defn_RDFTerm" name="defn_RDFTerm">RDF Term</a>

    <p>Let I be the set of all IRIs.<br>
    Let RDF-L be the set of all <a class="norm" href="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/#dfn-literal">RDF Literals</a><br>
    Let RDF-B be the set of all <a class="norm" href="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/#dfn-blank-node">blank nodes</a> in RDF graphs</p>

    <p>The set of <span class="definedTerm">RDF Terms</span>, RDF-T, is I union RDF-L union RDF-B.</p>
  </div>

  <p>This definition of <span class="definedTerm">RDF Term</span> collects together several basic notions from the
  <a class="norm" href="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/#section-data-model">RDF data model</a>,
  but <a href="http://www.w3.org/TR/rdf-concepts/#section-Graph-URIref">updated</a> to refer to IRIs rather than RDF
  URI references.</p>

  <h4>12.1.2 <a id="sparqlDataset" name="sparqlDataset">RDF Dataset</a></h4>
<div class="defn">
  <b>Definition:</b> <a id="defn_RDFDataset" name="defn_RDFDataset">RDF Dataset</a><p>
  An RDF dataset is a set:<br>
  { G, (&lt;u<sub>1</sub>&gt;, G<sub>1</sub>), (&lt;u<sub>2</sub>&gt;, G<sub>2</sub>), . . .
  (&lt;u<sub>n</sub>&gt;, G<sub>n</sub>) }<br>
  where G and each G<sub>i</sub> are graphs, and each &lt;u<sub>i</sub>&gt; is
  an IRI.
  Each &lt;u<sub>i</sub>&gt; is distinct.</p>
  <p>G is called the default graph. (&lt;u<sub>i</sub>&gt;, G<sub>i</sub>) are called
  named graphs.</p>
</div>

  <div class="defn">
    <b>Definition:</b> <a id="defn_ActiveGraph" name="defn_ActiveGraph">Active Graph</a>
    <p>The <b>active graph</b> is the graph from the dataset used for basic 
    graph pattern matching.</p>
  </div>

  <h4>12.1.3 <a id="sparqlQueryVariables" name="sparqlQueryVariables">Query Variables</a></h4>

  <div class="defn">
    <b>Definition:</b> <a id="defn_QueryVariable" name="defn_QueryVariable">Query Variable</a>

    <p>A <span class="definedTerm">query variable</span> is a member of the set V where V is infinite and disjoint from
    RDF-T.</p>
  </div>

  <h4>12.1.4 <a id="sparqlTriplePatterns" name="sparqlTriplePatterns">Triple Patterns</a></h4>

  <div class="defn">
    <b>Definition:</b> <a id="defn_TriplePattern" name="defn_TriplePattern">Triple Pattern</a>

    <p>A <span class="definedTerm">triple pattern</span> is member of the set:<br>
    (RDF-T union V) x (I union V) x (RDF-T union V)</p>
  </div>

  <p>This definition of Triple Pattern includes literal subjects. <a href="http://www.w3.org/2000/03/rdf-tracking/#rdfms-literalsubjects">This has been noted by RDF-core</a>.</p>
  <pre id="body">"[The RDF core Working Group] noted that it is aware of no reason why literals should not
  be subjects and a future WG with a less restrictive charter may
  extend the syntaxes to allow literals as the subjects of statements."
</pre>

  <p>Because RDF graphs may not contain literal subjects, any SPARQL triple pattern with a literal as subject will fail
  to match on any RDF graph.</p>
  
  <h4>12.1.5 <a id="sparqlBasicGraphPatterns" name="sparqlBasicGraphPatterns">Basic Graph Patterns</a></h4>

  
<div class="defn">
    <b>Definition:</b> <a id="defn_BasicGraphPattern" name="defn_BasicGraphPattern">Basic Graph Pattern</a>

    <p>A <span class="definedTerm">Basic Graph Pattern</span> is a
    set of <a href="#defn_TriplePattern">Triple Patterns</a>.</p>
  </div>

  <p>The empty graph pattern is a basic graph pattern which is the empty set.</p>
<h4>12.1.6 <a name="sparqlSolutions" id="sparqlSolutions">Solution Mapping</a></h4>

  <p>A solution mapping is a mapping from a set of variables to a set of RDF terms. 
  We use the term 'solution' where it is clear.</p>

  <div class="defn">
    <b>Definition: <a id="defn_sparqlSolutionMapping" name="defn_sparqlSolutionMapping">Solution 
    Mapping</a></b><p>A <b>solution mapping</b>, μ, is a partial function μ : V -&gt; T.</p>

    <p>The domain of μ, dom(μ), is the subset of V where μ is defined.</p>
  </div>
  <div class="defn">
    <b>Definition: 
    <a id="defn_sparqlSolutionSequence" name="defn_sparqlSolutionSequence">Solution Sequence</a></b>
    
    <p>A <b>solution sequence</b> is a list of solutions, possibly unordered.</p>
  </div>

<h4>12.1.7 <a name="sparqlSolMod" id="sparqlSolMod">Solution Sequence Modifiers</a></h4>

<div class="defn">
    <b>Definition:</b> 
    <a id="defn_SolutionModifier" name="defn_SolutionModifier">Solution Sequence Modifier</a>

    <p>A <span class="definedTerm">solution sequence modifier</span> is one of:</p>
    <ul>
      <li>
      <a href="#defn_algOrdered">
      Order By</a> modifier: put the solutions in order</li>
      <li>
      <a href="#defn_algProjection">
      Projection</a> modifier: choose certain variables</li>
      <li>
      <a href="#defn_algDistinct">
      Distinct</a> modifier: ensure solutions in the sequence are unique</li>
      <li>
      <a href="#defn_algReduced">
      Reduced</a> modifier: permit any non-unique solutions to be eliminated</li>
      <li>
      <a href="#defn_algSlice">
      Offset</a> modifier: control where the solutions start from in 
      the overall sequence of solutions</li>
      <li>
      <a href="#defn_algSlice">
      Limit</a> modifier: restrict the number of solutions</li>
    </ul>
  </div>
<h3>12.2 <a id="sparqlQuery" name="sparqlQuery">SPARQL Query</a></h3>
<p>This section defines the process of converting graph patterns and solution 
modifiers in a SPARQL query string into a SPARQL algebra expression.</p>
<p>After parsing a SPARQL query string, and applying the abbreviations for IRIs 
and triple patterns given in 
  <a href="#sparqlSyntax">section 4</a>, there is an abstract syntax tree 
composed of:</p>

<table class="plain">
  <tbody>
  <tr>
    <th>Patterns</th>
    <th>Modifiers</th>
    <th>Query Forms</th>
  </tr>
  <tr>
    <td>RDF terms</td>
    <td>DISTINCT</td>
    <td>SELECT</td>
  </tr>
  <tr>
    <td>triple patterns</td>
    <td>REDUCED</td>
    <td>CONSTRUCT</td>
  </tr>
  <tr>
    <td>Basic graph patterns</td>
    <td>PROJECT</td>
    <td>DESCRIBE</td>
  </tr>
  <tr>
    <td>Groups</td>
    <td>ORDER BY</td>
    <td>ASK</td>
  </tr>
  <tr>
    <td>OPTIONAL</td>
    <td>LIMIT</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>UNION</td>
    <td>OFFSET</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>GRAPH</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>FILTER</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  </tbody>
</table>
<p>The result of converting such an abstract syntax tree is a SPARQL query that 
uses the following symbols in the SPARQL algebra:</p>

<table class="plain">
  <tbody>
  <tr>
    <th>Graph Pattern</th>
    <th>Solution Modifiers</th>
  </tr>
  <tr>
    <td>BGP </td>
    <td>ToList</td>
  </tr>
  <tr>
    <td>Join</td>
    <td>OrderBy</td>
  </tr>
  <tr>
    <td>LeftJoin</td>
    <td>Project</td>
  </tr>
  <tr>
    <td>Filter</td>
    <td>Distinct</td>
  </tr>
  <tr>
    <td>Union</td>
    <td>Reduced</td>
  </tr>
  <tr>
    <td>Graph</td>
    <td>Slice</td>
  </tr>
  </tbody>
</table>

  <p><i>Slice</i> is the combination of OFFSET and LIMIT. <i>mod</i> is any one of the 
  solution modifiers.</p>
<p><i>ToList</i> is used where conversion from the results of graph pattern 
matching to sequences occurs.</p>

	<div class="defn">
    <b>Definition:</b> <a id="defn_SPARQLQuery" name="defn_SPARQLQuery">
    SPARQL Query</a>

    <p>A <span class="definedTerm">SPARQL Abstract Query</span> is a tuple (E, DS, R) where:</p>

    <ul>
      <li>E is a <a href="#sparqlAlgebra">SPARQL algebra</a> expression</li>
      <li>DS is an <a href="#defn_RDFDataset">RDF Dataset</a></li>
      <li>R is a <a href="#QueryForms"><span style="background-position: 0% 0%;">
      q</span>uery form</a></li>
    </ul>
	</div>
    <h4>12.2.1 <a id="convertGraphPattern" name="convertGraphPattern">Converting Graph Patterns</a></h4>
<p>This section describes the process for translating a SPARQL graph 
    patterns into a SPARQL algebra expression. After translating syntactic 
abbreviations for IRIs and triple patterns, it recursively processes syntactic 
forms into algebra expressions:</p>
<div class="wgNote">
    
The working group notes that the point at the simplification step is applied leads to ambiguous transformation 
of queries involving a doubly nested filter and pattern in an optional:<pre><code>OPTIONAL { { ... FILTER ( ... ?x ... ) } }.</code>.</pre>
<p>This is illustrated by two non-normative test cases:</p>
<ul>
<li><a href="http://www.w3.org/2001/sw/DataAccess/tests/data-r2/optional-filter/manifest#dawg-optional-filter-005-not-simplified">
Simplification applied after all transformations</a> or not at all.</li>

<li><a href="http://www.w3.org/2001/sw/DataAccess/tests/data-r2/optional-filter/manifest#dawg-optional-filter-005-simplified">
Simplification applied during transformation</a>.</li>
</ul>


</div>

<p>First, expand abbreviations for IRIs and triple patterns given in 
  <a href="#sparqlSyntax">section 4</a>.</p>
  
<p>The <code class="gRuleBody"><a href="#rWhereClause">WhereClause</a></code> consists of a
<code class="gRuleBody"><a href="#rGroupGraphPattern">GroupGraphPattern</a></code> which is comprised of the following forms:</p>
<ul>
  <li><code class="gRuleBody"><a href="#rTriplesBlock">TriplesBlock</a></code></li>
  <li><code class="gRuleBody"><a href="#rFilter">Filter</a></code></li>
  <li><code class="gRuleBody"><a href="#rOptionalGraphPattern">OptionalGraphPattern</a></code></li>
  <li><code class="gRuleBody"><a href="#rGroupOrUnionGraphPattern">GroupOrUnionGraphPattern</a></code></li>
  <li><code class="gRuleBody"><a href="#rGraphGraphPattern">GraphGraphPattern</a></code></li>
</ul>
<p>Each is translated by the following procedure:</p>

<p><b>Transform(syntax form)</b></p>
<blockquote>
  <p>If the form is <code class="gRuleBody"><a href="#rTriplesBlock">TriplesBlock</a></code></p>
</blockquote>
<pre class="codeBlock">The result is BGP(list of triple patterns)</pre>

  <blockquote>
    <p>If the form is <code class="gRuleBody">
    <a href="#rGroupOrUnionGraphPattern">GroupOrUnionGraphPattern</a></code></p>
</blockquote>

  <pre class="codeBlock">Let A := undefined

For each element G in the GroupOrUnionGraphPattern
    If A is undefined
        A := Transform(G)
    Else
        A := Union(A, Transform(G))

The result is A
</pre>


   <blockquote>
     <p>If the form is <code class="gRuleBody"><a href="#rGraphGraphPattern">GraphGraphPattern</a></code></p>
</blockquote>

  <pre class="codeBlock">If the form is GRAPH IRI GroupGraphPattern
    The result is Graph(IRI, Transform(GroupGraphPattern))
If the form is GRAPH Var GroupGraphPattern
    The result is Graph(Var, Transform(GroupGraphPattern))</pre>

  <blockquote>
    <p>If the form is <code class="gRuleBody"><a href="#rGroupGraphPattern">GroupGraphPattern</a></code></p>
    <blockquote>
      <p>We introduce the following symbols:</p>
      <ul>
        <li>Join(Pattern, Pattern)</li>
        <li>LeftJoin(Pattern, Pattern, expression)</li>
        <li>Filter(expression, Pattern)</li>
      </ul>
    </blockquote>
</blockquote>

  <pre class="codeBlock">Let FS := the empty set
Let G := the empty pattern, Z, a basic graph pattern which is the empty set.

For each element E in the GroupGraphPattern
   If E is of the form FILTER(expr)
       FS := FS set-union {expr}
   If E is of the form OPTIONAL{P}
   Then
       Let A := Transform(P)
       If A is of the form Filter(F, A2)
           G := LeftJoin(G, A2, F)
       else 
           G := LeftJoin(G, A, true)
   If E is any other form:
      Let A := Transform(E)
      G := Join(G, A)
   
  
If FS is not empty:
  Let X := Conjunction of expressions in FS
  G := Filter(X, G)

The result is G.
</pre>
<p>Simplification step:</p>
<p>Groups of one graph pattern (not a filter) become join(Z, A) and can be 
replaced by A. The empty graph pattern Z is the identity for join:</p>
  <pre class="codeBlock">Replace join(Z, A) by A
Replace join(A, Z) by A
</pre>

  <h4>12.2.2 <a id="sparqlAbsExamples" name="sparqlAbsExamples">Examples of Mapped Graph Patterns</a></h4>

  <p>The second form of a rewrite example is the first with empty group joins removed by 
  the simplification step.</p>
<p>Example: group with a basic graph pattern consisting of a single triple 
pattern:</p>

  <div class="algExample">
    <div class="algExample1">
      { ?s ?p ?o }
    </div>

    <div class="algExample2">
      Join(Z,
      BGP(?s ?p ?o) )</div>
    <div class="algExample2">
      BGP(?s ?p ?o)</div>
  </div>

<p>Example: group with a basic graph pattern consisting of two triple patterns:</p>

  <div class="algExample">
    <div class="algExample1">
      { ?s :p1 ?v1 ; :p2 ?v2 }
    </div>

    <div class="algExample2">
      BGP( ?s :p1 ?v1 .?s :p2 ?v2 )
    </div>
  </div>

<p>Example: group consisting of a union of two basic graph patterns:</p>

  <div class="algExample">
    <div class="algExample1">
      { { ?s :p1 ?v1 } UNION {?s :p2 ?v2 } }
    </div>

    <div class="algExample2">
      Union(Join(Z, BGP(?s :p1 ?v1)),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Join(Z, BGP(?s :p2 ?v2)) )
    </div>

    <div class="algExample2">
      Union( BGP(?s :p1 ?v1) , BGP(?s :p2 ?v2) )
    </div>
  </div>

<p>Example: group consisting a union of a union and a basic graph pattern:</p>

  <div class="algExample">
    <div class="algExample1">
      { { ?s :p1 ?v1 } UNION {?s :p2 ?v2 } UNION {?s :p3 ?v3 } }
    </div>

    <div class="algExample2">
      Union(<br>
&nbsp;&nbsp;&nbsp; Union( Join(Z, BGP(?s :p1 ?v1)),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Join(Z, BGP(?s :p2 ?v2))) 
      ,<br>
&nbsp;&nbsp;&nbsp; Join(Z, BGP(?s :p3 ?v3)) )</div>

    <div class="algExample2">
      Union( <br>
&nbsp;&nbsp;&nbsp; Union( BGP(?s :p1 ?v1) ,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BGP(?s :p2 ?v2),<br>
&nbsp;&nbsp;&nbsp; BGP(?s :p3 ?v3))</div>
  </div>

<p>Example: group consisting of a basic graph pattern and an optional graph 
pattern:</p>

  <div class="algExample">
    <div class="algExample1">
      { ?s :p1 ?v1 OPTIONAL {?s :p2 ?v2 } }
    </div>

    <div class="algExample2">
      LeftJoin(<br>
&nbsp;&nbsp;&nbsp; Join(Z, BGP(?s :p1 ?v1)),<br>
&nbsp;&nbsp;&nbsp; Join(Z, BGP(?s :p2 ?v2)) ),<br>
&nbsp;&nbsp;&nbsp; true)
    </div>

    <div class="algExample2">
      LeftJoin(BGP(?s :p1 ?v1), BGP(?s :p2 ?v2), true)
    </div>
  </div>

<p>Example: group consisting of a basic graph pattern and two optional graph 
patterns:</p>

  <div class="algExample">
    <div class="algExample1">
      { ?s :p1 ?v1 OPTIONAL {?s :p2 ?v2 } OPTIONAL { ?s :p3 ?v3 } }
    </div>

    <div class="algExample2">
      LeftJoin(<br>
           &nbsp;&nbsp;&nbsp; LeftJoin(<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BGP(?s :p1 ?v1),<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BGP(?s :p2 ?v2),<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              true) ,<br>
           &nbsp;&nbsp;&nbsp; BGP(?s :p3 ?v3),<br>
           &nbsp;&nbsp;&nbsp; true)
    </div>
  </div>

<p>Example: group consisting of a basic graph pattern and an optional graph 
pattern with a filter:</p>

  <div class="algExample">
    <div class="algExample1">
      { ?s :p1 ?v1 OPTIONAL {?s :p2 ?v2 FILTER(?v1&lt;3) } }
    </div>

    <div class="algExample2">
      LeftJoin(<br>
&nbsp;&nbsp;&nbsp;&nbsp; Join(Z, BGP(?s :p1 ?v1)),<br>
&nbsp;&nbsp;&nbsp;&nbsp; Join(Z, BGP(?s :p2 ?v2)),<br>
&nbsp;&nbsp;&nbsp;&nbsp; (?v1&lt;3) )
    </div>

    <div class="algExample2">
      LeftJoin(<br>
&nbsp;&nbsp;&nbsp; BGP(?s :p1 ?v1) ,<br>
&nbsp;&nbsp;&nbsp; BGP(?s :p2 ?v2) ,<br>
&nbsp;&nbsp; (?v1&lt;3) )
    </div>
  </div>

<p>Example: group consisting of a union graph pattern and an optional graph 
pattern:</p>

  <div class="algExample">
    <div class="algExample1">
      { {?s :p1 ?v1} UNION {?s :p2 ?v2} OPTIONAL {?s :p3 ?v3} }
    </div>

    <div class="algExample2">
      LeftJoin(<br>
        &nbsp;
        Union(BGP(?s :p1 ?v1),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BGP(?s :p2 ?v2)) ,<br>
        &nbsp;
        BGP(?s :p3 ?v3) ,<br>
        &nbsp;
        true )
    </div>
  </div>

<p>Example: group consisting of a basic graph pattern, a filter and an optional 
graph pattern:</p>

  <div class="algExample">
    <div class="algExample1">
      { ?s :p1 ?v1 FILTER (?v1 &lt; 3 ) OPTIONAL {?s :p2 ?v2} } }</div>

    <div class="algExample2">
      Filter( ?v1 &lt; 3 ,<br>
              &nbsp;
              LeftJoin( BGP(?s :p1 ?v1), BGP(?s :p2 ?v2), true) ,<br>
             &nbsp;
             )
    </div>
  </div>

  <h4>12.2.3 <a id="convertSolMod" name="convertSolMod">Converting Solution Modifiers</a></h4>

  <p>Step 1 : ToList</p>

  <p>ToList turns a multiset into a sequence with the same elements and cardinality. There is no implied ordering to
  the sequence; duplicates need not be adjacent.</p>

  <blockquote>
    <p>Let M := ToList(Pattern)</p>
  </blockquote>

  <p>Step 2 : ORDER BY</p>

  <p>If the query string has an ORDER BY clause</p>

  <blockquote>
    <p>M := OrderBy(M, list of order comparators)</p>
  </blockquote>

  <p>Step 3 : Projection</p>

  <blockquote>
    <p>M := Project(M, vars)</p>
  </blockquote>

  <p>where vars is the set of variables mentioned in the SELECT clause or all named variables in the query if SELECT *
  used.</p>

  <p>Step 4 : DISTINCT</p>

  <p>If the query contains DISTINCT,</p>

  <blockquote>
    <p>M := Distinct(M)</p>
  </blockquote>

  <p>Step 5 : REDUCED</p>

  <p>If the query contains REDUCED,</p>

  <blockquote>
    <p>M := Reduced(M)</p>
  </blockquote>

  <p>Step 6 : OFFSET and LIMIT</p>

  <p>If the query contains "OFFSET start" or "LIMIT length"</p>

  <blockquote>
    <p>M := Slice(M, start, length)</p>
    <blockquote>
      <p>start defaults to 0</p>
      <p>length defaults to (size(M)-start).</p>
    </blockquote>

  </blockquote>

  <p>The overall abstract query is M.</p>


  <h3>12.3 <a id="BasicGraphPattern" name="BasicGraphPattern">Basic Graph Patterns</a></h3>
<p>When matching graph patterns, the possible solutions form a <i>
<a href="http://en.wikipedia.org/w/index.php?title=Multiset&amp;oldid=163605900">multiset</a></i> [<a href="#multiset">multiset</a>], also known as 
a <i>bag</i>. A multiset is an unordered collection of elements in which each 
element may appear more than once. It is described by a set of elements and a
cardinality function giving the number of occurrences of each element from the 
set in the multiset.</p>

  <p>Write μ for solution mappings and </p>
<p>Write μ<sub>0</sub> for the mapping such that dom(μ<sub>0</sub>) is the empty set.</p>

  <p>Write Ω<sub>0</sub> for the multiset consisting of exactly the empty mapping μ<sub>0,</sub> with
  cardinality 1. This is the join identity.</p>

  <p>Write μ(?x-&gt;t) for the solution mapping variable x to RDF term t : { (x, t) }</p>

  <p>Write Ω(?x-&gt;t) for the multiset consisting of exactly μ(?x-&gt;t), that is, { { (x, t) } } with
  cardinality 1.</p>

  <div class="defn">
    <b>Definition: <a id="defn_algCompatibleMapping" name="defn_algCompatibleMapping">Compatible Mappings</a></b>

    <p>Two solution mappings μ<sub>1</sub> and μ<sub>2</sub> are compatible if, for every variable v in
    dom(μ<sub>1</sub>) and in dom(μ<sub>2</sub>), μ<sub>1</sub>(v) = μ<sub>2</sub>(v).</p>

  </div>

    <p>If μ<sub>1</sub> and μ<sub>2</sub> are compatible then μ<sub>1</sub> <i>set-union</i> μ<sub>2</sub>
    is also a mapping. Write merge(μ<sub>1</sub>, μ<sub>2</sub>) for μ<sub>1</sub> <i>set-union</i> μ<sub>2</sub></p>

  <p>Write card[Ω](μ) for the cardinality of solution mapping μ in a multiset 
  of mappings Ω.</p>

  <h4>12.3.1 <a id="BGPsparql" name="BGPsparql">SPARQL Basic Graph Pattern Matching</a></h4>

  <p>Basic graph patterns form the basis of SPARQL pattern matching. A basic 
  graph pattern is matched against the active graph for that part of the query. 
  Basic graph patterns can be instantiated by 
replacing both variables and blank nodes by terms, giving two notions 
of instance. Blank nodes are replaced using an
  <a href="http://www.w3.org/TR/rdf-mt#definst">RDF 
instance mapping</a>, &nbsp;σ, from blank nodes to RDF terms; variables are 
  replaced by a solution mapping from query variables to RDF terms.</p>

<div class="defn">
    <b>Definition: <a id="defn_PatternInstanceMapping" name="defn_PatternInstanceMapping">Pattern Instance Mapping</a></b>
    
    <p>A <b>Pattern Instance Mapping</b>, P, is the combination of an RDF 
    instance mapping, σ, and solution mapping, μ. P(x) = μ(σ(x))</p>
</div>    


    <p>Any pattern instance mapping defines a unique solution mapping
    and a unique RDF instance mapping obtained by restricting it to query 
	variables and blank nodes respectively.</p>

<div class="defn">
    <b>Definition: Basic Graph Pattern Matching</b>
    <p>Let BGP be a basic graph pattern and let G be an RDF graph.</p>
    <p>μ is a <b>solution</b> for BGP from G when there is a pattern instance 
    mapping P such that P(BGP) is a subgraph of G and μ is the restriction of P to 
    the query variables in BGP.</p>
    <p>card[Ω](μ) = card[Ω](number of distinct RDF instance mappings, σ, 
    such that P = μ(σ) is a pattern instance mapping and P(BGP) is a subgraph of G).</p>
</div>    
<p>If a basic graph pattern is the empty set, then the solution is Ω<sub>0</sub>.</p>
<h4>12.3.2 <a id="BGPsparqlBNodes" name="BGPsparqlBNodes">Treatment of Blank Nodes</a></h4>

		<p>This definition allows the solution mapping to bind a variable in a 
        basic graph pattern, BGP, to a blank node in G. Since SPARQL treats 
        blank node identifiers in a <a href="http://www.w3.org/TR/rdf-sparql-XMLres/">SPARQL Query Results XML Format</a> document as scoped to the document, they 
cannot be understood as identifying nodes in the active graph of the dataset. If DS is 
the dataset of a query, pattern solutions are therefore understood to 
be not from the active graph of DS itself, but from an RDF graph, called the <i>scoping 
graph,</i> which is graph-equivalent to the active graph of DS but shares no blank nodes 
with DS or with BGP. The same scoping graph is used for all solutions 
to a single query. The scoping graph is purely a theoretical 
construct; in practice, the effect is obtained simply by the document 
scope conventions for blank node identifiers. </p>

<!--
 <div class="defn">
    <b>Definition:</b> <a id="defn_ScopingGraph" name="defn_GraphSet">Scoping Graph</a>

    <p>The <span class="definedTerm">Scoping Graph</span> G' for
    RDF graph G, is an RDF Graph that is <a href="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/#section-graph-equality">

    graph-equivalent</a> to G</p>
  </div>
-->
		<p>Since RDF blank nodes allow infinitely many redundant solutions for 
        many patterns, there can be infinitely many pattern solutions (obtained 
        by replacing blank nodes by different blank nodes). It is necessary, 
        therefore, to somehow delimit the solutions for a basic graph pattern. SPARQL uses the 
        subgraph match criterion to determine the solutions of a basic graph 
        pattern. There is 
        one solution for each distinct pattern instance mapping from the basic 
        graph pattern to a subset of the active graph.</p>
<p>This is optimized for ease of computation rather 
than redundancy elimination. It allows query results to contain 
redundancies even when the active graph of the dataset is 
<a href="http://www.w3.org/TR/rdf-mt/#deflean">lean</a>, and it allows logically 
equivalent datasets to yield different query results. </p>

  <h3>12.4 <a id="sparqlAlgebra" name="sparqlAlgebra">SPARQL Algebra</a></h3>

  <p>For each symbol in a SPARQL abstract query, we define an operator for 
  evaluation. The SPARQL algebra operators of the same name are
  used to evaluate SPARQL abstract query nodes as described in the section "<a href="#sparqlAlgebraEval">Evaluation
  Semantics</a>".</p>

  <div class="defn">
    <p><b>Definition: <a id="defn_algFilter" name="defn_algFilter">Filter</a></b></p>

    <p>Let Ω be a multiset of solution mappings and expr be an expression. We define:</p>

    <p>Filter(expr, Ω) = { μ | μ in Ω and expr(μ) is an expression that has an 
    effective boolean value of true }</p>

    <p>card[Filter(expr, Ω)](μ) = card[Ω](μ)</p>
  </div>

  <div class="defn">
    <p><b>Definition: <a id="defn_algJoin" name="defn_algJoin">Join</a></b></p>

    <p>Let Ω<sub>1</sub> and Ω<sub>2</sub> be multisets of solution mappings. We define:</p>

    <p>Join(Ω<sub>1</sub>, Ω<sub>2</sub>) = { merge(μ<sub>1</sub>, μ<sub>2</sub>) | μ<sub>1</sub>
    in Ω<sub>1</sub>and μ<sub>2</sub> in Ω<sub>2</sub>, and μ<sub>1</sub> and μ<sub>2</sub> are
    compatible }</p>

    <p>card[Join(Ω<sub>1</sub>, Ω<sub>2</sub>)](μ) = <br>
&nbsp;&nbsp;&nbsp; for each merge(μ<sub>1</sub>, μ<sub>2</sub>), μ<sub>1</sub>
    in Ω<sub>1</sub>and μ<sub>2</sub> in Ω<sub>2</sub> such that μ = merge(μ<sub>1</sub>, μ<sub>2</sub>),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sum over (μ<sub>1</sub>, μ<sub>2</sub>), card[Ω<sub>1</sub>](μ<sub>1</sub>)*card[Ω<sub>2</sub>](μ<sub>2</sub>)</p>
  </div>

<p>It is possible that a solution mapping μ in a Join can arise in different 
solution mappings, μ<sub>1</sub>and μ<sub>2</sub> in the multisets being 
joined. The cardinality of&nbsp; μ is the sum of the cardinalities from all 
possibilities.</p>

  <div class="defn">
    <p><b>Definition: <a id="defn_algDiff" name="defn_algDiff">Diff</a></b></p>

    <p>Let Ω<sub>1</sub> and Ω<sub>2</sub> be multisets of solution mappings. We define:</p>

    <p>Diff(Ω<sub>1</sub>, Ω<sub>2</sub>, expr) =
            { μ | μ in Ω<sub>1</sub> such that for all μ′ in Ω<sub>2</sub>, 
    either μ and μ′ are not compatible or μ and μ'
    are compatible and expr(merge(μ, μ')) has an effective boolean value 
	of false }</p>

    <p>card[Diff(Ω<sub>1</sub>, Ω<sub>2</sub>, expr)](μ) = card[Ω<sub>1</sub>](μ)</p>
  </div>

  <p>Diff is used internally for the definition of LeftJoin.</p>

  <div class="defn">
    <p><b>Definition: <a id="defn_algLeftJoin" name="defn_algLeftJoin">LeftJoin</a></b></p>

    <p>Let Ω<sub>1</sub> and Ω<sub>2</sub> be multisets of solution mappings and 
    expr be an expression. We define:</p>

    <p>LeftJoin(Ω<sub>1</sub>, Ω<sub>2</sub>, expr) = Filter(expr, Join(Ω<sub>1</sub>,
    Ω<sub>2</sub>)) <i>set-union</i> Diff(Ω<sub>1</sub>, Ω<sub>2</sub>, expr)</p>

    <p>card[LeftJoin(Ω<sub>1</sub>, Ω<sub>2</sub>, expr)](μ) = card[Filter(expr,
    Join(Ω<sub>1</sub>, Ω<sub>2</sub>))](μ) + card[Diff(Ω<sub>1</sub>, Ω<sub>2</sub>,
    expr)](μ)</p>
  </div>

  <p>Written in full that is:</p>

  <p>LeftJoin(Ω<sub>1</sub>, Ω<sub>2</sub>, expr) =<br>
          &nbsp;&nbsp;&nbsp;
          { merge(μ<sub>1,</sub> μ<sub>2</sub>) | μ<sub>1</sub> in Ω<sub>1</sub>and μ<sub>2</sub> in
  Ω<sub>2</sub>, and μ<sub>1</sub> and μ<sub>2</sub> are compatible and expr(merge(μ<sub>1</sub>,
  μ<sub>2</sub>)) is true }<br>
              <i>set-union</i><br>
          &nbsp;&nbsp;&nbsp;
          { μ<sub>1</sub> | μ<sub>1</sub> in Ω<sub>1</sub>and μ<sub>2</sub> in Ω<sub>2</sub>, and
  μ<sub>1</sub> and μ<sub>2</sub> are not compatible }<br>
              <i>set-union</i><br>
          &nbsp;&nbsp;&nbsp;
          { μ<sub>1</sub> | μ<sub>1</sub> in Ω<sub>1</sub>and μ<sub>2</sub> in Ω<sub>2</sub>, and
  μ<sub>1</sub> and μ<sub>2</sub> are compatible and expr(merge(μ<sub>1</sub>, μ<sub>2</sub>)) is false
  }</p>

  <p>As these are distinct, the cardinality of LeftJoin is cardinality of these individual components of the
  definition.</p>

  <div class="defn">
    <p><b>Definition: <a id="defn_algUnion" name="defn_algUnion">Union</a></b></p>

    <p>Let Ω<sub>1</sub> and Ω<sub>2</sub> be multisets of solution mappings. We define:</p>

    <p>Union(Ω<sub>1</sub>, Ω<sub>2</sub>) = { μ | μ in Ω<sub>1</sub> or μ in
    Ω<sub>2</sub> }</p>

    <p>card[Union(Ω1, Ω2)](μ) = card[Ω1](μ) + card[Ω2](μ)</p>
  </div>

  <p>Write [x | C] for a sequence of elements where C(x) is true.</p>

  <p>Write card[L](x) to be the cardinality of x in L.</p>

  <div class="defn">
    <b>Definition: <a id="defn_algToList" name="defn_algToList">ToList</a></b>

    <p>Let Ω be a multiset of solution mappings.  We define:</p>

    <p>ToList(Ω) = a sequence of mappings μ in Ω in any order, with card[Ω](μ) occurrences of
    μ</p>

    <p>card[ToList(Ω)](μ) = card[Ω](μ)</p>
  </div>

  <div class="defn">
    <b>Definition: <a id="defn_algOrdered" name="defn_algOrdered">OrderBy</a></b>

    <p>Let Ψ be a sequence of solution mappings.  We define:</p>

    <p><a id="defn_algOrderBy0" name="defn_algOrderBy0">OrderBy</a>(Ψ, condition) = [ μ | μ in Ψ and the
    sequence satisfies the ordering condition]</p>

    <p>card[<a id="defn_algOrderBy1" name="defn_algOrderBy1">OrderBy</a>(Ψ, condition)](μ) =
    card[Ψ](μ)</p>
  </div>

  <div class="defn">
    <b>Definition: <a id="defn_algProjection" name="defn_algProjection">Project</a></b>

    <p>Let Ψ be a sequence of solution mappings and PV a set of variables.</p>

    <p>For mapping μ, write Proj(μ, PV) to be the restriction of μ to variables in 
    PV.</p>

    <p>Project(Ψ, PV)  = [ Proj(Ψ[μ], PV) | μ in Ψ ]</p>
    <p>card[Project(Ψ, PV)](μ) = card[Ψ](μ)</p>
    <p>The order of Project(Ψ, PV) must preserve any ordering given by OrderBy.</p>
  </div>

  <div class="defn">
    <b>Definition: <a id="defn_algDistinct" name="defn_algDistinct">Distinct</a></b>

    <p>Let Ψ be a sequence of solution mappings.  We define:</p>

    <p>Distinct(Ψ) = [ μ | μ in Ψ ]</p>
    <p>card[Distinct(Ψ)](μ) = 1</p>

    <p>The order of Distinct(Ψ) must preserve any ordering given by OrderBy.</p>
  </div>

  <div class="defn">
    <b>Definition: <a id="defn_algReduced" name="defn_algReduced">Reduced</a></b>

    <p>Let Ψ be a sequence of solution mappings.  We define:</p>

    <p>Reduced(Ψ) = [ μ | μ in Ψ ]</p>
    <p>card[Reduced(Ψ)](μ) is between 1 and card[Ψ](μ)</p>

    <p>The order of Reduced(Ψ) must preserve any ordering given by OrderBy.</p>
  </div>

  <p>The Reduced solution sequence modifier does not guarantee a defined cardinality.</p>

  <div class="defn">
    <b>Definition: <a id="defn_algSlice" name="defn_algSlice">Slice</a></b>

    <p>Let Ψ be a sequence of solution mappings.  We define:</p>

    <p><a name="defn_algOrderBy2" id="defn_algOrderBy2">Slice</a>(Ψ, start, length)[i] = Ψ[start+i] for i = 0
    to (length-1)</p>
  </div>

  <h3>12.5 <a id="sparqlAlgebraEval" name="sparqlAlgebraEval">Evaluation Semantics</a></h3>

  <p>We define eval(D(G), graph pattern) as the evaluation of a graph pattern with respect to a dataset D having active
  graph G. The active graph is initially the default graph.</p>

  <pre class="box">D : a dataset
D(G) : D a dataset with active graph G (the one patterns match against)
D[i] : The graph with IRI i in dataset D
D[DFT] : the default graph of D
P, P1, P2 : graph patterns
L : a solution sequence</pre>
<div class="defn">
    <b>Definition: <a id="defn_evalFilter" name="defn_evalFilter">Evaluation of Filter(F, 
    P)</a></b>
    <pre class="code">eval(D(G), Filter(F, P)) = Filter(F, eval(D(G),P))</pre>
  </div>

  <div class="defn">
    <b>Definition: <a id="defn_evalJoin" name="defn_evalJoin">Evaluation of 
    Join(P1, P2)</a></b>
    <pre class="code">eval(D(G), Join(P1, P2)) = Join(eval(D(G), P1), eval(D(G), P2))</pre>
  </div>

  <div class="defn">
    <b>Definition: <a id="defn_evalLeftJoin" name="defn_evalLeftJoin">Evaluation of LeftJoin(P1, P2, F)</a></b>
    <pre class="code">eval(D(G), LeftJoin(P1, P2, F)) = LeftJoin(eval(D(G), P1), eval(D(G), P2), F)
</pre>
  </div>

  <div class="defn">
    <b>Definition: <a id="defn_evalBasicGraphPattern" name="defn_evalBasicGraphPattern">Evaluation of a Basic Graph
    Pattern</a></b>
	<pre class="code">eval(D(G), BGP) = multiset of solution mappings</pre>
    <p>See section <a href="#BasicGraphPattern">12.3 Basic Graph Patterns</a></p>
  </div>

  <div class="defn">
    <b>Definition: <a id="defn_evalUnion" name="defn_evalUnion">Evaluation of a Union Pattern</a></b>
    <pre class="code">eval(D(G), Union(P1,P2)) = Union(eval(D(G), P1), eval(D(G), P2))
</pre>
  </div>

  <div class="defn">
    <b>Definition: <a id="defn_evalGraph" name="defn_evalGraph">Evaluation of a Graph Pattern</a></b>
    <pre class="code">if IRI is a graph name in D
eval(D(G), Graph(IRI,P)) = eval(D(D[IRI]), P)</pre>
    <pre class="code">if IRI is not a graph name in D
eval(D(G), Graph(IRI,P)) = the empty multiset</pre>
    <pre class="code">eval(D(G), Graph(var,P)) =
     Let R be the empty multiset
     foreach IRI i in D
        R := Union(R, Join( eval(D(D[i]), P) , Ω(?var-&gt;i) )
     the result is R
</pre>
  </div>
<p>The evaluation of graph uses the SPARQL algebra union operator. The 
cardinality of a solution mapping is the sum of the cardinalities of that 
solution mapping in each join operation.</p>
  <div class="defn">
    <b>Definition: <a id="defn_evalList" name="defn_evalList">Evaluation of ToList</a></b><pre class="code">eval(D, ToList(P)) = ToList(eval(D(D[DFT]), P))
</pre>
  </div>

  <div class="defn">
    <b>Definition: <a id="defn_evalDistinct" name="defn_evalDistinct">Evaluation of Distinct</a></b><pre class="code">eval(D, Distict(L)) = Distinct(eval(D, L))
</pre>
  </div>

  <div class="defn">
    <b>Definition: <a id="defn_evalReduced" name="defn_evalReduced">Evaluation of Reduced</a></b><pre class="code">eval(D, Reduced(L)) = Reduced(eval(D, L))
</pre>
  </div>

  <div class="defn">
    <b>Definition: <a id="defn_evalProject" name="defn_evalProject">Evaluation of Project</a></b><pre class="code">eval(D, Project(L, vars)) = Project(eval(D, L), vars)
</pre>
  </div>

  <div class="defn">
    <b>Definition: <a id="defn_evalOrderBy" name="defn_evalOrderBy">Evaluation of OrderBy</a></b><pre class="code">eval(D, OrderBy(L, condition)) = OrderBy(eval(D, L), condition)
</pre>
  </div>

  <div class="defn">
    <b>Definition: <a id="defn_evalSlice" name="defn_evalSlice">Evaluation of Slice</a></b><pre class="code">eval(D, Slice(L, start, length)) = Slice(eval(D, L), start, length)
</pre>
  </div>
  
<h3>12.6 <a id="sparqlBGPExtend" name="sparqlBGPExtend">Extending SPARQL Basic Graph Matching</a></h3>

<p>The overall SPARQL design can be used for queries 
which assume a more elaborate form of entailment than simple 
entailment, by re-writing the matching conditions for basic graph 
patterns. Since it is an open research problem to state such 
conditions in a single general form which applies to all forms of 
entailment and optimally eliminates needless or inappropriate 
redundancy, this document only gives necessary conditions which any 
such solution should satisfy. These will need to be extended to full 
definitions for each particular case. </p>

 <p>Basic graph patterns stand in the same relation to triple patterns 
that RDF graphs do to RDF triples, and much of the same terminology 
can be applied to them. In particular, two basic graph patterns are 
said to be <i>equivalent</i> if there is a bijection M between the 
terms of the triple patterns that maps blank nodes to blank nodes and 
maps variables, literals and IRIs to themselves, such that a triple ( 
s, p, o ) is in the first pattern if and only if the triple ( M(s), 
M(p) M(o) ) is in the second. This definition extends that for RDF 
graph equivalence to basic graph patterns by preserving variable 
names across equivalent patterns. </p>

<p>An <i>entailment regime</i> specifies </p>
<ol>
	<li>a subset of RDF graphs called <i>well-formed</i> for the regime</li>
	<li>an <i>entailment</i> relation between subsets of well-formed graphs
	 and well-formed graphs.</li>
</ol>

<p>Examples of entailment regimes include simple 
entailment [<a href="#RDF-MT">RDF-MT</a>], RDF entailment
[<a href="#RDF-MT">RDF-MT</a>], RDFS entailment 
[<a href="#RDF-MT">RDF-MT</a>], D-entailment [<a href="#RDF-MT">RDF-MT</a>] and
OWL-DL entailment [<a href="#OWL_Semantics">OWL-Semantics</a>]. 
Of these, only OWL-DL entailment restricts the set of well-formed graphs.
If E is an entailment
regime then we will refer to E-entailment, 
E-consistency, etc, following this naming convention.</p>

<p>Some entailment regimes can categorize some RDF 
graphs as inconsistent. For example, the RDF graph:</p>
<pre class="data">_:x rdf:type xsd:string .
_:x rdf:type xsd:decimal .
</pre>
<p>is D-inconsistent when D contains the XSD datatypes. The effect of a query
on an inconsistent graph is not 
covered by this specification, but must be specified by the particular 
SPARQL extension.</p>
        
        
<p>A SPARQL extension to E-entailment must satisfy the following 
conditions. </p>
<p>1 -- The 
<a href="#BGPsparqlBNodes">scoping graph</a>, SG, corresponding to any consistent 
active graph AG is uniquely specified and is E-equivalent to AG.</p>
<p>2 -- For any basic graph pattern BGP and pattern solution mapping P, P(BGP) is 
well-formed for E</p>
<p>3 -- For any scoping graph SG and answer set {P<sub>1</sub> ... P<sub>n</sub>} 
for a basic graph pattern BGP, and where {BGP<sub>1 .... </sub>BGP<sub>n</sub>} is a set of basic graph patterns 
all equivalent to BGP, none of which share any blank nodes with any other or with 
SG</p>
<blockquote>
	<p>SG E-entails (SG union P<sub>1</sub>(BGP<sub>1</sub>) union ... union P<sub>n</sub>(BGP<sub>n</sub>))</p>
</blockquote>
<p>These conditions do not fully determine the set of possible answers, since 
RDF allows unlimited amounts of redundancy. In addition, therefore, the 
following must hold.</p>
<p>4 -- Each SPARQL extension must provide conditions on answer sets which 
guarantee that every BGP and AG has a finite set of answers which is unique up 
to RDF graph equivalence.</p>
<h4 id="sparqlBGPExtend-notes">Notes</h4>
<p>(a) SG will often be graph equivalent to AG, but restricting this to 
E-equivalence allows some forms of normalization, for example elimination of 
semantic redundancies, to be applied to the source documents before querying.
</p>
<p>(b) The construction in condition 3 ensures that any blank nodes introduced 
by the solution mapping are used in a way which is internally consistent with the 
way that blank nodes occur in SG. This ensures that blank node identifiers occur 
in more than one answer in an answer set only when the blank nodes so identified 
are indeed identical in SG. If the extension does not allow answer bindings to 
blank nodes, then this condition can be simplified to the condition:</p>
<blockquote>
	<p>SG E-entails P(BGP) for each pattern solution P.</p>
</blockquote>
<p>(c) These conditions do not impose the SPARQL requirement that SG share no 
blank nodes with AG or BGP. In particular, it allows SG to actually be AG. This 
allows query protocols in which blank node identifiers retain their meaning 
between the query and the source document, or across multiple queries. Such 
protocols are not supported by the current SPARQL protocol specification, 
however. </p>
<p>(d) Since conditions 1 to 3 are only necessary conditions on answers, 
condition 4 allows cases where the set of legal answers can be restricted in 
various ways. For example, the current state of the art in OWL-DL querying 
focusses on the case where answer bindings to blank nodes are prohibited. We 
note that these conditions even allow the pathological 'mute' case where every 
query has an empty answer set. </p>
<p>(e) None of these conditions refer explicitly to instance mappings on blank 
nodes in BGP. For some entailment regimes, the existential interpretation of 
blank nodes cannot be fully captured by the existence of a single instance 
mapping. These conditions allow such regimes to give blank nodes in query 
patterns a 'fully existential' reading. </p>
<p>It is straightforward to show that SPARQL satisfies these conditions for the 
case where E is simple entailment, given that the SPARQL condition on SG is that 
it is graph-equivalent to AG but shares no blank nodes with AG or BGP (which 
satisfies the first condition). The only condition which is nontrivial is (3).
</p>
<p>Every answer P<sub>i</sub> is the solution mapping restriction of a SPARQL 
instance M<sub>i</sub> such that M<sub>i</sub>(BGP<sub>i</sub>) is a subgraph of 
SG. Since BGP<sub>i</sub> and SG have no blank nodes in common, the range of M<sub>i</sub> 
contains no blank nodes from BGP<sub>i</sub>; therefore, the solution mapping P<sub>i</sub> 
and RDF instance mapping I<sub>i</sub> components of M<sub>i</sub> commute, so M<sub>i</sub>(BGP<sub>i</sub>) 
= I<sub>i</sub>(P<sub>i</sub>(BGP<sub>i</sub>)). So</p>
<p>M<sub>1</sub>(BGP<sub>1</sub>) union ... union M<sub>n</sub>(BGP<sub>n</sub>)
<br>= I<sub>1</sub>(P<sub>1</sub>(BGP<sub>1</sub>)) union ... union I<sub>n</sub>(P<sub>n</sub>(BGP<sub>n</sub>))<br>= [ I<sub>1</sub> + ... + I<sub>n</sub>]( P<sub>1</sub>(BGP<sub>1</sub>) union 
... union P<sub>n</sub>(BGP<sub>n</sub>) )</p>
<p>since the domains of the I<sub>i</sub> instance mappings are all mutually 
exclusive. Since they are also exclusive from SG, </p>
<p>SG union [ I<sub>1</sub> + ... + I<sub>n</sub>]( P<sub>1</sub>(BGP<sub>1</sub>) 
union ... union P<sub>n</sub>(BGP<sub>n</sub>) )<br>= [ I<sub>1</sub> + ... + I<sub>n</sub>](SG union P<sub>1</sub>(BGP<sub>1</sub>) 
union ... union P<sub>n</sub>(BGP<sub>n</sub>) )</p>
<p>i.e. </p>
<p>SG union P<sub>1</sub>(BGP<sub>1</sub>) union ... union P<sub>n</sub>(BGP<sub>n</sub>)</p>
<p>has an instance which is a subgraph of SG, so is simply entailed by SG by the 
<a href="http://www.w3.org/TR/rdf-mt/#interplemmaprf">RDF interpolation lemma</a> 
[<a href="#RDF-MT">RDF-MT</a>].</p>
<h2>A. <a id="grammar" name="grammar">SPARQL Grammar</a></h2>
<h4>A.1 <a id="queryString" name="queryString">SPARQL Query String</a></h4>
<p>A <a name="defn_SPARQLQueryString" id="defn_SPARQLQueryString">SPARQL query string</a> 
is a Unicode character string (c.f. section 6.1 String concepts of [<a href="#CHARMOD">CHARMOD</a>]) 
in the language defined by the following grammar, starting with the
<a href="#rQuery">Query</a> production. For compatibility with future versions of 
Unicode, the characters in this string may include Unicode codepoints that are unassigned 
as of the date of this publication (see
<a class="inform" href="http://www.unicode.org/reports/tr31/tr31-5.html">Identifier 
and Pattern Syntax</a> [<a href="#UNIID">UNIID</a>] section 4 Pattern Syntax). For 
productions with excluded character classes (for example <code>[^&lt;&gt;'{}|^`]</code>), 
the characters are excluded from the range <code>#x0 - #x10FFFF</code>.</p>
<h4>A.2 <a id="codepointEscape" name="codepointEscape">Codepoint Escape Sequences</a></h4>
<p>A SPARQL Query String is processed for codepoint escape sequences before parsing 
by the grammar defined in EBNF below. The codepoint escape sequences for a SPARQL 
query string are:</p>
<table summary="Codepoint escapes" id="table68">
	<colgroup><col width="40%">
	</colgroup>
	<tbody><tr>
		<th class="major">Escape</th>
		<th class="major">Unicode code point</th>
	</tr>
	<tr>
		<td><span class="token">'\u'</span> <a href="#rHEX">HEX</a>
		<a href="#rHEX">HEX</a> <a href="#rHEX">HEX</a> <a href="#rHEX">HEX</a></td>
		<td>A Unicode code point in the range U+0 to U+FFFF inclusive corresponding 
    to the encoded hexadecimal value.</td>
	</tr>
	<tr>
		<td><span class="token">'\U'</span> <a href="#rHEX">HEX</a>
		<a href="#rHEX">HEX</a> <a href="#rHEX">HEX</a> <a href="#rHEX">HEX</a>
		<a href="#rHEX">HEX</a> <a href="#rHEX">HEX</a> <a href="#rHEX">HEX</a>
		<a href="#rHEX">HEX</a></td>
		<td>A Unicode code point in the range U+0 to U+10FFFF inclusive corresponding 
    to the encoded hexadecimal value.</td>
	</tr>
</tbody></table>
<p>where <a href="#rHEX">HEX</a> is a hexadecimal character</p>
<blockquote>
	<p><span style="font-family: monospace; font-size: 85%;"><a name="rHEX" id="rHEX">HEX</a> 
  ::= [0-9] | [A-F] | [a-f]</span></p>
</blockquote>
<p>Examples:</p>
<pre class="query untested">&lt;ab\u00E9xy&gt;        # Codepoint 00E9 is Latin small e with acute - é
\u03B1:a            # Codepoint x03B1 is Greek small alpha - α
a\u003Ab            # a:b -- codepoint x3A is colon</pre>
<p>Codepoint escape sequences can appear anywhere in the query string. They are 
processed before parsing based on the grammar rules and so may be replaced by codepoints 
with significance in the grammar, such as "<code>:</code>" marking a prefixed name.
</p>
<p>These escape sequences are not included in the grammar below. Only escape sequences 
for characters that would be legal at that point in the grammar may be given. For 
example, the variable "<code>?x\u0020y</code>" is not legal (<code>\u0020</code> 
is a space and is not permitted in a variable name).</p>
<h4>A.3 <a id="whitespace" name="whitespace">White Space</a></h4>
<p>White space (production <code class="gRuleBody"><a href="#rWS">WS</a></code>) 
is used to separate two terminals which would otherwise be (mis-)recognized as one 
terminal. Rule names below in capitals indicate where white space is significant; 
these form a possible choice of terminals for constructing a SPARQL parser. White 
space is significant in strings.</p>
<p>For example:</p>
<blockquote>
	<p><code>?a&lt;?b&amp;&amp;?c&gt;?d</code></p>
</blockquote>
<p>is the token sequence variable '<code>?a</code>', an IRI '<code>&lt;?b&amp;&amp;?c&gt;</code>', 
and variable '<code>?d</code>', not a expression involving the operator '<code>&amp;&amp;</code>' 
connextting two expression using '<code>&lt;</code>' (less than) and '<code>&gt;</code>' (greater than).</p>
<h4>A.4 <a id="grammarComments" name="grammarComments">Comments</a></h4>
<p>Comments in SPARQL queries take the form of '<code>#</code>', outside an IRI 
or string, and continue to the end of line (marked by characters <code>0x0D</code> 
or <code>0x0A</code>) or end of file if there is no end of line after the comment 
marker. Comments are treated as white space.</p>
<h4>A.5 <a id="iriRefs" name="iriRefs">IRI References</a></h4>
<p>Text matched by the <code class="gRuleBody"><a href="#rIRI_REF">IRI_REF</a></code> 
production and <code class="gRuleHead"><a href="#rPrefixedName">PrefixedName</a></code> (after 
prefix expansion) production, after escape processing, must be conform to the generic 
syntax of IRI references in section 2.2 of RFC 3987 "ABNF for IRI References and 
IRIs" [<a href="#rfc3987">RFC3987</a>]. For example, the 
<code class="gRuleBody"><a href="#rIRI_REF">IRI_REF</a></code> <code>&lt;abc#def&gt;</code> may occur in a 
SPARQL query string, but the <code class="gRuleBody"><a href="#rIRI_REF">IRI_REF</a></code>
<code>&lt;abc##def&gt;</code> must not.</p>
<p>Base IRIs declared with the <span class="token">BASE</span> keyword must be absolute 
IRIs. A prefix declared with the <span class="token">PREFIX</span> keyword may not 
be re-declared in the same query. See section 2.1.1, <a href="#QSynIRI">Syntax 
of IRI Terms</a>, for a description of <span class="token">BASE</span> and
<span class="token">PREFIX</span>.</p>
<h4>A.6 <a id="grammarBNodeLabels" name="grammarBNodeLabels">Blank Node Labels</a></h4>
<p>The same blank node label may not be used in two separate basic graph patterns 
with a single query.</p>
<h4>A.7 <a id="grammarEscapes" name="grammarEscapes">Escape sequences in strings</a></h4>
<p>In addition to the <a href="#codepointEscape">codepoint escape sequences</a>, the following escape sequences 
any <code><a href="#rString">string</a></code> production (e.g. <code>
<a href="#rSTRING_LITERAL1">STRING_LITERAL1</a></code>, <code>
<a href="#rSTRING_LITERAL2">STRING_LITERAL2</a></code>, <code>
<a href="#rSTRING_LITERAL_LONG1">STRING_LITERAL_LONG1</a></code>, <code>
<a href="#rSTRING_LITERAL_LONG2">STRING_LITERAL_LONG2</a></code>):</p>
<table summary="String escapes">
	<colgroup><col width="40%">
	</colgroup>
	<tbody><tr>
		<th class="major">Escape</th>
		<th class="major">Unicode code point</th>
	</tr>
	<tr>
		<td><span class="token">'\t'</span></td>
		<td>U+0009 (tab)</td>
	</tr>
	<tr>
		<td><span class="token">'\n'</span></td>
		<td>U+000A (line feed)</td>
	</tr>
	<tr>
		<td><span class="token">'\r'</span></td>
		<td>U+000D (carriage return)</td>
	</tr>
	<tr>
		<td><span class="token">'\b'</span></td>
		<td>U+0008 (backspace)</td>
	</tr>
	<tr>
		<td><span class="token">'\f'</span></td>
		<td>U+000C (form feed)</td>
	</tr>
	<tr>
		<td><span class="token">'\"'</span></td>
		<td>U+0022 (quotation mark, double quote mark)</td>
	</tr>
	<tr>
		<td><span class="token">"\'"</span></td>
		<td>U+0027 (apostrophe-quote, single quote mark)</td>
	</tr>
	<tr>
		<td><span class="token">'\\'</span></td>
		<td>U+005C (backslash)</td>
	</tr>
</tbody></table>
<p>Examples:</p>
<pre class="query untested">"abc\n"
"xy\rz"
'xy\tz'</pre>
<h4>A.8 <a name="sparqlGrammar" id="sparqlGrammar">Grammar</a></h4>
<p>The EBNF notation used in the grammar is defined in Extensible Markup Language 
(XML) 1.1 [<a href="#XML11">XML11</a>] section 6
<a class="norm" href="http://www.w3.org/TR/2004/REC-xml11-20040204/#sec-notation">Notation</a>.</p>
<p>Keywords are matched in a case-insensitive manner with the exception of the keyword 
'<code>a</code>' which, in line with Turtle and N3, is used in place of the IRI
<code>rdf:type</code> (in full, <code>
<a href="http://www.w3.org/1999/02/22-rdf-syntax-ns#type">http://www.w3.org/1999/02/22-rdf-syntax-ns#type</a></code>).</p>
<p>Keywords:</p>

<!-- <table cellpadding="0" cellspacing="1" style="border-collapse: collapse"> -->
<table class="plain">
	<tbody>
		<tr>
			<td>BASE</td>
			<td>SELECT</td>
			<td>ORDER BY</td>
			<td>FROM</td>
			<td>GRAPH</td>
			<td>STR</td>
			<td>isURI</td>
		</tr>
		<tr>
			<td>PREFIX</td>
			<td>CONSTRUCT</td>
			<td>LIMIT</td>
			<td>FROM NAMED</td>
			<td>OPTIONAL</td>
			<td>LANG</td>
			<td>isIRI</td>
		</tr>
		<tr>
			<td>&nbsp;</td>
			<td>DESCRIBE</td>
			<td>OFFSET</td>
			<td>WHERE</td>
			<td>UNION</td>
			<td>LANGMATCHES</td>
			<td>isLITERAL</td>
		</tr>
		<tr>
			<td>&nbsp;</td>
			<td>ASK</td>
			<td>DISTINCT</td>
			<td>&nbsp;</td>
			<td>FILTER</td>
			<td>DATATYPE</td>
			<td>REGEX</td>
		</tr>
		<tr>
			<td>&nbsp;</td>
			<td>&nbsp;</td>
			<td>REDUCED</td>
			<td>&nbsp;</td>
			<td>a</td>
			<td>BOUND</td>
			<td>true</td>
		</tr>
		<tr>
			<td>&nbsp;</td>
			<td>&nbsp;</td>
			<td>&nbsp;</td>
			<td>&nbsp;</td>
			<td>&nbsp;</td>
			<td>sameTERM</td>
			<td>false</td>
		</tr>
	</tbody>
</table>
<p>Escape sequences are case sensitive.</p>
<p>When choosing a rule to match, the longest match is chosen.</p>

<!-- MARKER html GRAMMAR -->

<div class="grammarTable">
  <table><tbody>

<tr valign="baseline">
  <td><code class="gRuleLabel">[1]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rQuery" name="rQuery">Query</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rPrologue">Prologue</a><br>( <a href="#rSelectQuery">SelectQuery</a> | <a href="#rConstructQuery">ConstructQuery</a> | <a href="#rDescribeQuery">DescribeQuery</a> | <a href="#rAskQuery">AskQuery</a> )</code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[2]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rPrologue" name="rPrologue">Prologue</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rBaseDecl">BaseDecl</a>? <a href="#rPrefixDecl">PrefixDecl</a>*</code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[3]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rBaseDecl" name="rBaseDecl">BaseDecl</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'BASE'</span> <a href="#rIRI_REF">IRI_REF</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[4]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rPrefixDecl" name="rPrefixDecl">PrefixDecl</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'PREFIX'</span> <a href="#rPNAME_NS">PNAME_NS</a> <a href="#rIRI_REF">IRI_REF</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[5]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rSelectQuery" name="rSelectQuery">SelectQuery</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'SELECT'</span> ( <span class="token">'DISTINCT'</span> | <span class="token">'REDUCED'</span> )? ( <a href="#rVar">Var</a>+ | <span class="token">'*'</span> ) <a href="#rDatasetClause">DatasetClause</a>* <a href="#rWhereClause">WhereClause</a> <a href="#rSolutionModifier">SolutionModifier</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[6]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rConstructQuery" name="rConstructQuery">ConstructQuery</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'CONSTRUCT'</span> <a href="#rConstructTemplate">ConstructTemplate</a> <a href="#rDatasetClause">DatasetClause</a>* <a href="#rWhereClause">WhereClause</a> <a href="#rSolutionModifier">SolutionModifier</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[7]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rDescribeQuery" name="rDescribeQuery">DescribeQuery</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'DESCRIBE'</span> ( <a href="#rVarOrIRIref">VarOrIRIref</a>+ | <span class="token">'*'</span> ) <a href="#rDatasetClause">DatasetClause</a>* <a href="#rWhereClause">WhereClause</a>? <a href="#rSolutionModifier">SolutionModifier</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[8]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rAskQuery" name="rAskQuery">AskQuery</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'ASK'</span> <a href="#rDatasetClause">DatasetClause</a>* <a href="#rWhereClause">WhereClause</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[9]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rDatasetClause" name="rDatasetClause">DatasetClause</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'FROM'</span> ( <a href="#rDefaultGraphClause">DefaultGraphClause</a> | <a href="#rNamedGraphClause">NamedGraphClause</a> )</code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[10]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rDefaultGraphClause" name="rDefaultGraphClause">DefaultGraphClause</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rSourceSelector">SourceSelector</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[11]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rNamedGraphClause" name="rNamedGraphClause">NamedGraphClause</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'NAMED'</span> <a href="#rSourceSelector">SourceSelector</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[12]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rSourceSelector" name="rSourceSelector">SourceSelector</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rIRIref">IRIref</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[13]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rWhereClause" name="rWhereClause">WhereClause</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'WHERE'</span>? <a href="#rGroupGraphPattern">GroupGraphPattern</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[14]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rSolutionModifier" name="rSolutionModifier">SolutionModifier</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rOrderClause">OrderClause</a>? <a href="#rLimitOffsetClauses">LimitOffsetClauses</a>?</code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[15]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rLimitOffsetClauses" name="rLimitOffsetClauses">LimitOffsetClauses</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">( <a href="#rLimitClause">LimitClause</a> <a href="#rOffsetClause">OffsetClause</a>? | <a href="#rOffsetClause">OffsetClause</a> <a href="#rLimitClause">LimitClause</a>? )</code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[16]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rOrderClause" name="rOrderClause">OrderClause</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'ORDER'</span> <span class="token">'BY'</span> <a href="#rOrderCondition">OrderCondition</a>+</code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[17]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rOrderCondition" name="rOrderCondition">OrderCondition</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">   ( ( <span class="token">'ASC'</span> | <span class="token">'DESC'</span> ) <a href="#rBrackettedExpression">BrackettedExpression</a> )<br>| ( <a href="#rConstraint">Constraint</a> | <a href="#rVar">Var</a> ) </code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[18]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rLimitClause" name="rLimitClause">LimitClause</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'LIMIT'</span> <a href="#rINTEGER">INTEGER</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[19]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rOffsetClause" name="rOffsetClause">OffsetClause</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'OFFSET'</span> <a href="#rINTEGER">INTEGER</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[20]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rGroupGraphPattern" name="rGroupGraphPattern">GroupGraphPattern</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'{'</span> <a href="#rTriplesBlock">TriplesBlock</a>? ( ( <a href="#rGraphPatternNotTriples">GraphPatternNotTriples</a> | <a href="#rFilter">Filter</a> ) <span class="token">'.'</span>? <a href="#rTriplesBlock">TriplesBlock</a>? )* <span class="token">'}'</span></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[21]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rTriplesBlock" name="rTriplesBlock">TriplesBlock</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rTriplesSameSubject">TriplesSameSubject</a> ( <span class="token">'.'</span> <a href="#rTriplesBlock">TriplesBlock</a>? )?</code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[22]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rGraphPatternNotTriples" name="rGraphPatternNotTriples">GraphPatternNotTriples</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rOptionalGraphPattern">OptionalGraphPattern</a> | <a href="#rGroupOrUnionGraphPattern">GroupOrUnionGraphPattern</a> | <a href="#rGraphGraphPattern">GraphGraphPattern</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[23]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rOptionalGraphPattern" name="rOptionalGraphPattern">OptionalGraphPattern</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'OPTIONAL'</span> <a href="#rGroupGraphPattern">GroupGraphPattern</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[24]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rGraphGraphPattern" name="rGraphGraphPattern">GraphGraphPattern</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'GRAPH'</span> <a href="#rVarOrIRIref">VarOrIRIref</a> <a href="#rGroupGraphPattern">GroupGraphPattern</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[25]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rGroupOrUnionGraphPattern" name="rGroupOrUnionGraphPattern">GroupOrUnionGraphPattern</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rGroupGraphPattern">GroupGraphPattern</a> ( <span class="token">'UNION'</span> <a href="#rGroupGraphPattern">GroupGraphPattern</a> )*</code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[26]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rFilter" name="rFilter">Filter</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'FILTER'</span> <a href="#rConstraint">Constraint</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[27]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rConstraint" name="rConstraint">Constraint</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rBrackettedExpression">BrackettedExpression</a> | <a href="#rBuiltInCall">BuiltInCall</a> | <a href="#rFunctionCall">FunctionCall</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[28]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rFunctionCall" name="rFunctionCall">FunctionCall</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rIRIref">IRIref</a> <a href="#rArgList">ArgList</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[29]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rArgList" name="rArgList">ArgList</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">( <a href="#rNIL">NIL</a> | <span class="token">'('</span> <a href="#rExpression">Expression</a> ( <span class="token">','</span> <a href="#rExpression">Expression</a> )* <span class="token">')'</span> )</code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[30]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rConstructTemplate" name="rConstructTemplate">ConstructTemplate</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'{'</span> <a href="#rConstructTriples">ConstructTriples</a>? <span class="token">'}'</span></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[31]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rConstructTriples" name="rConstructTriples">ConstructTriples</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rTriplesSameSubject">TriplesSameSubject</a> ( <span class="token">'.'</span> <a href="#rConstructTriples">ConstructTriples</a>? )?</code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[32]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rTriplesSameSubject" name="rTriplesSameSubject">TriplesSameSubject</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rVarOrTerm">VarOrTerm</a> <a href="#rPropertyListNotEmpty">PropertyListNotEmpty</a> |	<a href="#rTriplesNode">TriplesNode</a> <a href="#rPropertyList">PropertyList</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[33]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rPropertyListNotEmpty" name="rPropertyListNotEmpty">PropertyListNotEmpty</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rVerb">Verb</a> <a href="#rObjectList">ObjectList</a> ( <span class="token">';'</span> ( <a href="#rVerb">Verb</a> <a href="#rObjectList">ObjectList</a> )? )*</code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[34]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rPropertyList" name="rPropertyList">PropertyList</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rPropertyListNotEmpty">PropertyListNotEmpty</a>?</code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[35]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rObjectList" name="rObjectList">ObjectList</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rObject">Object</a> ( <span class="token">','</span> <a href="#rObject">Object</a> )*</code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[36]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rObject" name="rObject">Object</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rGraphNode">GraphNode</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[37]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rVerb" name="rVerb">Verb</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rVarOrIRIref">VarOrIRIref</a> | <span class="token">'a'</span></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[38]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rTriplesNode" name="rTriplesNode">TriplesNode</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rCollection">Collection</a> |	<a href="#rBlankNodePropertyList">BlankNodePropertyList</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[39]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rBlankNodePropertyList" name="rBlankNodePropertyList">BlankNodePropertyList</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'['</span> <a href="#rPropertyListNotEmpty">PropertyListNotEmpty</a> <span class="token">']'</span></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[40]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rCollection" name="rCollection">Collection</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'('</span> <a href="#rGraphNode">GraphNode</a>+ <span class="token">')'</span></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[41]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rGraphNode" name="rGraphNode">GraphNode</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rVarOrTerm">VarOrTerm</a> |	<a href="#rTriplesNode">TriplesNode</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[42]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rVarOrTerm" name="rVarOrTerm">VarOrTerm</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rVar">Var</a> | <a href="#rGraphTerm">GraphTerm</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[43]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rVarOrIRIref" name="rVarOrIRIref">VarOrIRIref</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rVar">Var</a> | <a href="#rIRIref">IRIref</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[44]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rVar" name="rVar">Var</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rVAR1">VAR1</a> | <a href="#rVAR2">VAR2</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[45]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rGraphTerm" name="rGraphTerm">GraphTerm</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rIRIref">IRIref</a> |	<a href="#rRDFLiteral">RDFLiteral</a> |	<a href="#rNumericLiteral">NumericLiteral</a> |	<a href="#rBooleanLiteral">BooleanLiteral</a> |	<a href="#rBlankNode">BlankNode</a> |	<a href="#rNIL">NIL</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[46]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rExpression" name="rExpression">Expression</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rConditionalOrExpression">ConditionalOrExpression</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[47]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rConditionalOrExpression" name="rConditionalOrExpression">ConditionalOrExpression</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rConditionalAndExpression">ConditionalAndExpression</a> ( <span class="token">'||'</span> <a href="#rConditionalAndExpression">ConditionalAndExpression</a> )*</code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[48]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rConditionalAndExpression" name="rConditionalAndExpression">ConditionalAndExpression</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rValueLogical">ValueLogical</a> ( <span class="token">'&amp;&amp;'</span> <a href="#rValueLogical">ValueLogical</a> )*</code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[49]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rValueLogical" name="rValueLogical">ValueLogical</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rRelationalExpression">RelationalExpression</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[50]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rRelationalExpression" name="rRelationalExpression">RelationalExpression</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rNumericExpression">NumericExpression</a> ( <span class="token">'='</span> <a href="#rNumericExpression">NumericExpression</a> | <span class="token">'!='</span> <a href="#rNumericExpression">NumericExpression</a> | <span class="token">'&lt;'</span> <a href="#rNumericExpression">NumericExpression</a> | <span class="token">'&gt;'</span> <a href="#rNumericExpression">NumericExpression</a> | <span class="token">'&lt;='</span> <a href="#rNumericExpression">NumericExpression</a> | <span class="token">'&gt;='</span> <a href="#rNumericExpression">NumericExpression</a> )?</code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[51]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rNumericExpression" name="rNumericExpression">NumericExpression</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rAdditiveExpression">AdditiveExpression</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[52]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rAdditiveExpression" name="rAdditiveExpression">AdditiveExpression</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rMultiplicativeExpression">MultiplicativeExpression</a> ( <span class="token">'+'</span> <a href="#rMultiplicativeExpression">MultiplicativeExpression</a> | <span class="token">'-'</span> <a href="#rMultiplicativeExpression">MultiplicativeExpression</a> | <a href="#rNumericLiteralPositive">NumericLiteralPositive</a> | <a href="#rNumericLiteralNegative">NumericLiteralNegative</a> )*</code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[53]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rMultiplicativeExpression" name="rMultiplicativeExpression">MultiplicativeExpression</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rUnaryExpression">UnaryExpression</a> ( <span class="token">'*'</span> <a href="#rUnaryExpression">UnaryExpression</a> | <span class="token">'/'</span> <a href="#rUnaryExpression">UnaryExpression</a> )*</code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[54]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rUnaryExpression" name="rUnaryExpression">UnaryExpression</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">&nbsp;&nbsp;<span class="token">'!'</span> <a href="#rPrimaryExpression">PrimaryExpression</a> <br>|	<span class="token">'+'</span> <a href="#rPrimaryExpression">PrimaryExpression</a> <br>|	<span class="token">'-'</span> <a href="#rPrimaryExpression">PrimaryExpression</a> <br>|	<a href="#rPrimaryExpression">PrimaryExpression</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[55]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rPrimaryExpression" name="rPrimaryExpression">PrimaryExpression</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rBrackettedExpression">BrackettedExpression</a> | <a href="#rBuiltInCall">BuiltInCall</a> | <a href="#rIRIrefOrFunction">IRIrefOrFunction</a> | <a href="#rRDFLiteral">RDFLiteral</a> | <a href="#rNumericLiteral">NumericLiteral</a> | <a href="#rBooleanLiteral">BooleanLiteral</a> | <a href="#rVar">Var</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[56]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rBrackettedExpression" name="rBrackettedExpression">BrackettedExpression</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[57]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rBuiltInCall" name="rBuiltInCall">BuiltInCall</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">&nbsp;&nbsp;<span class="token">'STR'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br>|	<span class="token">'LANG'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br>|	<span class="token">'LANGMATCHES'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">','</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br>|	<span class="token">'DATATYPE'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br>|	<span class="token">'BOUND'</span> <span class="token">'('</span> <a href="#rVar">Var</a> <span class="token">')'</span> <br>|	<span class="token">'sameTerm'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">','</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br>|	<span class="token">'isIRI'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br>|	<span class="token">'isURI'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br>|	<span class="token">'isBLANK'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br>|	<span class="token">'isLITERAL'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br>|	<a href="#rRegexExpression">RegexExpression</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[58]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rRegexExpression" name="rRegexExpression">RegexExpression</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'REGEX'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">','</span> <a href="#rExpression">Expression</a> ( <span class="token">','</span> <a href="#rExpression">Expression</a> )? <span class="token">')'</span></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[59]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rIRIrefOrFunction" name="rIRIrefOrFunction">IRIrefOrFunction</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rIRIref">IRIref</a> <a href="#rArgList">ArgList</a>?</code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[60]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rRDFLiteral" name="rRDFLiteral">RDFLiteral</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rString">String</a> ( <a href="#rLANGTAG">LANGTAG</a> | ( <span class="token">'^^'</span> <a href="#rIRIref">IRIref</a> ) )?</code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[61]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rNumericLiteral" name="rNumericLiteral">NumericLiteral</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rNumericLiteralUnsigned">NumericLiteralUnsigned</a> | <a href="#rNumericLiteralPositive">NumericLiteralPositive</a> | <a href="#rNumericLiteralNegative">NumericLiteralNegative</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[62]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rNumericLiteralUnsigned" name="rNumericLiteralUnsigned">NumericLiteralUnsigned</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rINTEGER">INTEGER</a> |	<a href="#rDECIMAL">DECIMAL</a> |	<a href="#rDOUBLE">DOUBLE</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[63]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rNumericLiteralPositive" name="rNumericLiteralPositive">NumericLiteralPositive</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rINTEGER_POSITIVE">INTEGER_POSITIVE</a> |	<a href="#rDECIMAL_POSITIVE">DECIMAL_POSITIVE</a> |	<a href="#rDOUBLE_POSITIVE">DOUBLE_POSITIVE</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[64]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rNumericLiteralNegative" name="rNumericLiteralNegative">NumericLiteralNegative</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rINTEGER_NEGATIVE">INTEGER_NEGATIVE</a> |	<a href="#rDECIMAL_NEGATIVE">DECIMAL_NEGATIVE</a> |	<a href="#rDOUBLE_NEGATIVE">DOUBLE_NEGATIVE</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[65]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rBooleanLiteral" name="rBooleanLiteral">BooleanLiteral</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'true'</span> |	<span class="token">'false'</span></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[66]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rString" name="rString">String</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rSTRING_LITERAL1">STRING_LITERAL1</a> | <a href="#rSTRING_LITERAL2">STRING_LITERAL2</a> | <a href="#rSTRING_LITERAL_LONG1">STRING_LITERAL_LONG1</a> | <a href="#rSTRING_LITERAL_LONG2">STRING_LITERAL_LONG2</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[67]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rIRIref" name="rIRIref">IRIref</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rIRI_REF">IRI_REF</a> |	<a href="#rPrefixedName">PrefixedName</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[68]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rPrefixedName" name="rPrefixedName">PrefixedName</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rPNAME_LN">PNAME_LN</a> | <a href="#rPNAME_NS">PNAME_NS</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[69]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rBlankNode" name="rBlankNode">BlankNode</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rBLANK_NODE_LABEL">BLANK_NODE_LABEL</a> |	<a href="#rANON">ANON</a></code></td>
</tr>
</tbody></table>

<p>Productions for terminals:</p>

<table><tbody>

<tr valign="baseline">
  <td><code class="gRuleLabel">[70]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rIRI_REF" name="rIRI_REF">IRI_REF</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'&lt;' ([^&lt;&gt;"{}|^`\]-[#x00-#x20])* '&gt;'</span></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[71]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rPNAME_NS" name="rPNAME_NS">PNAME_NS</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rPN_PREFIX">PN_PREFIX</a>? ':'</code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[72]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rPNAME_LN" name="rPNAME_LN">PNAME_LN</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rPNAME_NS">PNAME_NS</a> <a href="#rPN_LOCAL">PN_LOCAL</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[73]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rBLANK_NODE_LABEL" name="rBLANK_NODE_LABEL">BLANK_NODE_LABEL</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">'_:' <a href="#rPN_LOCAL">PN_LOCAL</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[74]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rVAR1" name="rVAR1">VAR1</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">'?' <a href="#rVARNAME">VARNAME</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[75]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rVAR2" name="rVAR2">VAR2</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">'$' <a href="#rVARNAME">VARNAME</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[76]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rLANGTAG" name="rLANGTAG">LANGTAG</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">'@' [a-zA-Z]+ ('-' [a-zA-Z0-9]+)*</code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[77]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rINTEGER" name="rINTEGER">INTEGER</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">[0-9]+</code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[78]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rDECIMAL" name="rDECIMAL">DECIMAL</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">[0-9]+ '.' [0-9]* | '.' [0-9]+</code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[79]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rDOUBLE" name="rDOUBLE">DOUBLE</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">[0-9]+ '.' [0-9]* <a href="#rEXPONENT">EXPONENT</a> | '.' ([0-9])+ <a href="#rEXPONENT">EXPONENT</a> | ([0-9])+ <a href="#rEXPONENT">EXPONENT</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[80]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rINTEGER_POSITIVE" name="rINTEGER_POSITIVE">INTEGER_POSITIVE</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'+'</span> <a href="#rINTEGER">INTEGER</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[81]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rDECIMAL_POSITIVE" name="rDECIMAL_POSITIVE">DECIMAL_POSITIVE</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'+'</span> <a href="#rDECIMAL">DECIMAL</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[82]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rDOUBLE_POSITIVE" name="rDOUBLE_POSITIVE">DOUBLE_POSITIVE</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'+'</span> <a href="#rDOUBLE">DOUBLE</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[83]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rINTEGER_NEGATIVE" name="rINTEGER_NEGATIVE">INTEGER_NEGATIVE</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'-'</span> <a href="#rINTEGER">INTEGER</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[84]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rDECIMAL_NEGATIVE" name="rDECIMAL_NEGATIVE">DECIMAL_NEGATIVE</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'-'</span> <a href="#rDECIMAL">DECIMAL</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[85]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rDOUBLE_NEGATIVE" name="rDOUBLE_NEGATIVE">DOUBLE_NEGATIVE</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'-'</span> <a href="#rDOUBLE">DOUBLE</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[86]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rEXPONENT" name="rEXPONENT">EXPONENT</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">[eE] [+-]? [0-9]+</code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[87]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rSTRING_LITERAL1" name="rSTRING_LITERAL1">STRING_LITERAL1</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">"'" ( ([^#x27#x5C#xA#xD]) | <a href="#rECHAR">ECHAR</a> )* "'"</code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[88]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rSTRING_LITERAL2" name="rSTRING_LITERAL2">STRING_LITERAL2</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">'"' ( ([^#x22#x5C#xA#xD]) | <a href="#rECHAR">ECHAR</a> )* '"'</code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[89]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rSTRING_LITERAL_LONG1" name="rSTRING_LITERAL_LONG1">STRING_LITERAL_LONG1</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">"'''" ( ( "'" | "''" )? ( [^'\] | <a href="#rECHAR">ECHAR</a> ) )* "'''"</code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[90]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rSTRING_LITERAL_LONG2" name="rSTRING_LITERAL_LONG2">STRING_LITERAL_LONG2</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">'"""' ( ( '"' | '""' )? ( [^"\] | <a href="#rECHAR">ECHAR</a> ) )* '"""'</code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[91]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rECHAR" name="rECHAR">ECHAR</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">'\' [tbnrf\"']</code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[92]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rNIL" name="rNIL">NIL</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">'(' <a href="#rWS">WS</a>* ')'</code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[93]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rWS" name="rWS">WS</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">#x20 | #x9 | #xD | #xA</code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[94]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rANON" name="rANON">ANON</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">'['  <a href="#rWS">WS</a>* ']'</code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[95]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rPN_CHARS_BASE" name="rPN_CHARS_BASE">PN_CHARS_BASE</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">[A-Z] | [a-z] | [#x00C0-#x00D6] | 
[#x00D8-#x00F6] | [#x00F8-#x02FF] | [#x0370-#x037D] | [#x037F-#x1FFF] | 
[#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | 
[#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]</code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[96]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rPN_CHARS_U" name="rPN_CHARS_U">PN_CHARS_U</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rPN_CHARS_BASE">PN_CHARS_BASE</a> | '_'</code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[97]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rVARNAME" name="rVARNAME">VARNAME</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">( <a href="#rPN_CHARS_U">PN_CHARS_U</a>  | [0-9] ) ( <a href="#rPN_CHARS_U">PN_CHARS_U</a> | [0-9] | #x00B7 | [#x0300-#x036F] | [#x203F-#x2040] )*</code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[98]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rPN_CHARS" name="rPN_CHARS">PN_CHARS</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rPN_CHARS_U">PN_CHARS_U</a> | '-' | [0-9] | #x00B7 | [#x0300-#x036F] | [#x203F-#x2040]</code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[99]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rPN_PREFIX" name="rPN_PREFIX">PN_PREFIX</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rPN_CHARS_BASE">PN_CHARS_BASE</a> ((<a href="#rPN_CHARS">PN_CHARS</a>|'.')* <a href="#rPN_CHARS">PN_CHARS</a>)?</code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[100]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rPN_LOCAL" name="rPN_LOCAL">PN_LOCAL</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
	    <td><code class="gRuleBody">( <a href="#rPN_CHARS_U">PN_CHARS_U</a> | [0-9] ) ((<a href="#rPN_CHARS">PN_CHARS</a>|'.')* <a href="#rPN_CHARS">PN_CHARS</a>)?</code><br>Note that <a href="#rPN_LOCAL">SPARQL local names</a> allow leading digits while <a href="http://www.w3.org/TR/2006/REC-xml-names11-20060816/#NT-LocalPart">XML local names</a> do not.</td>
</tr>
  </tbody></table>
</div>


<!-- /MARKER html GRAMMAR -->
  <p>Notes:</p>
<ol>
	<li>The SPARQL grammar is LL(1) when the rules with uppercased names are used as 
  terminals.</li>
	<li>In signed numbers, no white space is allowed between the sign and the 
  number. The <code class="gRuleHead"><a href="#rAdditiveExpression">AdditiveExpression</a></code> grammar rule 
  allows for this by covering the the two cases of an expression followed by a 
  signed number. These produce an addition or substraction of the unsigned 
  number as appropriate.</li>
</ol>
<p>Some grammar files for some commonly used tools are <a href="http://www.w3.org/2001/sw/DataAccess/rq23/parsers/">available 
  here</a>.</p>
<h2>B. <a id="conformance" name="conformance">Conformance</a></h2>
<p>See appendix <a href="#grammar">A SPARQL Grammar</a> regarding conformance of
  <a href="#defn_SPARQLQueryString">SPARQL Query strings</a>, and section
<a href="#QueryForms">10 Query Forms</a> for conformance of query results. 
See appendix <a href="#mediaType">E. Internet Media Type</a> for conformance to 
the application/sparql-query media type.</p>
<p>This specification is intended for use in conjunction with the SPARQL Protocol 
[<a href="#SPROT">SPROT</a>] and the SPARQL Query Results XML Format [<a href="#RESULTS">RESULTS</a>]. 
See those specifications for their conformance criteria.</p>
<p>Note that the SPARQL protocol describes an abstract interface as well as a network 
protocol, and the abstract interface may apply to APIs as well as network interfaces.</p>
<h2>C. <a id="security" name="security">Security Considerations</a> (Informative)</h2>
<p>SPARQL queries using FROM, FROM NAMED, or GRAPH may cause the specified URI to 
be dereferenced. This may cause additional use of network, disk or CPU resources 
along with associated secondary issues such as denial of service. The security issues 
of <a class="norm" href="http://www.ietf.org/rfc/rfc3986.txt">Uniform Resource Identifier 
(URI): Generic Syntax</a> [<a href="#rfc3986">RFC3986</a>] Section 7 should be considered. 
In addition, the contents of <code>file:</code> URIs can in some cases be accessed, 
processed and returned as results, providing unintended access to local resources.</p>
<p>The SPARQL language permits extensions, which will have their own security implications.</p>
<p>Multiple IRIs may have the same appearance. Characters in different scripts may 
look similar (a Cyrillic "о" may appear similar to a Latin "o"). A character followed 
by combining characters may have the same visual representation as another character 
(LATIN SMALL LETTER E followed by COMBINING ACUTE ACCENT has the same visual representation 
as LATIN SMALL LETTER E WITH ACUTE).
<!-- (<code>foo:resum&#40751;code> and <code>f&#1086;&#1086;:resume&#769;</code>)-->
Users of SPARQL must take care to construct queries with IRIs that match the IRIs 
in the data. Further information about matching of similar characters can be found 
in <a class="inform" href="http://www.unicode.org/reports/tr36/">Unicode Security 
Considerations</a> [<a href="#UNISEC">UNISEC</a>] and
<a class="norm" href="http://www.ietf.org/rfc/rfc3987.txt">Internationalized Resource 
Identifiers (IRIs)</a> [<a href="#rfc3987">RFC3987</a>] Section 8.</p>
<h2>D. <a id="mediaType" name="mediaType">Internet Media Type, File Extension and 
Macintosh File Type</a></h2>
<dl>
	<dt>contact:</dt>
	<dd>Eric Prud'hommeaux</dd>
	<dt>See also:</dt>
	<dd><a href="http://www.w3.org/2002/06/registering-mediatype">How to Register 
  a Media Type for a W3C Specification</a></dd>
	<dd><a href="http://www.w3.org/2001/tag/2002/0129-mime">Internet Media Type registration, 
  consistency of use</a><br>TAG Finding 3 June 2002 (Revised 4 September 2002)</dd>
</dl>
<p>The Internet Media Type / MIME Type for the SPARQL Query Language is "application/sparql-query".</p>
<p>It is recommended that sparql query files have the extension ".rq" (all lowercase) 
on all platforms.</p>
<p>It is recommended that sparql query files stored on Macintosh HFS file systems 
be given a file type of "TEXT".</p>
<dl>
	<dt>Type name:</dt>
	<dd>application</dd>
	<dt>Subtype name:</dt>
	<dd>sparql-query</dd>
	<dt>Required parameters:</dt>
	<dd>None</dd>
	<dt>Optional parameters:</dt>
	<dd>None</dd>
	<dt>Encoding considerations:</dt>
	<dd>The syntax of the SPARQL Query Language is expressed over code points in Unicode 
  [<a href="#UNICODE">UNICODE</a>]. The encoding is always UTF-8 [<a href="#rfc3629">RFC3629</a>].</dd>
	<dd>Unicode code points may also be expressed using an \uXXXX (U+0 to U+FFFF) 
  or \UXXXXXXXX syntax (for U+10000 onwards) where X is a hexadecimal digit [0-9A-F]</dd>
	<dt>Security considerations:</dt>
	<dd>See SPARQL Query appendix C, <a href="#security">Security Considerations</a> 
  as well as <a class="norm" href="http://www.ietf.org/rfc/rfc3629.txt">RFC 3629</a> 
  [<a href="#rfc3629">RFC3629</a>] section 7, Security Considerations.</dd>
	<dt>Interoperability considerations:</dt>
	<dd>There are no known interoperability issues.</dd>
	<dt>Published specification:</dt>
	<dd>This specification.</dd>
	<dt>Applications which use this media type:</dt>
	<dd>No known applications currently use this media type.</dd>
	<dt>Additional information:</dt>
	<dt>Magic number(s):</dt>
	<dd>A SPARQL query may have the string 'PREFIX' (case independent) near the beginning 
  of the document.</dd>
	<dt>File extension(s):</dt>
	<dd>".rq"</dd>
	<dt>Base URI:</dt>
	<dd>The SPARQL 'BASE &lt;IRIref&gt;' term can change the current base URI for relative 
  IRIrefs in the query language that are used sequentially later in the document.</dd>
	<dt>Macintosh file type code(s):</dt>
	<dd>"TEXT"</dd>
	<dt>Person &amp; email address to contact for further information:</dt>
	<dd>public-rdf-dawg-comments@w3.org</dd>
	<dt>Intended usage:</dt>
	<dd>COMMON</dd>
	<dt>Restrictions on usage:</dt>
	<dd>None</dd>
	<dt>Author/Change controller:</dt>
	<dd>The SPARQL specification is a work product of the World Wide Web Consortium's 
  RDF Data Access Working Group. The W3C has change control over these specifications.</dd>
</dl>
<div>
	<h2>E. <a id="references" name="references">References</a></h2>
	<h3 id="normativeRefs">Normative References</h3>
	<dl class="bib">
		<dt><a name="CHARMOD" id="CHARMOD">[CHARMOD]</a></dt>
		<dd><cite>
		<a href="http://www.w3.org/TR/2005/REC-charmod-20050215/">Character
      Model for the World Wide Web 1.0: Fundamentals</a></cite>,
      R. Ishida, F. Yergeau, M. J. Düst, M. Wolf, T. Texin,
      Editors, W3C Recommendation, 15 February 2005,
      http://www.w3.org/TR/2005/REC-charmod-20050215/ . 
		<a href="http://www.w3.org/TR/charmod/" title="Latest version of Character Model for the World Wide Web 1.0: Fundamentals">Latest version</a> available at http://www.w3.org/TR/charmod/
      .</dd>
		<dt><a name="CONCEPTS" id="CONCEPTS">[CONCEPTS]</a></dt>
		<dd><cite>
		<a href="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/">Resource
      Description Framework (RDF): Concepts and Abstract
      Syntax</a></cite>, G. Klyne, J. J. Carroll, Editors, W3C
      Recommendation, 10 February 2004,
      http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/ .
      	<a href="http://www.w3.org/TR/rdf-concepts/" title="Latest version of Resource Description Framework (RDF): Concepts and Abstract Syntax">Latest version</a> available at
      http://www.w3.org/TR/rdf-concepts/ .</dd>
		<dt><a name="FUNCOP" id="FUNCOP">[FUNCOP]</a></dt>
		<dd><cite>
		<a href="http://www.w3.org/TR/2007/REC-xpath-functions-20070123/">XQuery
      1.0 and XPath 2.0 Functions and Operators</a></cite>, J.
      Melton, A. Malhotra, N. Walsh, Editors, W3C Recommendation,
      23 January 2007,
      http://www.w3.org/TR/2007/REC-xpath-functions-20070123/ .
      	<a href="http://www.w3.org/TR/xpath-functions/" title="Latest version of XQuery 1.0 and XPath 2.0 Functions and Operators">Latest version</a> available at
      http://www.w3.org/TR/xpath-functions/ .</dd>
		<dt><a id="RDF-MT" name="RDF-MT">[RDF-MT]</a></dt>
		<dd><cite>
		<a href="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/">RDF
      Semantics</a></cite>, P. Hayes, Editor, W3C Recommendation,
      10 February 2004,
      http://www.w3.org/TR/2004/REC-rdf-mt-20040210/ . 
		<a title="Latest version of RDF Semantics" href="http://www.w3.org/TR/rdf-mt/">Latest version</a> available
      at http://www.w3.org/TR/rdf-mt/ .</dd>
		<dt><a name="rfc3629" id="rfc3629">[RFC3629]</a></dt>
		<dd>RFC 3629 <cite>
		<a href="http://www.ietf.org/rfc/rfc3629.txt">UTF-8, a transformation
      format of ISO 10646</a></cite>, F. Yergeau November 2003</dd>

	<dt><a name="rfc4647" id="rfc4647">[RFC4647]</a></dt>
	<dd>RFC 4647 <cite><a href="http://www.ietf.org/rfc/rfc4647.txt">Matching of Language Tags</a></cite>, A. Phillips, M. Davis September 2006</dd>

		<dt><a name="rfc3986" id="rfc3986">[RFC3986]</a></dt>
		<dd>RFC 3986 <cite>
		<a href="http://www.ietf.org/rfc/rfc3986.txt">Uniform Resource
      Identifier (URI): Generic Syntax</a></cite>, T. Berners-Lee,
      R. Fielding, L. Masinter January 2005</dd>
		<dt><a name="rfc3987" id="rfc3987">[RFC3987]</a></dt>
		<dd><a href="http://www.ietf.org/rfc/rfc3987.txt">RFC
      3987</a>, "Internationalized Resource Identifiers (IRIs)", M.
      Dürst , M. Suignard</dd>
		<dt><a name="UNICODE" id="UNICODE">[UNICODE]</a></dt>
		<dd><cite>The Unicode Standard, Version 4</cite>. ISBN
      0-321-18578-1, as updated from time to time by the
      publication of new versions. The latest version of Unicode
      and additional information on versions of the standard and of
      the Unicode Character Database is available at 
		<a href="http://www.unicode.org/unicode/standard/versions/">http://www.unicode.org/unicode/standard/versions/</a>.</dd>
		<dt><a name="XML11" id="XML11">[XML11]</a></dt>
		<dd><cite>
		<a href="http://www.w3.org/TR/2004/REC-xml11-20040204/">Extensible
      Markup Language (XML) 1.1</a></cite>, J. Cowan, J. Paoli, E.
      Maler, C. M. Sperberg-McQueen, F. Yergeau, T. Bray, Editors,
      W3C Recommendation, 4 February 2004,
      http://www.w3.org/TR/2004/REC-xml11-20040204/ . 
		<a href="http://www.w3.org/TR/xml11/" title="Latest version of Extensible Markup Language (XML) 1.1">Latest
      version</a> available at http://www.w3.org/TR/xml11/ .</dd>
		<dt><a name="XPATH20" id="XPATH20">[XPATH20]</a></dt>
		<dd><cite>
		<a href="http://www.w3.org/TR/2007/REC-xpath20-20070123/">XML Path
      Language (XPath) 2.0</a></cite>, A. Berglund, S. Boag, D. Chamberlin, M. F. Fernández, M. Kay, J. Robie, J. Siméon,
      Editors, W3C Recommendation, 23 January 2007,
      http://www.w3.org/TR/2007/REC-xpath20-20070123/ . 
		<a href="http://www.w3.org/TR/xpath20/" title="Latest version of XML Path Language (XPath) 2.0">Latest
      version</a> available at http://www.w3.org/TR/xpath20/ .</dd>
		<dt><a name="XQUERY" id="XQUERY">[XQUERY]</a></dt>
		<dd><cite>
		<a href="http://www.w3.org/TR/2007/REC-xquery-20070123/">XQuery 1.0:
      An XML Query Language</a></cite>, S. Boag, D. Chamberlin, M. F. Fernández, D. Florescu, J. Robie, J. Siméon, Editors, W3C Recommendation, 23
      January 2007, http://www.w3.org/TR/2007/REC-xquery-20070123/.
      	<a href="http://www.w3.org/TR/xquery/" title="Latest version of XQuery 1.0: An XML Query Language">Latest
      version</a> available at http://www.w3.org/TR/xquery/ . 
      <!-- odd... bib generator knows it as http://www.w3.org/TR/xquery
      but the title page says http://www.w3.org/TR/xquery/ --></dd>
		<dt><a name="XSDT" id="XSDT">[XSDT]</a></dt>
		<dd><cite>
		<a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/">XML
      Schema Part 2: Datatypes Second Edition</a></cite>, P. V.
      Biron, A. Malhotra, Editors, W3C Recommendation, 28 October
      2004, http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/ .
      	<a href="http://www.w3.org/TR/xmlschema-2/" title="Latest version of XML Schema Part 2: Datatypes Second Edition">Latest version</a> available at
      http://www.w3.org/TR/xmlschema-2/ .</dd>
	<dt><a name="BCP47" id="BCP47">[BCP47]</a></dt>
	<dd><cite><a href="http://www.rfc-editor.org/rfc/bcp/bcp47.txt">Best Common Practice 47</a></cite>, P. V. Biron, A. Malhotra, Editors, W3C Recommendation, 28 October 2004, http://www.rfc-editor.org/rfc/bcp/bcp47.txt .</dd>
	</dl>
	<h3 id="informativeRefs">Informative References</h3>
	<dl class="bib">
		<dt><a name="CBD" id="CBD">[CBD]</a></dt>
		<dd><cite><a href="http://www.w3.org/Submission/CBD/">CBD - Concise 
        Bounded Description</a></cite>, Patrick Stickler, Nokia, W3C Member 
        Submission, 3 June 2005.</dd>
		<dt><a name="DC" id="DC">[DC]</a></dt>
		<dd><cite>
		<a href="http://www.dublincore.org/documents/dcmes-xml/">Expressing
      Simple Dublin Core in RDF/XML</a></cite>
		<a href="http://dublincore.org/">Dublin Core Dublin Core Metadata
      Initiative</a> Recommendation 2002-07-31.</dd><!--
    <dt><a name="namespace" id="namespace">[NAMESPACE]</a></dt>
    <dd>
      <cite><a
      href="http://www.w3.org/TR/2004/REC-xml-names11-20040204">Namespaces
      in XML 1.1</a> </cite>, T. Bray, A. Layman, D. Hollander,
      R. Tobin, Editors, W3C Recommendation, 4 February 2004,
      http://www.w3.org/TR/2004/REC-xml-names11-20040204 . <a
      href="http://www.w3.org/TR/xml-names11" title="Latest version
      of Namespaces in XML 1.1">Latest version</a> available at
      http://www.w3.org/TR/xml-names11/ .
    </dd>
-->
        <dt><a id="multiset" name="multiset">[Multiset]</a></dt>
        <dd><cite>
            <a href="http://en.wikipedia.org/w/index.php?title=Multiset&amp;oldid=163605900">Multiset</a></cite>, Wikipedia, The Free Encyclopedia.
            Article as given on October 25, 2007 at http://en.wikipedia.org/w/index.php?title=Multiset&amp;oldid=163605900. The 
            <a href="http://en.wikipedia.org/wiki/Multiset">latest version</a> of this article is at http://en.wikipedia.org/wiki/Multiset.
            </dd>
      	<dt><a id="OWL_Semantics" name="OWL_Semantics">[OWL-Semantics]</a></dt>
		<dd><cite>
		<a href="http://www.w3.org/TR/2004/REC-owl-semantics-20040210/">OWL
      Web Ontology Language Semantics and Abstract
      Syntax</a></cite>, Peter F. Patel-Schneider, Patrick Hayes,
      Ian Horrocks, Editors, W3C Recommendation
      http://www.w3.org/TR/2004/REC-owl-semantics-20040210/.
      	<a href="http://www.w3.org/TR/owl-semantics/">Latest
      version</a> at <a href="http://www.w3.org/TR/owl-semantics/">http://www.w3.org/TR/owl-semantics/</a>.</dd>


	<dt><a id="rdfschema" name="rdfschema">[RDFS]</a></dt>
	<dd>
	  <cite><a href="http://www.w3.org/TR/2004/REC-rdf-schema-20040210/">RDF Vocabulary Description Language 1.0: RDF Schema</a></cite>,
	  Dan Brickley, R.V. Guha, Editors,
	  W3C Recommendation,
	  10 February 2004,
	  http://www.w3.org/TR/2004/REC-rdf-schema-20040210/ .
	  <a href="http://www.w3.org/TR/rdf-schema/">Latest version</a> at <a href="http://www.w3.org/TR/rdf-schema/">http://www.w3.org/TR/rdf-schema/</a> .
	</dd>
		<dt><a name="RESULTS" id="RESULTS">[RESULTS]</a></dt>
		<dd><cite>
		<a href="http://www.w3.org/TR/2008/REC-rdf-sparql-XMLres-20080115/">SPARQL
      Query Results XML Format</a></cite>, D. Beckett, Editor, W3C
      Recommendation, 15 January 2008,
      http://www.w3.org/TR/2008/REC-rdf-sparql-XMLres-20080115/ .
      	<a href="http://www.w3.org/TR/rdf-sparql-XMLres/" title="Latest version of SPARQL Query Results XML Format">Latest
      version</a> available at 
		<a href="http://www.w3.org/TR/rdf-sparql-XMLres/">http://www.w3.org/TR/rdf-sparql-XMLres/</a>
      .</dd>
		<dt><a id="SPROT" name="SPROT">[SPROT]</a></dt>
		<dd><cite>
		<a href="http://www.w3.org/TR/2008/REC-rdf-sparql-protocol-20080115/">SPARQL
      Protocol for RDF</a></cite>, K. Clark, Editor, W3C Recommendation,
      15 January 2008,
      http://www.w3.org/TR/2008/REC-rdf-sparql-protocol-20080115/ .
      	<a title="Latest version of SPARQL Protocol for RDF" href="http://www.w3.org/TR/rdf-sparql-protocol/">Latest
      version</a> available at
      http://www.w3.org/TR/rdf-sparql-protocol/ .</dd>
		<dt><a name="TURTLE" id="TURTLE">[TURTLE]</a></dt>
		<dd><a href="http://www.w3.org/TeamSubmission/turtle/">Turtle - Terse
      RDF Triple Language</a>, Dave Beckett.</dd>
		<dt><a name="UCNR" id="UCNR">[UCNR]</a></dt>
		<dd><cite>
		<a href="http://www.w3.org/TR/2005/WD-rdf-dawg-uc-20050325/">RDF Data
      Access Use Cases and Requirements</a></cite>, K. Clark,
      Editor, W3C Working Draft, 25 March 2005,
      http://www.w3.org/TR/2005/WD-rdf-dawg-uc-20050325/ . 
		<a href="http://www.w3.org/TR/rdf-dawg-uc/" title="Latest version of RDF Data Access Use Cases and Requirements">Latest version</a> available at
      http://www.w3.org/TR/rdf-dawg-uc/ .</dd>
		<dt><a name="UNISEC" id="UNISEC">[UNISEC]</a></dt>
		<dd><cite><a href="http://www.unicode.org/reports/tr36/">Unicode Security
      Considerations</a></cite>, Mark Davis, Michel Suignard</dd>

	<dt><a id="VCARD" name="VCARD">[VCARD]</a></dt>
	<dd>
	  <cite><a href="http://www.w3.org/TR/2001/NOTE-vcard-rdf-20010222/">Representing vCard Objects in RDF/XML</a></cite>,
	  Renato Iannella,
	  W3C Note,
	  22 February 2001,
	  http://www.w3.org/TR/2001/NOTE-vcard-rdf-20010222/ .
	  <a href="http://www.w3.org/TR/vcard-rdf">Latest version</a> is available at <tt>http://www.w3.org/TR/vcard-rdf</tt> .
	</dd>

	<dt><a name="WEBARCH" id="WEBARCH">[WEBARCH]</a></dt>
	<dd>
	  <cite><a href="http://www.w3.org/TR/2004/REC-webarch-20041215/">Architecture of the World Wide Web, Volume One</a></cite>, 
	  I. Jacobs, N. Walsh, Editors,
	  W3C Recommendation,
	  15 December 2004,
	  http://www.w3.org/TR/2004/REC-webarch-20041215/ .
	  <a href="http://www.w3.org/TR/webarch/">Latest version</a> is available at <tt>http://www.w3.org/TR/webarch/</tt> .
	</dd>

		<dt><a name="UNIID" id="UNIID">[UNIID]</a></dt>
		<dd><cite>
		<a href="http://www.unicode.org/reports/tr31/tr31-5.html">Identifier
      and Pattern Syntax 4.1.0</a></cite>, Mark Davis, Unicode
      Standard Annex #31, 25 March 2005,
      http://www.unicode.org/reports/tr31/tr31-5.html . 
		<a href="http://www.unicode.org/reports/tr31/" title="Latest version of Identifier and Pattern Syntax">Latest
      version</a> available at <a href="http://www.unicode.org/reports/tr31/">http://www.unicode.org/reports/tr31/</a>
      .</dd>
      <dt>[<a name="refSemantics1" id="refSemantics1">SPARQL-sem-05</a>]</dt>
      <dd><cite><a href="http://www.hpl.hp.com/techreports/2005/HPL-2005-170.html">A relational
      algebra for SPARQL</a></cite>, Richard Cyganiak, 2005</dd>
      <dt>[<a name="refSemantics3" id="refSemantics2">SPARQL-sem-06</a>]</dt>
      <dd><cite><a href="http://arxiv.org/abs/cs/0605124">Semantics of SPARQL</a></cite>, Jorge Pérez, Marcelo Arenas, and Claudio Gutierrez, 
      2006</dd>
</dl></div>

<h2>F. <a name="acknowledgements" id="acknowledgements">Acknowledgements</a> (Informative)</h2>
<p>The SPARQL RDF Query Language is a product of the whole of the
<a href="http://www.w3.org/2001/sw/DataAccess/">W3C RDF Data Access Working Group</a>, 
and our thanks for discussions, comments and reviews go to all
<a href="http://www.w3.org/2001/sw/DataAccess/#who">present and past members</a>.</p>
<p>In addition, we have had comments and discussions with many people through the 
working group comments list. All comments go to making a better document. Andy would 
also like to particularly thank Jorge Peérez, Geoff Chappell, Bob MacGregor, Yosi Scharf 
and Richard 
Newman for exploring specific issues related to SPARQL. Eric would like to acknowledge 
the invaluable help of Björn Höhrmann.</p>


<div class="changes">
	<h2><a name="chlog" id="chlog">Change Log</a></h2>
    <p>This is a high-level summary of changes made to this document since publication of the 
    <a href="http://www.w3.org/TR/2007/PR-rdf-sparql-query-20071112/">14 June 2007 Candidate 
    Recommendation</a>:</p>

    <ul>
	<li>In §9 <a href="#solutionModifiers">Solution Sequences and Modifiers</a>, the term <tt>solution set</tt> was changed to <tt>solution sequence</tt>.</li>
	<li>The media type <code>application/sparql-query</code> was approved so the text about the status of that request was removed.</li>
    </ul>
</div>

<div class="nav"><a href="http://validator.w3.org/check/referer">
	<img src="SPARQL%20Query%20Language%20for%20RDF_files/valid-xhtml10.png" alt="Valid XHTML 1.0!" width="88" height="31"></a>
</div><hr>

</body></html>